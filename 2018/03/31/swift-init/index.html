<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Swift 初始化 | ZYF.IM BLOG</title><meta name=keywords content="ios,swift"><meta name=description content='因为自己是直接从 Swift 进入的 iOS 开发，Swift 与 Objective-C 初始化的对比就不多提了。感觉上 Swift 初始化的方式像 Java，自己也只这样套着 Java 去理解，但也发现了不相同的地方。
初始化顺序
class Blog: NSObject {
    let param: String

    override init() {
    }
}
这里有条错误 error: property &#39;self.param&#39; not initialized at implicitly generated super.init call 说明：param 参数没有在隐式生成 super.init 调用之前完成初始化。
Swift 中并不是不调用 super.init 而是为了方便开发者由编译器完成了这一步，但是要求调用 super.init 之前要完成成员变量的初始化。

class Blog: NSObject {
    let param: String

    override init() {
        param = "swift init"
    }
}
对于需要修改父类中成员变量值，我们需要在调用 super.init 之后再进行修改：
class Cat {
    var name: String

    init() {
        name = "cat"
    }
}

class Tiger: Cat {
    let power: Int

    override init() {
        power = 10
        super.init()
        name = "tiger"
    }
}
Swift 中类的初始化顺序：'><meta name=author content="Me"><link rel=canonical href=https://zyf.im/2018/03/31/swift-init/><link crossorigin=anonymous href=/assets/css/stylesheet.63618a0fd0c7dd946ad6f368012c097fc6e5a8464cefd289c140dd28c01ec58d.css integrity="sha256-Y2GKD9DH3ZRq1vNoASwJf8blqEZM79KJwUDdKMAexY0=" rel="preload stylesheet" as=style><link rel=icon href=https://zyf.im/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zyf.im/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://zyf.im/favicon-32x32.png><link rel=apple-touch-icon href=https://zyf.im/apple-touch-icon.png><link rel=mask-icon href=https://zyf.im/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://zyf.im/2018/03/31/swift-init/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-6DVZ6E58DG"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-6DVZ6E58DG")}</script><meta property="og:url" content="https://zyf.im/2018/03/31/swift-init/"><meta property="og:site_name" content="ZYF.IM BLOG"><meta property="og:title" content="Swift 初始化"><meta property="og:description" content='因为自己是直接从 Swift 进入的 iOS 开发，Swift 与 Objective-C 初始化的对比就不多提了。感觉上 Swift 初始化的方式像 Java，自己也只这样套着 Java 去理解，但也发现了不相同的地方。
初始化顺序 class Blog: NSObject { let param: String override init() { } } 这里有条错误 error: property &#39;self.param&#39; not initialized at implicitly generated super.init call 说明：param 参数没有在隐式生成 super.init 调用之前完成初始化。
Swift 中并不是不调用 super.init 而是为了方便开发者由编译器完成了这一步，但是要求调用 super.init 之前要完成成员变量的初始化。
class Blog: NSObject { let param: String override init() { param = "swift init" } } 对于需要修改父类中成员变量值，我们需要在调用 super.init 之后再进行修改：
class Cat { var name: String init() { name = "cat" } } class Tiger: Cat { let power: Int override init() { power = 10 super.init() name = "tiger" } } Swift 中类的初始化顺序：'><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-03-31T17:00:00+08:00"><meta property="article:modified_time" content="2018-03-31T17:00:00+08:00"><meta property="article:tag" content="Ios"><meta property="article:tag" content="Swift"><meta name=twitter:card content="summary"><meta name=twitter:title content="Swift 初始化"><meta name=twitter:description content='因为自己是直接从 Swift 进入的 iOS 开发，Swift 与 Objective-C 初始化的对比就不多提了。感觉上 Swift 初始化的方式像 Java，自己也只这样套着 Java 去理解，但也发现了不相同的地方。
初始化顺序
class Blog: NSObject {
    let param: String

    override init() {
    }
}
这里有条错误 error: property &#39;self.param&#39; not initialized at implicitly generated super.init call 说明：param 参数没有在隐式生成 super.init 调用之前完成初始化。
Swift 中并不是不调用 super.init 而是为了方便开发者由编译器完成了这一步，但是要求调用 super.init 之前要完成成员变量的初始化。

class Blog: NSObject {
    let param: String

    override init() {
        param = "swift init"
    }
}
对于需要修改父类中成员变量值，我们需要在调用 super.init 之后再进行修改：
class Cat {
    var name: String

    init() {
        name = "cat"
    }
}

class Tiger: Cat {
    let power: Int

    override init() {
        power = 10
        super.init()
        name = "tiger"
    }
}
Swift 中类的初始化顺序：'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zyf.im/posts/"},{"@type":"ListItem","position":2,"name":"Swift 初始化","item":"https://zyf.im/2018/03/31/swift-init/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Swift 初始化","name":"Swift 初始化","description":"因为自己是直接从 Swift 进入的 iOS 开发，Swift 与 Objective-C 初始化的对比就不多提了。感觉上 Swift 初始化的方式像 Java，自己也只这样套着 Java 去理解，但也发现了不相同的地方。\n初始化顺序 class Blog: NSObject { let param: String override init() { } } 这里有条错误 error: property 'self.param' not initialized at implicitly generated super.init call 说明：param 参数没有在隐式生成 super.init 调用之前完成初始化。\nSwift 中并不是不调用 super.init 而是为了方便开发者由编译器完成了这一步，但是要求调用 super.init 之前要完成成员变量的初始化。\nclass Blog: NSObject { let param: String override init() { param = \u0026#34;swift init\u0026#34; } } 对于需要修改父类中成员变量值，我们需要在调用 super.init 之后再进行修改：\nclass Cat { var name: String init() { name = \u0026#34;cat\u0026#34; } } class Tiger: Cat { let power: Int override init() { power = 10 super.init() name = \u0026#34;tiger\u0026#34; } } Swift 中类的初始化顺序：\n","keywords":["ios","swift"],"articleBody":"因为自己是直接从 Swift 进入的 iOS 开发，Swift 与 Objective-C 初始化的对比就不多提了。感觉上 Swift 初始化的方式像 Java，自己也只这样套着 Java 去理解，但也发现了不相同的地方。\n初始化顺序 class Blog: NSObject { let param: String override init() { } } 这里有条错误 error: property 'self.param' not initialized at implicitly generated super.init call 说明：param 参数没有在隐式生成 super.init 调用之前完成初始化。\nSwift 中并不是不调用 super.init 而是为了方便开发者由编译器完成了这一步，但是要求调用 super.init 之前要完成成员变量的初始化。\nclass Blog: NSObject { let param: String override init() { param = \"swift init\" } } 对于需要修改父类中成员变量值，我们需要在调用 super.init 之后再进行修改：\nclass Cat { var name: String init() { name = \"cat\" } } class Tiger: Cat { let power: Int override init() { power = 10 super.init() name = \"tiger\" } } Swift 中类的初始化顺序：\n初始化自己的成员变量，必须 调用父类初始化方法，如无需第三步，则这一步也可省略 修改父类成员变量，可选 补充说明：\nlet 声明的常量是可以在初始化方法中进行赋值，Swift 中的 init 方法只会被调用一次，这与 Objective-C 不同 即使成员变量是可选类型，如：let power: Int? 仍然是需要进行初始化的，var power: Int? 则可以不用 关键字 例子 1：\nclass CustomView: UIView { let param: Int override init() { // error 1 self.param = 1 super.init() // error 2 } } // error 3 将父类从 NSObject 修改为 UIView，竟然收到 3 条错误：\ninitializer does not override a designated initializer from its superclass must call a designated initializer of the superclass ‘UIView’ ‘required’ initializer ‘init(coder:)’ must be provided by subclass of ‘UIView’ 例子 2：\nclass CustomView: UIView { convenience init(param: Int, frame: CGRect) { super.init(frame: frame) // error } required init?(coder aDecoder: NSCoder) { fatalError(\"init(coder:) has not been implemented\") } } error：\nconvenience initializer for ‘CustomView’ must delegate (with ‘self.init’) rather than chaining to a superclass 上面俩个例子出现了 3 个关键字：designated、convenience 和 required。\ndesignated Swift 定义了两种类初始化器类型，用来保证所有成员属性能够获得一个初始化值。即 designated initializers [i’niʃəlaizə] 和 convenience initializers。\nDesignated initializers are the primary initializers for a class. A designated initializer fully initializes all properties introduced by that class and calls an appropriate superclass initializer to continue the initialization process up the superclass chain.\nprimary initializers：designated initializers 是一个类的主初始化器，理论上来说是一个类初始化的必经之路。（不同的初始化路径可能调用不同的 designated initializers） fully initializes all properties：必须在 designated initializers 中完成所有成员属性的初始化 calls an appropriate superclass initializer：需要调用合适的父类初始化器完成初始化，不能随意调用 在 Swift 中 designated initializers 的写法和一般的初始化方法无异，Sample 1 中，我们试图去 override init，可以理解为我们就是在 override 一个 designated initializers，然后我们收到了错误 Initializer does not override a designated initializer from its superclass，可见我们并没有找到合适的 designated initializers，我们进入父类 UIView，可以看到下面两个初始化方法：\npublic init(frame: CGRect) public init?(coder aDecoder: NSCoder) 原来，这两个类才是父类的 designated initializers，那我们改改试试：\nclass CustomView: UIView { let param: Int override init(frame: CGRect) { // error 1 fixed self.param = 1 super.init(frame: frame) // error 2 fixed } } // error 3 error 1 fixed 由此可见：我们去 override 一个不是 designated initializers 的初始化器时，是不满足定义中所说的 primary initializers，这就可能导致这个初始化器不被执行，成员变量没有初始化，这样创建的“半成品”实例可能存在一些不安全的情况。\n第二条 fully initializes all properties，这点我们并没有犯错，因为我们已经初始化了 CustomView 类中引入的 param 变量。\n第三条 calls an appropriate superclass initializer 很明显就对应了 error 2，我们 override init(frame:)，那我们就必须调用对应的父类初始化方法。\nerror 3 提示我们 init(coder:) 是一个 ‘required’ initializer，子类必须提供\nrequired Write the required modifier before the definition of a class initializer to indicate that every subclass of the class must implement that initializer.\n通过添加 required 关键字强制子类对某个初始化方法进行重写。\nclass CustomView: UIView { let param: Int override init(frame: CGRect) { // error 1 fixed self.param = 1 super.init(frame: frame) // error 2 fixed } required init?(coder aDecoder: NSCoder) { fatalError(\"init(coder:) has not been implemented\") } } // error 3 fixed error 3 fixed 插入的这个方法很奇怪，方法体里直接写 fatalError(\"init(coder:) has not been implemented\")，那岂不是走到这里就 crash 了？\ndesignated initializers 是一个类的主初始化器，理论上来说是一个类初始化的必经之路（不同的初始化路径可能调用不同的 designated initializers），其实，这个 init(coder:) 与 init(frame: frame) 就是不同的初始化路径，当我们使用 xib 方式初始化一个 view 时，就会走到 init(coder:)。此时，如果我们没有真正实现这个方法，就会出现 fatal crash。\n完整初始方案：\nclass CustomView: UIView { let param: Int override init(frame: CGRect) { self.param = 1 super.init(frame: frame) } required init?(coder aDecoder: NSCoder) { self.param = 1 super.init(coder: aDecoder) } } convenience Convenience initializers are secondary, supporting initializers for a class. You can define a convenience initializer to call a designated initializer from the same class as the convenience initializer with some of the designated initializer’s parameters set to default values. You can also define a convenience initializer to create an instance of that class for a specific use case or input value type.\nconvenience initializers 是对类初始化方法的补充，用于为类提供一些快捷的初始化方法，可以不创建这类方法，但如果创建了，就需要遵循原则：call a designated initializer from the same class，也就是说要调用该类自己的 designated initializer，那么我们应该 override init(frame:) ，然后修改为：\nclass CustomView: UIView { convenience init(param: Int, frame: CGRect) { self.init(frame: frame) // error fixed } override init(frame: CGRect) { super.init(frame: frame) } required init?(coder aDecoder: NSCoder) { fatalError(\"init(coder:) has not been implemented\") } } 然后对成员变量 param 赋值：\nclass CustomView: UIView { var param: Int convenience init(param: Int, frame: CGRect) { self.param = param // error self.init(frame: frame) } override init(frame: CGRect) { super.init(frame: frame) // error } required init?(coder aDecoder: NSCoder) { fatalError(\"init(coder:) has not been implemented\") } } 来个两个错误：\nUse of ‘self’ in property access ‘param’ before self.init initializes self Property ‘self.param’ not initialized at super.init call 第二个错误我们清楚，是需要在调用 super.init 之前初始化本类成员属性。\n第一个错误其实，这是 Swift 编译器提供的安全检查，文档原文如下：\nA convenience initializer must delegate to another initializer before assigning a value to any property (including properties defined by the same class). If it doesn’t, the new value the convenience initializer assigns will be overwritten by its own class’s designated initializer.\n原来 Swift 防止 convenience initializers 中赋值之后又被该类自己的 designated initializer 覆盖而做了检查。因此，正确的方式应该是调用该类的其他初始化方法之后再修改属性值，最终修改如下：\nclass CustomView: UIView { var param: Int convenience init(param: Int, frame: CGRect) { self.init(frame: frame) self.param = param // error fixed } override init(frame: CGRect) { self.param = 0 // error fixed super.init(frame: frame) } required init?(coder aDecoder: NSCoder) { self.param = 0 super.init(coder: aDecoder) } } 小结 子类中初始化方法必须覆盖全部初始化路径，以保证对象完全初始化 子类中 designated initializer 必须调用父类中对应的 designated initializer，以保证父类也能完成初始化 子类中如果重写父类中 convenience initializer 所需要的全部 init 方法，就可以在子类中使用父类的 convenience initializer 了 子类如果没有定义任何 designated initializer，则默认继承所有父类的 designated initializer 及 convenience initializer 子类中必须实现的 designated initializer，可以通过添加 required 关键字强制子类重写其实现，以保证依赖该方法的 convenience initializer 始终可以使用 convenience initializer 必须调用自身类中的其他初始化方法，并在最终必须调用一个 designated initializer 在构造器完成初始化之前, 不能调用任何实例方法，或读取任何实例属性的值，self 本身也不能被引用 可失败初始化器 可失败初始化器 Failable Initializers ，即可能返回 nil 的初始化方法。\nA failable initializer creates an optional value of the type it initializes. You write return nil within a failable initializer to indicate a point at which initialization failure can be triggered.\n就是将初始化返回值变成 optional value，并在不满足初始化条件的地方 return nil。通过调用处判断是否有值即可知道是否初始化成功。\nclass Product { let name: String init?(name: String) { if name.isEmpty { return nil } self.name = name } } class CartItem: Product { let quantity: Int init?(name: String, quantity: Int) { if quantity \u003c 1 { return nil } self.quantity = quantity super.init(name: name) } } CartItem 类的初始化方法先对传入参数 quantity 的值进行判断，小于 1 则为无效参数，然后 return nil（初始化失败），大于或等于 1 则继续调用父类 Product 的初始化方法，再次判断传入参数 name，为空则 return nil（初始化失败），否则继续初始化。\n总的来说，可失败初始化器的设定，是在保证安全性的基础上提供了逻辑上更清晰的初始化方式。Failable Initializers 所有的结果都将是 T? 类型，通过 Optional Binding 方式，我们就能知道初始化是否成功，并安全地使用它们了。\nReferences 从 Swift 初始化说起 The Swift Programming Language (Swift 4.1) Initialization Swift 类构造器的使用 – EOF –\n","wordCount":"972","inLanguage":"en","datePublished":"2018-03-31T17:00:00+08:00","dateModified":"2018-03-31T17:00:00+08:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zyf.im/2018/03/31/swift-init/"},"publisher":{"@type":"Organization","name":"ZYF.IM BLOG","logo":{"@type":"ImageObject","url":"https://zyf.im/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://zyf.im/ accesskey=h title="ZYF.IM (Alt + H)"><img src=https://zyf.im/apple-touch-icon.png alt aria-label=logo height=35>ZYF.IM</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://zyf.im/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://zyf.im/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://zyf.im/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://zyf.im/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://zyf.im/>Home</a>&nbsp;»&nbsp;<a href=https://zyf.im/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Swift 初始化</h1><div class=post-meta><span title='2018-03-31 17:00:00 +0800 CST'>March 31, 2018</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;972 words&nbsp;·&nbsp;Me</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#初始化顺序>初始化顺序</a></li><li><a href=#关键字>关键字</a><ul><li><a href=#designated>designated</a></li><li><a href=#required>required</a></li><li><a href=#convenience>convenience</a></li><li><a href=#小结>小结</a></li></ul></li><li><a href=#可失败初始化器>可失败初始化器</a></li><li><a href=#references>References</a></li></ul></nav></div></details></div><div class=post-content><p>因为自己是直接从 Swift 进入的 iOS 开发，Swift 与 Objective-C 初始化的对比就不多提了。感觉上 Swift 初始化的方式像 Java，自己也只这样套着 Java 去理解，但也发现了不相同的地方。</p><h2 id=初始化顺序>初始化顺序<a hidden class=anchor aria-hidden=true href=#初始化顺序>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=kd>class</span> <span class=nc>Blog</span><span class=p>:</span> <span class=n>NSObject</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>let</span> <span class=nv>param</span><span class=p>:</span> <span class=nb>String</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kr>override</span> <span class=kd>init</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>这里有条错误 <code>error: property 'self.param' not initialized at implicitly generated super.init call</code> 说明：<code>param</code> 参数没有在隐式生成 <code>super.init</code> 调用之前完成初始化。</p><p>Swift 中并不是不调用 <code>super.init</code> 而是为了方便开发者由编译器完成了这一步，但是要求调用 <code>super.init</code> 之前要完成成员变量的初始化。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=kd>class</span> <span class=nc>Blog</span><span class=p>:</span> <span class=n>NSObject</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>let</span> <span class=nv>param</span><span class=p>:</span> <span class=nb>String</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kr>override</span> <span class=kd>init</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>param</span> <span class=p>=</span> <span class=s>&#34;swift init&#34;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>对于需要修改父类中成员变量值，我们需要在调用 <code>super.init</code> 之后再进行修改：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=kd>class</span> <span class=nc>Cat</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nv>name</span><span class=p>:</span> <span class=nb>String</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>init</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>name</span> <span class=p>=</span> <span class=s>&#34;cat&#34;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>class</span> <span class=nc>Tiger</span><span class=p>:</span> <span class=n>Cat</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>let</span> <span class=nv>power</span><span class=p>:</span> <span class=nb>Int</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kr>override</span> <span class=kd>init</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>power</span> <span class=p>=</span> <span class=mi>10</span>
</span></span><span class=line><span class=cl>        <span class=kc>super</span><span class=p>.</span><span class=kd>init</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=n>name</span> <span class=p>=</span> <span class=s>&#34;tiger&#34;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Swift 中类的初始化顺序：</p><ol><li>初始化自己的成员变量，必须</li><li>调用父类初始化方法，如无需第三步，则这一步也可省略</li><li>修改父类成员变量，可选</li></ol><p>补充说明：</p><ul><li><code>let</code> 声明的常量是可以在初始化方法中进行赋值，Swift 中的 init 方法只会被调用一次，这与 Objective-C 不同</li><li>即使成员变量是可选类型，如：<code>let power: Int?</code> 仍然是需要进行初始化的，<code>var power: Int?</code> 则可以不用</li></ul><h2 id=关键字>关键字<a hidden class=anchor aria-hidden=true href=#关键字>#</a></h2><p>例子 1：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=kd>class</span> <span class=nc>CustomView</span><span class=p>:</span> <span class=n>UIView</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>let</span> <span class=nv>param</span><span class=p>:</span> <span class=nb>Int</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kr>override</span> <span class=kd>init</span><span class=p>()</span> <span class=p>{</span> <span class=c1>// error 1</span>
</span></span><span class=line><span class=cl>        <span class=kc>self</span><span class=p>.</span><span class=n>param</span> <span class=p>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=kc>super</span><span class=p>.</span><span class=kd>init</span><span class=p>()</span> <span class=c1>// error 2</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=c1>// error 3</span>
</span></span></code></pre></div><p>将父类从 <code>NSObject</code> 修改为 <code>UIView</code>，竟然收到 3 条错误：</p><ol><li>initializer does not override a <strong>designated</strong> initializer from its superclass</li><li>must call a designated initializer of the superclass &lsquo;UIView&rsquo;</li><li><strong>&lsquo;required&rsquo;</strong> initializer &lsquo;init(coder:)&rsquo; must be provided by subclass of &lsquo;UIView&rsquo;</li></ol><p>例子 2：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=kd>class</span> <span class=nc>CustomView</span><span class=p>:</span> <span class=n>UIView</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kr>convenience</span> <span class=kd>init</span><span class=p>(</span><span class=n>param</span><span class=p>:</span> <span class=nb>Int</span><span class=p>,</span> <span class=n>frame</span><span class=p>:</span> <span class=n>CGRect</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kc>super</span><span class=p>.</span><span class=kd>init</span><span class=p>(</span><span class=n>frame</span><span class=p>:</span> <span class=n>frame</span><span class=p>)</span> <span class=c1>// error</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kr>required</span> <span class=kd>init</span><span class=p>?(</span><span class=n>coder</span> <span class=n>aDecoder</span><span class=p>:</span> <span class=n>NSCoder</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=bp>fatalError</span><span class=p>(</span><span class=s>&#34;init(coder:) has not been implemented&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>error：</p><ul><li><strong>convenience</strong> initializer for &lsquo;CustomView&rsquo; must delegate (with &lsquo;self.init&rsquo;) rather than chaining to a superclass</li></ul><p>上面俩个例子出现了 3 个关键字：<code>designated</code>、<code>convenience</code> 和 <code>required</code>。</p><h3 id=designated>designated<a hidden class=anchor aria-hidden=true href=#designated>#</a></h3><p>Swift 定义了两种类初始化器类型，用来保证所有成员属性能够获得一个初始化值。即 designated initializers [i&rsquo;niʃəlaizə] 和 convenience initializers。</p><blockquote><p>Designated initializers are the primary initializers for a class. A designated initializer fully initializes all properties introduced by that class and calls an appropriate superclass initializer to continue the initialization process up the superclass chain.</p></blockquote><ol><li>primary initializers：designated initializers 是一个类的主初始化器，理论上来说是一个类初始化的必经之路。（不同的初始化路径可能调用不同的 designated initializers）</li><li>fully initializes all properties：必须在 designated initializers 中完成所有成员属性的初始化</li><li>calls an appropriate superclass initializer：需要调用合适的父类初始化器完成初始化，不能随意调用</li></ol><p><em>在 Swift 中 designated initializers 的写法和一般的初始化方法无异</em>，Sample 1 中，我们试图去 override init，可以理解为我们就是在 override 一个 designated initializers，然后我们收到了错误 Initializer does not override a designated initializer from its superclass，可见我们并没有找到合适的 designated initializers，我们进入父类 UIView，可以看到下面两个初始化方法：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=kd>public</span> <span class=kd>init</span><span class=p>(</span><span class=n>frame</span><span class=p>:</span> <span class=n>CGRect</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>init</span><span class=p>?(</span><span class=n>coder</span> <span class=n>aDecoder</span><span class=p>:</span> <span class=n>NSCoder</span><span class=p>)</span>
</span></span></code></pre></div><p>原来，这两个类才是父类的 designated initializers，那我们改改试试：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=kd>class</span> <span class=nc>CustomView</span><span class=p>:</span> <span class=n>UIView</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>let</span> <span class=nv>param</span><span class=p>:</span> <span class=nb>Int</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kr>override</span> <span class=kd>init</span><span class=p>(</span><span class=n>frame</span><span class=p>:</span> <span class=n>CGRect</span><span class=p>)</span> <span class=p>{</span> <span class=c1>// error 1 fixed</span>
</span></span><span class=line><span class=cl>        <span class=kc>self</span><span class=p>.</span><span class=n>param</span> <span class=p>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=kc>super</span><span class=p>.</span><span class=kd>init</span><span class=p>(</span><span class=n>frame</span><span class=p>:</span> <span class=n>frame</span><span class=p>)</span> <span class=c1>// error 2 fixed</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=c1>// error 3</span>
</span></span></code></pre></div><p>error 1 fixed 由此可见：我们去 override 一个不是 designated initializers 的初始化器时，是不满足定义中所说的 primary initializers，这就可能导致这个初始化器不被执行，成员变量没有初始化，这样创建的“半成品”实例可能存在一些不安全的情况。</p><p>第二条 fully initializes all properties，这点我们并没有犯错，因为我们已经初始化了 CustomView 类中引入的 param 变量。</p><p>第三条 calls an appropriate superclass initializer 很明显就对应了 error 2，我们 override init(frame:)，那我们就必须调用对应的父类初始化方法。</p><p>error 3 提示我们 init(coder:) 是一个 &lsquo;required&rsquo; initializer，子类必须提供</p><h3 id=required>required<a hidden class=anchor aria-hidden=true href=#required>#</a></h3><blockquote><p>Write the required modifier before the definition of a class initializer to indicate that every subclass of the class must implement that initializer.</p></blockquote><p>通过添加 required 关键字强制子类对某个初始化方法进行重写。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=kd>class</span> <span class=nc>CustomView</span><span class=p>:</span> <span class=n>UIView</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>let</span> <span class=nv>param</span><span class=p>:</span> <span class=nb>Int</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kr>override</span> <span class=kd>init</span><span class=p>(</span><span class=n>frame</span><span class=p>:</span> <span class=n>CGRect</span><span class=p>)</span> <span class=p>{</span> <span class=c1>// error 1 fixed</span>
</span></span><span class=line><span class=cl>        <span class=kc>self</span><span class=p>.</span><span class=n>param</span> <span class=p>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=kc>super</span><span class=p>.</span><span class=kd>init</span><span class=p>(</span><span class=n>frame</span><span class=p>:</span> <span class=n>frame</span><span class=p>)</span> <span class=c1>// error 2 fixed</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kr>required</span> <span class=kd>init</span><span class=p>?(</span><span class=n>coder</span> <span class=n>aDecoder</span><span class=p>:</span> <span class=n>NSCoder</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=bp>fatalError</span><span class=p>(</span><span class=s>&#34;init(coder:) has not been implemented&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=c1>// error 3 fixed</span>
</span></span></code></pre></div><p>error 3 fixed 插入的这个方法很奇怪，方法体里直接写 <code>fatalError("init(coder:) has not been implemented")</code>，那岂不是走到这里就 crash 了？</p><p>designated initializers 是一个类的主初始化器，理论上来说是一个类初始化的必经之路（不同的初始化路径可能调用不同的 designated initializers），其实，这个 <code>init(coder:)</code> 与 <code>init(frame: frame)</code> 就是不同的初始化路径，当我们使用 xib 方式初始化一个 view 时，就会走到 init(coder:)。此时，如果我们没有真正实现这个方法，就会出现 fatal crash。</p><p>完整初始方案：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=kd>class</span> <span class=nc>CustomView</span><span class=p>:</span> <span class=n>UIView</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>let</span> <span class=nv>param</span><span class=p>:</span> <span class=nb>Int</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kr>override</span> <span class=kd>init</span><span class=p>(</span><span class=n>frame</span><span class=p>:</span> <span class=n>CGRect</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kc>self</span><span class=p>.</span><span class=n>param</span> <span class=p>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=kc>super</span><span class=p>.</span><span class=kd>init</span><span class=p>(</span><span class=n>frame</span><span class=p>:</span> <span class=n>frame</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kr>required</span> <span class=kd>init</span><span class=p>?(</span><span class=n>coder</span> <span class=n>aDecoder</span><span class=p>:</span> <span class=n>NSCoder</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kc>self</span><span class=p>.</span><span class=n>param</span> <span class=p>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=kc>super</span><span class=p>.</span><span class=kd>init</span><span class=p>(</span><span class=n>coder</span><span class=p>:</span> <span class=n>aDecoder</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=convenience>convenience<a hidden class=anchor aria-hidden=true href=#convenience>#</a></h3><blockquote><p>Convenience initializers are secondary, supporting initializers for a class. You can define a convenience initializer to call a designated initializer from the same class as the convenience initializer with some of the designated initializer’s parameters set to default values. You can also define a convenience initializer to create an instance of that class for a specific use case or input value type.</p></blockquote><p>convenience initializers 是对类初始化方法的补充，用于为类提供一些快捷的初始化方法，可以不创建这类方法，但如果创建了，就需要遵循原则：call a designated initializer from the same class，也就是说要调用该类自己的 <code>designated initializer</code>，那么我们应该 <code>override init(frame:)</code> ，然后修改为：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=kd>class</span> <span class=nc>CustomView</span><span class=p>:</span> <span class=n>UIView</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kr>convenience</span> <span class=kd>init</span><span class=p>(</span><span class=n>param</span><span class=p>:</span> <span class=nb>Int</span><span class=p>,</span> <span class=n>frame</span><span class=p>:</span> <span class=n>CGRect</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kc>self</span><span class=p>.</span><span class=kd>init</span><span class=p>(</span><span class=n>frame</span><span class=p>:</span> <span class=n>frame</span><span class=p>)</span> <span class=c1>// error fixed</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kr>override</span> <span class=kd>init</span><span class=p>(</span><span class=n>frame</span><span class=p>:</span> <span class=n>CGRect</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kc>super</span><span class=p>.</span><span class=kd>init</span><span class=p>(</span><span class=n>frame</span><span class=p>:</span> <span class=n>frame</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kr>required</span> <span class=kd>init</span><span class=p>?(</span><span class=n>coder</span> <span class=n>aDecoder</span><span class=p>:</span> <span class=n>NSCoder</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=bp>fatalError</span><span class=p>(</span><span class=s>&#34;init(coder:) has not been implemented&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>然后对成员变量 <code>param</code> 赋值：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=kd>class</span> <span class=nc>CustomView</span><span class=p>:</span> <span class=n>UIView</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nv>param</span><span class=p>:</span> <span class=nb>Int</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kr>convenience</span> <span class=kd>init</span><span class=p>(</span><span class=n>param</span><span class=p>:</span> <span class=nb>Int</span><span class=p>,</span> <span class=n>frame</span><span class=p>:</span> <span class=n>CGRect</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kc>self</span><span class=p>.</span><span class=n>param</span> <span class=p>=</span> <span class=n>param</span> <span class=c1>// error</span>
</span></span><span class=line><span class=cl>        <span class=kc>self</span><span class=p>.</span><span class=kd>init</span><span class=p>(</span><span class=n>frame</span><span class=p>:</span> <span class=n>frame</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kr>override</span> <span class=kd>init</span><span class=p>(</span><span class=n>frame</span><span class=p>:</span> <span class=n>CGRect</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kc>super</span><span class=p>.</span><span class=kd>init</span><span class=p>(</span><span class=n>frame</span><span class=p>:</span> <span class=n>frame</span><span class=p>)</span> <span class=c1>// error</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kr>required</span> <span class=kd>init</span><span class=p>?(</span><span class=n>coder</span> <span class=n>aDecoder</span><span class=p>:</span> <span class=n>NSCoder</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=bp>fatalError</span><span class=p>(</span><span class=s>&#34;init(coder:) has not been implemented&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>来个两个错误：</p><ul><li>Use of &lsquo;self&rsquo; in property access &lsquo;param&rsquo; before self.init initializes self</li><li>Property &lsquo;self.param&rsquo; not initialized at super.init call</li></ul><p>第二个错误我们清楚，是需要在调用 super.init 之前初始化本类成员属性。</p><p>第一个错误其实，这是 Swift 编译器提供的安全检查，文档原文如下：</p><blockquote><p>A convenience initializer must delegate to another initializer before assigning a value to any property (including properties defined by the same class). If it doesn’t, the new value the convenience initializer assigns will be overwritten by its own class’s designated initializer.</p></blockquote><p>原来 Swift 防止 convenience initializers 中赋值之后又被该类自己的 designated initializer 覆盖而做了检查。因此，正确的方式应该是调用该类的其他初始化方法之后再修改属性值，最终修改如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=kd>class</span> <span class=nc>CustomView</span><span class=p>:</span> <span class=n>UIView</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nv>param</span><span class=p>:</span> <span class=nb>Int</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kr>convenience</span> <span class=kd>init</span><span class=p>(</span><span class=n>param</span><span class=p>:</span> <span class=nb>Int</span><span class=p>,</span> <span class=n>frame</span><span class=p>:</span> <span class=n>CGRect</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kc>self</span><span class=p>.</span><span class=kd>init</span><span class=p>(</span><span class=n>frame</span><span class=p>:</span> <span class=n>frame</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=kc>self</span><span class=p>.</span><span class=n>param</span> <span class=p>=</span> <span class=n>param</span> <span class=c1>// error fixed</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kr>override</span> <span class=kd>init</span><span class=p>(</span><span class=n>frame</span><span class=p>:</span> <span class=n>CGRect</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kc>self</span><span class=p>.</span><span class=n>param</span> <span class=p>=</span> <span class=mi>0</span> <span class=c1>// error fixed</span>
</span></span><span class=line><span class=cl>        <span class=kc>super</span><span class=p>.</span><span class=kd>init</span><span class=p>(</span><span class=n>frame</span><span class=p>:</span> <span class=n>frame</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kr>required</span> <span class=kd>init</span><span class=p>?(</span><span class=n>coder</span> <span class=n>aDecoder</span><span class=p>:</span> <span class=n>NSCoder</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kc>self</span><span class=p>.</span><span class=n>param</span> <span class=p>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>        <span class=kc>super</span><span class=p>.</span><span class=kd>init</span><span class=p>(</span><span class=n>coder</span><span class=p>:</span> <span class=n>aDecoder</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=小结>小结<a hidden class=anchor aria-hidden=true href=#小结>#</a></h3><ol><li>子类中初始化方法必须覆盖全部初始化路径，以保证对象完全初始化</li><li>子类中 <code>designated initializer</code> 必须调用父类中对应的 <code>designated initializer</code>，以保证父类也能完成初始化</li><li>子类中如果重写父类中 <code>convenience initializer</code> 所需要的全部 <code>init</code> 方法，就可以在子类中使用父类的 <code>convenience initializer</code> 了</li><li>子类如果没有定义任何 <code>designated initializer</code>，则默认继承所有父类的 <code>designated initializer</code> 及 <code>convenience initializer</code></li><li>子类中必须实现的 <code>designated initializer</code>，可以通过添加 <code>required</code> 关键字强制子类重写其实现，以保证依赖该方法的 <code>convenience initializer</code> 始终可以使用</li><li><code>convenience initializer</code> 必须调用自身类中的其他初始化方法，并在最终必须调用一个 <code>designated initializer</code></li><li>在构造器完成初始化之前, 不能调用任何实例方法，或读取任何实例属性的值，<code>self</code> 本身也不能被引用</li></ol><h2 id=可失败初始化器>可失败初始化器<a hidden class=anchor aria-hidden=true href=#可失败初始化器>#</a></h2><p>可失败初始化器 <code>Failable Initializers</code> ，即可能返回 <code>nil</code> 的初始化方法。</p><blockquote><p>A failable initializer creates an <em>optional value</em> of the type it initializes. You write <em>return nil within a failable initializer</em> to indicate a point at which initialization failure can be triggered.</p></blockquote><p>就是将初始化返回值变成 optional value，并在不满足初始化条件的地方 return nil。通过调用处判断是否有值即可知道是否初始化成功。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=kd>class</span> <span class=nc>Product</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>let</span> <span class=nv>name</span><span class=p>:</span> <span class=nb>String</span>
</span></span><span class=line><span class=cl>    <span class=kd>init</span><span class=p>?(</span><span class=n>name</span><span class=p>:</span> <span class=nb>String</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>name</span><span class=p>.</span><span class=bp>isEmpty</span> <span class=p>{</span> <span class=k>return</span> <span class=kc>nil</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=kc>self</span><span class=p>.</span><span class=n>name</span> <span class=p>=</span> <span class=n>name</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>class</span> <span class=nc>CartItem</span><span class=p>:</span> <span class=n>Product</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>let</span> <span class=nv>quantity</span><span class=p>:</span> <span class=nb>Int</span>
</span></span><span class=line><span class=cl>    <span class=kd>init</span><span class=p>?(</span><span class=n>name</span><span class=p>:</span> <span class=nb>String</span><span class=p>,</span> <span class=n>quantity</span><span class=p>:</span> <span class=nb>Int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>quantity</span> <span class=o>&lt;</span> <span class=mi>1</span> <span class=p>{</span> <span class=k>return</span> <span class=kc>nil</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=kc>self</span><span class=p>.</span><span class=n>quantity</span> <span class=p>=</span> <span class=n>quantity</span>
</span></span><span class=line><span class=cl>        <span class=kc>super</span><span class=p>.</span><span class=kd>init</span><span class=p>(</span><span class=n>name</span><span class=p>:</span> <span class=n>name</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>CartItem 类的初始化方法先对传入参数 <code>quantity</code> 的值进行判断，小于 <code>1</code> 则为无效参数，然后 <code>return nil</code>（初始化失败），大于或等于 <code>1</code> 则继续调用父类 <code>Product</code> 的初始化方法，再次判断传入参数 <code>name</code>，为空则 <code>return nil</code>（初始化失败），否则继续初始化。</p><p>总的来说，可失败初始化器的设定，是在保证安全性的基础上提供了逻辑上更清晰的初始化方式。<code>Failable Initializers</code> 所有的结果都将是 <code>T?</code> 类型，通过 <code>Optional Binding</code> 方式，我们就能知道初始化是否成功，并安全地使用它们了。</p><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><ul><li><a href=http://huizhao.win/2016/11/13/swift-init/>从 Swift 初始化说起</a></li><li><a href=https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Initialization.html>The Swift Programming Language (Swift 4.1) Initialization</a></li><li><a href=https://draveness.me/swift-zhong-init-de-shi-yong>Swift 类构造器的使用</a></li></ul><p>&ndash; EOF &ndash;</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://zyf.im/tags/ios/>Ios</a></li><li><a href=https://zyf.im/tags/swift/>Swift</a></li></ul><nav class=paginav><a class=prev href=https://zyf.im/2018/04/24/docker-ufw-not-work/><span class=title>« Prev</span><br><span>Docker UFW 失效</span>
</a><a class=next href=https://zyf.im/2018/03/29/ios-safe-area/><span class=title>Next »</span><br><span>iOS Safe Area 我所知道的全部</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://zyf.im/>ZYF.IM BLOG</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>