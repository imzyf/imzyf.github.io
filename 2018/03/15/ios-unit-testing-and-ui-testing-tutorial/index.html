<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>【译】iOS 单元测试和 UI 测试入门教程 | ZYF.IM BLOG</title>
<meta name=keywords content="ios"><meta name=description content='
iOS Unit Testing and UI Testing Tutorial
编写测试并不迷人 (glamorous)，但是既然测试能让你闪闪发光 (sparkling) 的应用程序避免变成 (from turning into) 一堆乱七八糟的垃圾，那么说明测试是必要的。如果你正在阅读这篇教程，那么你已经知道你 应该 为代码和 UI 编写测试，但是你可能不知道如何做。
也许你已经有一个 &ldquo;可以运行&rdquo; 的应用，但想测试你正在进行的扩展应用的更改。也许你已经编写了一些测试，但不确定它们是否是 正确 的测试。或者，你已经开始开发一个新应用，想要边开发边测试。
这篇教程将告诉你如何:

使用 Xcode 的测试导航器来测试应用的模型和异步方法
通过使用存根 (stubs) 和模拟对象 (mocks) 模拟与库或系统对象的交互
测试 UI 和性能
使用代码覆盖率工具

在此过程中，你将学到一些测试高手常用的专业术语。
开始
首先，下载教程素材。它包含一个基于 UIKit Apprentice 中的示例应用的 BullsEye 项目。这是一个简单的运气和机会游戏。游戏逻辑在 BullsEyeGame 类中，你将在本教程中对其进行测试。
测试什么
在编写任何测试之前，重要的是了解基础知识。你需要测试什么？
如果你的目标是扩展现有应用，你应该首先为计划更改的任何组件编写测试。
一般来说，测试应该覆盖：

核心功能：模型类和方法及其与控制器的交互
最常见的 UI 工作流
边界条件
Bug 修复

测试的最佳实践
首字母缩写 FIRST 描述了有效单元测试的一套简明标准。这些标准是：

Fast：测试应该快速运行。
Independent/Isolated：测试之间不应共享状态。
Repeatable：每次运行测试时，都应获得相同的结果。外部数据提供者或并发问题可能导致间歇性失败。
Self-validating：测试应完全自动化。输出应该是"通过"或"失败"，而不是依赖程序员对日志文件的解释。
Timely：理想情况下，你应该在编写生产代码之前编写测试它们的测试。这被称为测试驱动开发。

遵循 FIRST 原则将使你的测试保持清晰有用，而不会成为应用开发的障碍。'><meta name=author content="Me"><link rel=canonical href=https://zyf.im/2018/03/15/ios-unit-testing-and-ui-testing-tutorial/><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://zyf.im/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zyf.im/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://zyf.im/favicon-32x32.png><link rel=apple-touch-icon href=https://zyf.im/apple-touch-icon.png><link rel=mask-icon href=https://zyf.im/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://zyf.im/2018/03/15/ios-unit-testing-and-ui-testing-tutorial/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:url" content="https://zyf.im/2018/03/15/ios-unit-testing-and-ui-testing-tutorial/"><meta property="og:site_name" content="ZYF.IM BLOG"><meta property="og:title" content="【译】iOS 单元测试和 UI 测试入门教程"><meta property="og:description" content=' iOS Unit Testing and UI Testing Tutorial
编写测试并不迷人 (glamorous)，但是既然测试能让你闪闪发光 (sparkling) 的应用程序避免变成 (from turning into) 一堆乱七八糟的垃圾，那么说明测试是必要的。如果你正在阅读这篇教程，那么你已经知道你 应该 为代码和 UI 编写测试，但是你可能不知道如何做。
也许你已经有一个 “可以运行” 的应用，但想测试你正在进行的扩展应用的更改。也许你已经编写了一些测试，但不确定它们是否是 正确 的测试。或者，你已经开始开发一个新应用，想要边开发边测试。
这篇教程将告诉你如何:
使用 Xcode 的测试导航器来测试应用的模型和异步方法 通过使用存根 (stubs) 和模拟对象 (mocks) 模拟与库或系统对象的交互 测试 UI 和性能 使用代码覆盖率工具 在此过程中，你将学到一些测试高手常用的专业术语。
开始 首先，下载教程素材。它包含一个基于 UIKit Apprentice 中的示例应用的 BullsEye 项目。这是一个简单的运气和机会游戏。游戏逻辑在 BullsEyeGame 类中，你将在本教程中对其进行测试。
测试什么 在编写任何测试之前，重要的是了解基础知识。你需要测试什么？
如果你的目标是扩展现有应用，你应该首先为计划更改的任何组件编写测试。
一般来说，测试应该覆盖：
核心功能：模型类和方法及其与控制器的交互 最常见的 UI 工作流 边界条件 Bug 修复 测试的最佳实践 首字母缩写 FIRST 描述了有效单元测试的一套简明标准。这些标准是：
Fast：测试应该快速运行。 Independent/Isolated：测试之间不应共享状态。 Repeatable：每次运行测试时，都应获得相同的结果。外部数据提供者或并发问题可能导致间歇性失败。 Self-validating：测试应完全自动化。输出应该是"通过"或"失败"，而不是依赖程序员对日志文件的解释。 Timely：理想情况下，你应该在编写生产代码之前编写测试它们的测试。这被称为测试驱动开发。 遵循 FIRST 原则将使你的测试保持清晰有用，而不会成为应用开发的障碍。'><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-03-15T19:00:00+00:00"><meta property="article:modified_time" content="2018-03-15T19:00:00+00:00"><meta property="article:tag" content="Ios"><meta name=twitter:card content="summary"><meta name=twitter:title content="【译】iOS 单元测试和 UI 测试入门教程"><meta name=twitter:description content='
iOS Unit Testing and UI Testing Tutorial
编写测试并不迷人 (glamorous)，但是既然测试能让你闪闪发光 (sparkling) 的应用程序避免变成 (from turning into) 一堆乱七八糟的垃圾，那么说明测试是必要的。如果你正在阅读这篇教程，那么你已经知道你 应该 为代码和 UI 编写测试，但是你可能不知道如何做。
也许你已经有一个 &ldquo;可以运行&rdquo; 的应用，但想测试你正在进行的扩展应用的更改。也许你已经编写了一些测试，但不确定它们是否是 正确 的测试。或者，你已经开始开发一个新应用，想要边开发边测试。
这篇教程将告诉你如何:

使用 Xcode 的测试导航器来测试应用的模型和异步方法
通过使用存根 (stubs) 和模拟对象 (mocks) 模拟与库或系统对象的交互
测试 UI 和性能
使用代码覆盖率工具

在此过程中，你将学到一些测试高手常用的专业术语。
开始
首先，下载教程素材。它包含一个基于 UIKit Apprentice 中的示例应用的 BullsEye 项目。这是一个简单的运气和机会游戏。游戏逻辑在 BullsEyeGame 类中，你将在本教程中对其进行测试。
测试什么
在编写任何测试之前，重要的是了解基础知识。你需要测试什么？
如果你的目标是扩展现有应用，你应该首先为计划更改的任何组件编写测试。
一般来说，测试应该覆盖：

核心功能：模型类和方法及其与控制器的交互
最常见的 UI 工作流
边界条件
Bug 修复

测试的最佳实践
首字母缩写 FIRST 描述了有效单元测试的一套简明标准。这些标准是：

Fast：测试应该快速运行。
Independent/Isolated：测试之间不应共享状态。
Repeatable：每次运行测试时，都应获得相同的结果。外部数据提供者或并发问题可能导致间歇性失败。
Self-validating：测试应完全自动化。输出应该是"通过"或"失败"，而不是依赖程序员对日志文件的解释。
Timely：理想情况下，你应该在编写生产代码之前编写测试它们的测试。这被称为测试驱动开发。

遵循 FIRST 原则将使你的测试保持清晰有用，而不会成为应用开发的障碍。'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zyf.im/posts/"},{"@type":"ListItem","position":2,"name":"【译】iOS 单元测试和 UI 测试入门教程","item":"https://zyf.im/2018/03/15/ios-unit-testing-and-ui-testing-tutorial/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"【译】iOS 单元测试和 UI 测试入门教程","name":"【译】iOS 单元测试和 UI 测试入门教程","description":" iOS Unit Testing and UI Testing Tutorial\n编写测试并不迷人 (glamorous)，但是既然测试能让你闪闪发光 (sparkling) 的应用程序避免变成 (from turning into) 一堆乱七八糟的垃圾，那么说明测试是必要的。如果你正在阅读这篇教程，那么你已经知道你 应该 为代码和 UI 编写测试，但是你可能不知道如何做。\n也许你已经有一个 \u0026ldquo;可以运行\u0026rdquo; 的应用，但想测试你正在进行的扩展应用的更改。也许你已经编写了一些测试，但不确定它们是否是 正确 的测试。或者，你已经开始开发一个新应用，想要边开发边测试。\n这篇教程将告诉你如何:\n使用 Xcode 的测试导航器来测试应用的模型和异步方法 通过使用存根 (stubs) 和模拟对象 (mocks) 模拟与库或系统对象的交互 测试 UI 和性能 使用代码覆盖率工具 在此过程中，你将学到一些测试高手常用的专业术语。\n开始 首先，下载教程素材。它包含一个基于 UIKit Apprentice 中的示例应用的 BullsEye 项目。这是一个简单的运气和机会游戏。游戏逻辑在 BullsEyeGame 类中，你将在本教程中对其进行测试。\n测试什么 在编写任何测试之前，重要的是了解基础知识。你需要测试什么？\n如果你的目标是扩展现有应用，你应该首先为计划更改的任何组件编写测试。\n一般来说，测试应该覆盖：\n核心功能：模型类和方法及其与控制器的交互 最常见的 UI 工作流 边界条件 Bug 修复 测试的最佳实践 首字母缩写 FIRST 描述了有效单元测试的一套简明标准。这些标准是：\nFast：测试应该快速运行。 Independent/Isolated：测试之间不应共享状态。 Repeatable：每次运行测试时，都应获得相同的结果。外部数据提供者或并发问题可能导致间歇性失败。 Self-validating：测试应完全自动化。输出应该是\u0026quot;通过\u0026quot;或\u0026quot;失败\u0026quot;，而不是依赖程序员对日志文件的解释。 Timely：理想情况下，你应该在编写生产代码之前编写测试它们的测试。这被称为测试驱动开发。 遵循 FIRST 原则将使你的测试保持清晰有用，而不会成为应用开发的障碍。\n","keywords":["ios"],"articleBody":" iOS Unit Testing and UI Testing Tutorial\n编写测试并不迷人 (glamorous)，但是既然测试能让你闪闪发光 (sparkling) 的应用程序避免变成 (from turning into) 一堆乱七八糟的垃圾，那么说明测试是必要的。如果你正在阅读这篇教程，那么你已经知道你 应该 为代码和 UI 编写测试，但是你可能不知道如何做。\n也许你已经有一个 “可以运行” 的应用，但想测试你正在进行的扩展应用的更改。也许你已经编写了一些测试，但不确定它们是否是 正确 的测试。或者，你已经开始开发一个新应用，想要边开发边测试。\n这篇教程将告诉你如何:\n使用 Xcode 的测试导航器来测试应用的模型和异步方法 通过使用存根 (stubs) 和模拟对象 (mocks) 模拟与库或系统对象的交互 测试 UI 和性能 使用代码覆盖率工具 在此过程中，你将学到一些测试高手常用的专业术语。\n开始 首先，下载教程素材。它包含一个基于 UIKit Apprentice 中的示例应用的 BullsEye 项目。这是一个简单的运气和机会游戏。游戏逻辑在 BullsEyeGame 类中，你将在本教程中对其进行测试。\n测试什么 在编写任何测试之前，重要的是了解基础知识。你需要测试什么？\n如果你的目标是扩展现有应用，你应该首先为计划更改的任何组件编写测试。\n一般来说，测试应该覆盖：\n核心功能：模型类和方法及其与控制器的交互 最常见的 UI 工作流 边界条件 Bug 修复 测试的最佳实践 首字母缩写 FIRST 描述了有效单元测试的一套简明标准。这些标准是：\nFast：测试应该快速运行。 Independent/Isolated：测试之间不应共享状态。 Repeatable：每次运行测试时，都应获得相同的结果。外部数据提供者或并发问题可能导致间歇性失败。 Self-validating：测试应完全自动化。输出应该是\"通过\"或\"失败\"，而不是依赖程序员对日志文件的解释。 Timely：理想情况下，你应该在编写生产代码之前编写测试它们的测试。这被称为测试驱动开发。 遵循 FIRST 原则将使你的测试保持清晰有用，而不会成为应用开发的障碍。\nXcode 中的单元测试 测试导航器 提供了使用测试的最简单方法。你将使用它来创建测试目标并对你的应用运行测试。\n创建单元测试目标 打开 BullsEye 项目并按下 Command-6 打开测试导航器。\n点击左下角的 +，然后从菜单中选择 New Unit Test Target…：\n接受默认名称 BullsEyeTests，并输入 com.raywenderlich 作为 Organization Identifier。当测试包出现在测试导航器中时，通过点击展开三角形展开它，然后点击 BullsEyeTests 在编辑器中打开它。\n默认模板导入测试框架 XCTest，并定义了 BullsEyeTests 子类，其中包含 setUpWithError()、tearDownWithError() 和示例测试方法。\n你可以通过三种方式运行测试：\nProduct ▸ Test 或 Command-U。这两种方式都会运行 所有 测试类。 点击测试导航器中的箭头按钮。 点击边栏中的菱形按钮。 你也可以通过点击测试导航器或边栏中的菱形来运行单个测试方法。\n当所有测试成功时，菱形将变为绿色并显示勾号。点击 testPerformanceExample() 末尾的灰色菱形打开性能结果：\n你不需要 testPerformanceExample() 或 testExample()，所以删除它们。\n使用 XCTAssert 测试模型 首先，你将使用 XCTAssert 函数测试 BullsEye 模型的核心功能：BullsEyeGame 是否正确计算一轮的分数？\n在 BullsEyeTests.swift 中，在 import XCTest 下面添加这一行：\n@testable import BullsEye 这使单元测试可以访问 BullsEye 中的 internal 类型和函数。\n在 BullsEyeTests 顶部添加这个属性：\nvar sut: BullsEyeGame! 这为 BullsEyeGame 创建一个占位符，它是 System Under Test (SUT)，或者说是这个测试用例类关注测试的对象。\n接下来，用以下内容替换 setUpWithError() 的内容：\ntry super.setUpWithError() sut = BullsEyeGame() 这在类级别创建 BullsEyeGame，以便该测试类中的所有测试都可以访问 SUT 对象的属性和方法。\n在你忘记之前，在 tearDownWithError() 中 释放 你的 SUT 对象。用以下内容替换它的内容：\nsut = nil try super.tearDownWithError() 注意：在 setUpWithError() 中创建 SUT 并在 tearDownWithError() 中释放它是一种很好的做法，以确保每个测试都从干净的状态开始。\n编写你的第一个测试 现在你已经准备好编写你的第一个测试了！\n在 BullsEyeTests 末尾添加以下代码，测试当猜测值高于目标值时是否计算了预期的分数：\nfunc testScoreIsComputedWhenGuessIsHigherThanTarget() { // given let guess = sut.targetValue + 5 // when sut.check(guess: guess) // then XCTAssertEqual(sut.scoreRound, 95, \"Score computed from guess is wrong\") } 测试方法的名称总是以 test 开头，后跟对其测试内容的描述。\n将测试格式化为 given、when 和 then 部分是一种良好的做法：\nGiven：在这里，你设置所需的任何值。在这个例子中，你创建一个 guess 值，以便可以指定它与 targetValue 相差多少。 When：在这一部分，你将执行被测试的代码：调用 check(guess:)。 Then：这是你断言你期望的结果的部分，如果测试 失败，会打印一条消息。在这种情况下，sut.scoreRound 应该等于 95，因为它是 100 − 5。 通过点击边栏或测试导航器中的菱形图标运行测试。这将构建并运行应用，菱形图标将变成绿色勾号！你还会看到一个短暂显示在 Xcode 上方的弹出窗口，也表示成功：\n注意：要查看 XCTestAssertions 的完整列表，请访问 Apple 的按类别列出的断言页面。\n调试测试 让我们添加另一个测试来检查当猜测值低于目标值时的得分计算。添加以下测试方法：\nfunc testScoreIsComputedWhenGuessIsLowerThanTarget() { // given let guess = sut.targetValue - 5 // when sut.check(guess: guess) // then XCTAssertEqual(sut.scoreRound, 95, \"Score computed from guess is wrong\") } 在这个测试中，猜测值比目标值小 5，所以分数应该仍然是 95。运行这个测试看看会发生什么。\n如果这个测试失败了，那么你可能在 BullsEyeGame 中发现了一个 bug！在断点导航器中添加测试失败断点，这将在断言失败时停止测试运行。\n运行你的测试：当测试失败时，它将在 XCTAssertEqual 行停止。在调试控制台中检查 sut 和 guess。\n猜测值是目标值减 5，但 scoreRound 是 105 而不是 95！\n要进一步调查，使用常规调试过程：在 when 语句处设置断点，并在 BullsEyeGame.swift 的 check(_:) 方法中设置另一个断点。然后再次运行测试，分步执行 let difference 行，检查 difference 值：\n问题是 difference 是负数，所以得分是 100 - (-5)。要修复这个问题，应该使用 difference 的绝对值。\n修改 BullsEyeGame.swift 中的 check 方法，将：\nlet difference = guess - targetValue 改为：\nlet difference = abs(guess - targetValue) 移除两个断点并再次运行测试以确认它现在通过了。\n使用 XCTestExpectation 测试异步操作 许多 iOS 应用程序与网络、数据库或文件系统进行异步交互。这些异步操作需要特殊的测试处理，确保测试能够等待操作完成后再进行断言。\n要测试异步操作，可以使用 XCTestExpectation。它允许你创建一个期望（expectation），告诉测试等待满足这个期望，然后才能结束测试。\n下面是测试异步操作的基本模式：\nfunc testAsynchronousOperation() { // 1. 创建期望 let expectation = expectation(description: \"描述你期望发生的事\") // 2. 执行异步操作 performAsyncOperation { // 3. 异步操作完成时，满足期望 expectation.fulfill() } // 4. 等待期望被满足，设置超时时间 wait(for: [expectation], timeout: 5.0) // 5. 在异步操作完成后进行断言 } 这个模式可以帮助你测试各种异步操作，如网络请求、动画或定时器。\n快速失败 有时，测试失败是如此明显，以至于没有理由继续执行测试的剩余部分。在这种情况下，你可以使用 XCTFail(_:file:line:) 强制测试立即失败：\nfunc testWithCondition() { guard someConditionIsMet else { XCTFail(\"重要条件未满足\") return } // 继续测试 } 有条件地失败 你可能希望根据特定条件跳过某些测试。例如，某些测试可能只在特定的设备或操作系统版本上运行。在这些情况下，你可以使用 XCTSkip 来有条件地跳过测试：\nfunc testFeatureOnlyAvailableIniOS14() throws { if #available(iOS 14.0, *) { // 测试 iOS 14 特性 } else { throw XCTSkip(\"此测试需要 iOS 14\") } } 模拟对象和交互 当你测试一个与其他对象交互的对象时，可能不希望测试涉及真实的依赖项。例如，如果测试需要网络请求，则测试将变得缓慢和不可靠。\n这就是为什么我们使用存根（Stubs）和模拟对象（Mocks）来代替真实对象：\n存根（Stub）：提供测试所需的固定响应，不关心如何被调用 模拟对象（Mock）：记录它们如何被调用，允许你验证交互方式 使用存根模拟输入 创建一个存根非常简单，你只需创建一个实现相同协议的对象，并提供固定的测试数据：\nprotocol DataProvider { func fetchData(completion: @escaping (Data?, Error?) -\u003e Void) } class StubDataProvider: DataProvider { var stubData: Data? var stubError: Error? func fetchData(completion: @escaping (Data?, Error?) -\u003e Void) { completion(stubData, stubError) } } 现在你可以使用这个存根来测试你的代码如何处理不同的数据情况：\nfunc testHandleDataFetchSuccess() { // 创建存根并设置测试数据 let stub = StubDataProvider() stub.stubData = \"测试数据\".data(using: .utf8) // 将存根注入被测试系统 sut = SystemUnderTest(dataProvider: stub) // 执行测试 sut.loadData() // 断言 XCTAssertEqual(sut.loadedData, stub.stubData) } 使用模拟对象验证交互 模拟对象除了返回数据外，还跟踪它如何被调用：\nclass MockDataProvider: DataProvider { var fetchDataCallCount = 0 var stubbedData: Data? func fetchData(completion: @escaping (Data?, Error?) -\u003e Void) { fetchDataCallCount += 1 completion(stubbedData, nil) } } 然后可以验证模拟对象是否按预期被调用：\nfunc testDataProviderIsCalledOnRefresh() { // 创建模拟对象 let mock = MockDataProvider() // 注入模拟对象 sut = SystemUnderTest(dataProvider: mock) // 在刷新时应该调用数据提供者 sut.refresh() // 验证交互 XCTAssertEqual(mock.fetchDataCallCount, 1, \"刷新应该调用一次数据提供者\") } Xcode 中的 UI 测试 UI 测试模拟用户与应用程序界面的交互。这些测试非常有价值，因为它们验证整个应用程序从用户角度的工作方式。\n创建 UI 测试目标 与单元测试类似，你可以从测试导航器创建 UI 测试目标，选择 “New UI Test Target…\"。\nUI 测试使用 XCUIApplication 类启动你的应用程序，并通过 XCUIElement 查询与 UI 元素交互：\nfunc testExample() throws { // 启动应用 let app = XCUIApplication() app.launch() // 与 UI 交互 app.buttons[\"增加\"].tap() // 验证 UI 状态 XCTAssertEqual(app.staticTexts[\"计数器\"].label, \"1\") } 记录 UI 测试 Xcode 提供了一个记录功能，可以自动生成 UI 测试代码。在编辑器中放置光标，然后点击记录按钮，与应用交互。Xcode 将生成相应的测试代码。\n测试性能 除了测试功能正确性，Xcode 还支持性能测试，用于确保你的代码保持高效：\nfunc testPerformanceExample() throws { measure { // 放置要测量性能的代码 for _ in 1...1000 { _ = complexAlgorithm() } } } 当你运行这个测试时，Xcode 会多次执行 measure 块内的代码，并报告平均执行时间。如果执行时间明显变慢，测试将失败。\n启用代码覆盖率 代码覆盖率是衡量测试质量的指标，它显示了你的测试覆盖了多少代码。\n启用代码覆盖率步骤：\n编辑方案 (Edit Scheme) 选择 “Test” 操作 选择 “Options” 选项卡 勾选 “Code Coverage” 选项 运行测试后，可以在报告导航器中查看覆盖率报告。\n追求 100% 覆盖率？ 虽然高代码覆盖率是好事，但盲目追求 100% 的覆盖率可能适得其反。测试的目标是确保代码的正确性，而不仅仅是提高覆盖率数字。\n关注测试以下方面：\n容易出错的复杂逻辑 经常变化的代码 核心业务功能 已修复的 bug 总结 本教程介绍了如何在 Xcode 中进行单元测试和 UI 测试。掌握这些测试技术将帮助你创建更可靠、更健壮的 iOS 应用。\n关键要点：\n使用 XCTAssert 函数测试模型层 使用 XCTestExpectation 测试异步操作 使用存根和模拟对象隔离测试 创建 UI 测试验证用户交互 测量代码性能并监控变化 监控代码覆盖率，但关注测试质量而非数量 最重要的是，养成编写测试的习惯。随着时间的推移，这将为你的应用程序构建一个安全网，让你能够自信地进行更改并添加新功能。\n参考资料 Apple 官方文档：XCTest Apple 按类别列出的断言 WWDC 视频：测试与 Xcode ","wordCount":"680","inLanguage":"en","datePublished":"2018-03-15T19:00:00Z","dateModified":"2018-03-15T19:00:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zyf.im/2018/03/15/ios-unit-testing-and-ui-testing-tutorial/"},"publisher":{"@type":"Organization","name":"ZYF.IM BLOG","logo":{"@type":"ImageObject","url":"https://zyf.im/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://zyf.im/ accesskey=h title="ZYF.IM (Alt + H)"><img src=https://zyf.im/apple-touch-icon.png alt aria-label=logo height=35>ZYF.IM</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://zyf.im/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://zyf.im/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://zyf.im/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://zyf.im/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://zyf.im/>Home</a>&nbsp;»&nbsp;<a href=https://zyf.im/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">【译】iOS 单元测试和 UI 测试入门教程</h1><div class=post-meta><span title='2018-03-15 19:00:00 +0000 UTC'>March 15, 2018</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;680 words&nbsp;·&nbsp;Me</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#开始>开始</a></li><li><a href=#测试什么>测试什么</a><ul><li><a href=#测试的最佳实践>测试的最佳实践</a></li></ul></li><li><a href=#xcode-中的单元测试>Xcode 中的单元测试</a><ul><li><a href=#创建单元测试目标>创建单元测试目标</a></li><li><a href=#使用-xctassert-测试模型>使用 XCTAssert 测试模型</a></li></ul></li><li><a href=#编写你的第一个测试>编写你的第一个测试</a><ul><li><a href=#调试测试>调试测试</a></li><li><a href=#使用-xctestexpectation-测试异步操作>使用 XCTestExpectation 测试异步操作</a></li><li><a href=#快速失败>快速失败</a></li><li><a href=#有条件地失败>有条件地失败</a></li></ul></li><li><a href=#模拟对象和交互>模拟对象和交互</a><ul><li><a href=#使用存根模拟输入>使用存根模拟输入</a></li><li><a href=#使用模拟对象验证交互>使用模拟对象验证交互</a></li></ul></li><li><a href=#xcode-中的-ui-测试>Xcode 中的 UI 测试</a><ul><li><a href=#创建-ui-测试目标>创建 UI 测试目标</a></li><li><a href=#记录-ui-测试>记录 UI 测试</a></li></ul></li><li><a href=#测试性能>测试性能</a></li><li><a href=#启用代码覆盖率>启用代码覆盖率</a><ul><li><a href=#追求-100-覆盖率>追求 100% 覆盖率？</a></li></ul></li><li><a href=#总结>总结</a></li><li><a href=#参考资料>参考资料</a></li></ul></nav></div></details></div><div class=post-content><blockquote><p><a href=https://www.kodeco.com/21020457-ios-unit-testing-and-ui-testing-tutorial>iOS Unit Testing and UI Testing Tutorial</a></p></blockquote><p>编写测试并不迷人 (glamorous)，但是既然测试能让你闪闪发光 (sparkling) 的应用程序避免变成 (from turning into) 一堆乱七八糟的垃圾，那么说明测试是必要的。如果你正在阅读这篇教程，那么你已经知道你 <em>应该</em> 为代码和 UI 编写测试，但是你可能不知道如何做。</p><p>也许你已经有一个 &ldquo;可以运行&rdquo; 的应用，但想测试你正在进行的扩展应用的更改。也许你已经编写了一些测试，但不确定它们是否是 <em>正确</em> 的测试。或者，你已经开始开发一个新应用，想要边开发边测试。</p><p>这篇教程将告诉你如何:</p><ul><li>使用 Xcode 的测试导航器来测试应用的模型和异步方法</li><li>通过使用存根 (stubs) 和模拟对象 (mocks) 模拟与库或系统对象的交互</li><li>测试 UI 和性能</li><li>使用代码覆盖率工具</li></ul><p>在此过程中，你将学到一些测试高手常用的专业术语。</p><h2 id=开始>开始<a hidden class=anchor aria-hidden=true href=#开始>#</a></h2><p>首先，下载教程素材。它包含一个基于 UIKit Apprentice 中的示例应用的 BullsEye 项目。这是一个简单的运气和机会游戏。游戏逻辑在 <code>BullsEyeGame</code> 类中，你将在本教程中对其进行测试。</p><h2 id=测试什么>测试什么<a hidden class=anchor aria-hidden=true href=#测试什么>#</a></h2><p>在编写任何测试之前，重要的是了解基础知识。你需要测试什么？</p><p>如果你的目标是扩展现有应用，你应该首先为计划更改的任何组件编写测试。</p><p>一般来说，测试应该覆盖：</p><ul><li>核心功能：模型类和方法及其与控制器的交互</li><li>最常见的 UI 工作流</li><li>边界条件</li><li>Bug 修复</li></ul><h3 id=测试的最佳实践>测试的最佳实践<a hidden class=anchor aria-hidden=true href=#测试的最佳实践>#</a></h3><p>首字母缩写 <em>FIRST</em> 描述了有效单元测试的一套简明标准。这些标准是：</p><ul><li><em>Fast</em>：测试应该快速运行。</li><li><em>Independent/Isolated</em>：测试之间不应共享状态。</li><li><em>Repeatable</em>：每次运行测试时，都应获得相同的结果。外部数据提供者或并发问题可能导致间歇性失败。</li><li><em>Self-validating</em>：测试应完全自动化。输出应该是"通过"或"失败"，而不是依赖程序员对日志文件的解释。</li><li><em>Timely</em>：理想情况下，你应该在编写生产代码之前编写测试它们的测试。这被称为测试驱动开发。</li></ul><p>遵循 FIRST 原则将使你的测试保持清晰有用，而不会成为应用开发的障碍。</p><h2 id=xcode-中的单元测试>Xcode 中的单元测试<a hidden class=anchor aria-hidden=true href=#xcode-中的单元测试>#</a></h2><p><em>测试导航器</em> 提供了使用测试的最简单方法。你将使用它来创建测试目标并对你的应用运行测试。</p><h3 id=创建单元测试目标>创建单元测试目标<a hidden class=anchor aria-hidden=true href=#创建单元测试目标>#</a></h3><p>打开 <em>BullsEye</em> 项目并按下 <em>Command-6</em> 打开测试导航器。</p><p>点击左下角的 <em>+</em>，然后从菜单中选择 <em>New Unit Test Target…</em>：</p><p><img alt=测试导航器 loading=lazy src=https://koenig-media.raywenderlich.com/uploads/2016/12/TestNavigator1.png></p><p>接受默认名称 <em>BullsEyeTests</em>，并输入 <em>com.raywenderlich</em> 作为 <em>Organization Identifier</em>。当测试包出现在测试导航器中时，通过点击展开三角形展开它，然后点击 <em>BullsEyeTests</em> 在编辑器中打开它。</p><p><img alt=测试模板 loading=lazy src=https://koenig-media.raywenderlich.com/uploads/2016/12/TestNavigator2.png></p><p>默认模板导入测试框架 <em>XCTest</em>，并定义了 <code>BullsEyeTests</code> 子类，其中包含 <code>setUpWithError()</code>、<code>tearDownWithError()</code> 和示例测试方法。</p><p>你可以通过三种方式运行测试：</p><ol><li><em>Product ▸ Test</em> 或 <em>Command-U</em>。这两种方式都会运行 <em>所有</em> 测试类。</li><li>点击测试导航器中的箭头按钮。</li><li>点击边栏中的菱形按钮。</li></ol><p><img alt=运行测试 loading=lazy src=https://koenig-media.raywenderlich.com/uploads/2016/12/TestNavigator3.png></p><p>你也可以通过点击测试导航器或边栏中的菱形来运行单个测试方法。</p><p>当所有测试成功时，菱形将变为绿色并显示勾号。点击 <code>testPerformanceExample()</code> 末尾的灰色菱形打开性能结果：</p><p><img alt=性能测试结果 loading=lazy src=https://koenig-media.raywenderlich.com/uploads/2016/12/TestNavigator4.png></p><p>你不需要 <code>testPerformanceExample()</code> 或 <code>testExample()</code>，所以删除它们。</p><h3 id=使用-xctassert-测试模型>使用 XCTAssert 测试模型<a hidden class=anchor aria-hidden=true href=#使用-xctassert-测试模型>#</a></h3><p>首先，你将使用 <code>XCTAssert</code> 函数测试 BullsEye 模型的核心功能：<code>BullsEyeGame</code> 是否正确计算一轮的分数？</p><p>在 <em>BullsEyeTests.swift</em> 中，在 <code>import XCTest</code> 下面添加这一行：</p><pre tabindex=0><code>@testable import BullsEye
</code></pre><p>这使单元测试可以访问 BullsEye 中的 <em>internal</em> 类型和函数。</p><p>在 <code>BullsEyeTests</code> 顶部添加这个属性：</p><pre tabindex=0><code>var sut: BullsEyeGame!
</code></pre><p>这为 <code>BullsEyeGame</code> 创建一个占位符，它是 <em>System Under Test</em> (SUT)，或者说是这个测试用例类关注测试的对象。</p><p>接下来，用以下内容替换 <code>setUpWithError()</code> 的内容：</p><pre tabindex=0><code>try super.setUpWithError()
sut = BullsEyeGame()
</code></pre><p>这在类级别创建 <code>BullsEyeGame</code>，以便该测试类中的所有测试都可以访问 SUT 对象的属性和方法。</p><p>在你忘记之前，在 <code>tearDownWithError()</code> 中 <em>释放</em> 你的 SUT 对象。用以下内容替换它的内容：</p><pre tabindex=0><code>sut = nil
try super.tearDownWithError()
</code></pre><blockquote><p>注意：在 <code>setUpWithError()</code> 中创建 SUT 并在 <code>tearDownWithError()</code> 中释放它是一种很好的做法，以确保每个测试都从干净的状态开始。</p></blockquote><h2 id=编写你的第一个测试>编写你的第一个测试<a hidden class=anchor aria-hidden=true href=#编写你的第一个测试>#</a></h2><p>现在你已经准备好编写你的第一个测试了！</p><p>在 <code>BullsEyeTests</code> 末尾添加以下代码，测试当猜测值高于目标值时是否计算了预期的分数：</p><pre tabindex=0><code>func testScoreIsComputedWhenGuessIsHigherThanTarget() {
  // given
  let guess = sut.targetValue + 5

  // when
  sut.check(guess: guess)

  // then
  XCTAssertEqual(sut.scoreRound, 95, &#34;Score computed from guess is wrong&#34;)
}
</code></pre><p>测试方法的名称总是以 <em>test</em> 开头，后跟对其测试内容的描述。</p><p>将测试格式化为 <em>given</em>、<em>when</em> 和 <em>then</em> 部分是一种良好的做法：</p><ol><li><em>Given</em>：在这里，你设置所需的任何值。在这个例子中，你创建一个 <code>guess</code> 值，以便可以指定它与 <code>targetValue</code> 相差多少。</li><li><em>When</em>：在这一部分，你将执行被测试的代码：调用 <code>check(guess:)</code>。</li><li><em>Then</em>：这是你断言你期望的结果的部分，如果测试 <em>失败</em>，会打印一条消息。在这种情况下，<code>sut.scoreRound</code> 应该等于 95，因为它是 100 − 5。</li></ol><p>通过点击边栏或测试导航器中的菱形图标运行测试。这将构建并运行应用，菱形图标将变成绿色勾号！你还会看到一个短暂显示在 Xcode 上方的弹出窗口，也表示成功：</p><p><img alt=测试成功 loading=lazy src=https://koenig-media.raywenderlich.com/uploads/2016/12/TestNavigator4.png></p><blockquote><p>注意：要查看 <em>XCTestAssertions</em> 的完整列表，请访问 Apple 的按类别列出的断言页面。</p></blockquote><h3 id=调试测试>调试测试<a hidden class=anchor aria-hidden=true href=#调试测试>#</a></h3><p>让我们添加另一个测试来检查当猜测值低于目标值时的得分计算。添加以下测试方法：</p><pre tabindex=0><code>func testScoreIsComputedWhenGuessIsLowerThanTarget() {
  // given
  let guess = sut.targetValue - 5

  // when
  sut.check(guess: guess)

  // then
  XCTAssertEqual(sut.scoreRound, 95, &#34;Score computed from guess is wrong&#34;)
}
</code></pre><p>在这个测试中，猜测值比目标值小 5，所以分数应该仍然是 95。运行这个测试看看会发生什么。</p><p>如果这个测试失败了，那么你可能在 BullsEyeGame 中发现了一个 bug！在断点导航器中添加测试失败断点，这将在断言失败时停止测试运行。</p><p><img alt=添加测试失败断点 loading=lazy src=https://koenig-media.raywenderlich.com/uploads/2016/12/AddTestFailureBreakpoint.png></p><p>运行你的测试：当测试失败时，它将在 XCTAssertEqual 行停止。在调试控制台中检查 sut 和 guess。</p><p><img alt=测试失败 loading=lazy src=https://koenig-media.raywenderlich.com/uploads/2016/12/TestFailure.png></p><p>猜测值是目标值减 5，但 scoreRound 是 105 而不是 95！</p><p>要进一步调查，使用常规调试过程：在 when 语句处设置断点，并在 BullsEyeGame.swift 的 <code>check(_:)</code> 方法中设置另一个断点。然后再次运行测试，分步执行 let difference 行，检查 difference 值：</p><p><img alt=调试控制台 loading=lazy src=https://koenig-media.raywenderlich.com/uploads/2016/12/DebugConsole.png></p><p>问题是 difference 是负数，所以得分是 100 - (-5)。要修复这个问题，应该使用 difference 的绝对值。</p><p>修改 BullsEyeGame.swift 中的 check 方法，将：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=kd>let</span> <span class=nv>difference</span> <span class=p>=</span> <span class=n>guess</span> <span class=o>-</span> <span class=n>targetValue</span>
</span></span></code></pre></div><p>改为：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=kd>let</span> <span class=nv>difference</span> <span class=p>=</span> <span class=bp>abs</span><span class=p>(</span><span class=n>guess</span> <span class=o>-</span> <span class=n>targetValue</span><span class=p>)</span>
</span></span></code></pre></div><p>移除两个断点并再次运行测试以确认它现在通过了。</p><h3 id=使用-xctestexpectation-测试异步操作>使用 XCTestExpectation 测试异步操作<a hidden class=anchor aria-hidden=true href=#使用-xctestexpectation-测试异步操作>#</a></h3><p>许多 iOS 应用程序与网络、数据库或文件系统进行异步交互。这些异步操作需要特殊的测试处理，确保测试能够等待操作完成后再进行断言。</p><p>要测试异步操作，可以使用 <code>XCTestExpectation</code>。它允许你创建一个期望（expectation），告诉测试等待满足这个期望，然后才能结束测试。</p><p>下面是测试异步操作的基本模式：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=kd>func</span> <span class=nf>testAsynchronousOperation</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 1. 创建期望</span>
</span></span><span class=line><span class=cl>  <span class=kd>let</span> <span class=nv>expectation</span> <span class=p>=</span> <span class=n>expectation</span><span class=p>(</span><span class=n>description</span><span class=p>:</span> <span class=s>&#34;描述你期望发生的事&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 2. 执行异步操作</span>
</span></span><span class=line><span class=cl>  <span class=n>performAsyncOperation</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 3. 异步操作完成时，满足期望</span>
</span></span><span class=line><span class=cl>    <span class=n>expectation</span><span class=p>.</span><span class=n>fulfill</span><span class=p>()</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 4. 等待期望被满足，设置超时时间</span>
</span></span><span class=line><span class=cl>  <span class=n>wait</span><span class=p>(</span><span class=k>for</span><span class=p>:</span> <span class=p>[</span><span class=n>expectation</span><span class=p>],</span> <span class=n>timeout</span><span class=p>:</span> <span class=mf>5.0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 5. 在异步操作完成后进行断言</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>这个模式可以帮助你测试各种异步操作，如网络请求、动画或定时器。</p><h3 id=快速失败>快速失败<a hidden class=anchor aria-hidden=true href=#快速失败>#</a></h3><p>有时，测试失败是如此明显，以至于没有理由继续执行测试的剩余部分。在这种情况下，你可以使用 <code>XCTFail(_:file:line:)</code> 强制测试立即失败：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=kd>func</span> <span class=nf>testWithCondition</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>guard</span> <span class=n>someConditionIsMet</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>XCTFail</span><span class=p>(</span><span class=s>&#34;重要条件未满足&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 继续测试</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=有条件地失败>有条件地失败<a hidden class=anchor aria-hidden=true href=#有条件地失败>#</a></h3><p>你可能希望根据特定条件跳过某些测试。例如，某些测试可能只在特定的设备或操作系统版本上运行。在这些情况下，你可以使用 <code>XCTSkip</code> 来有条件地跳过测试：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=kd>func</span> <span class=nf>testFeatureOnlyAvailableIniOS14</span><span class=p>()</span> <span class=kr>throws</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=cp>#available</span><span class=p>(</span><span class=cp>iOS</span> <span class=mf>14.0</span><span class=p>,</span> <span class=o>*</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 测试 iOS 14 特性</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>throw</span> <span class=n>XCTSkip</span><span class=p>(</span><span class=s>&#34;此测试需要 iOS 14&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=模拟对象和交互>模拟对象和交互<a hidden class=anchor aria-hidden=true href=#模拟对象和交互>#</a></h2><p>当你测试一个与其他对象交互的对象时，可能不希望测试涉及真实的依赖项。例如，如果测试需要网络请求，则测试将变得缓慢和不可靠。</p><p>这就是为什么我们使用存根（Stubs）和模拟对象（Mocks）来代替真实对象：</p><ul><li><strong>存根（Stub）</strong>：提供测试所需的固定响应，不关心如何被调用</li><li><strong>模拟对象（Mock）</strong>：记录它们如何被调用，允许你验证交互方式</li></ul><h3 id=使用存根模拟输入>使用存根模拟输入<a hidden class=anchor aria-hidden=true href=#使用存根模拟输入>#</a></h3><p>创建一个存根非常简单，你只需创建一个实现相同协议的对象，并提供固定的测试数据：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=kd>protocol</span> <span class=nc>DataProvider</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kd>func</span> <span class=nf>fetchData</span><span class=p>(</span><span class=n>completion</span><span class=p>:</span> <span class=p>@</span><span class=n>escaping</span> <span class=p>(</span><span class=n>Data</span><span class=p>?,</span> <span class=n>Error</span><span class=p>?)</span> <span class=p>-&gt;</span> <span class=nb>Void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>class</span> <span class=nc>StubDataProvider</span><span class=p>:</span> <span class=n>DataProvider</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kd>var</span> <span class=nv>stubData</span><span class=p>:</span> <span class=n>Data</span><span class=p>?</span>
</span></span><span class=line><span class=cl>  <span class=kd>var</span> <span class=nv>stubError</span><span class=p>:</span> <span class=n>Error</span><span class=p>?</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kd>func</span> <span class=nf>fetchData</span><span class=p>(</span><span class=n>completion</span><span class=p>:</span> <span class=p>@</span><span class=n>escaping</span> <span class=p>(</span><span class=n>Data</span><span class=p>?,</span> <span class=n>Error</span><span class=p>?)</span> <span class=p>-&gt;</span> <span class=nb>Void</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>completion</span><span class=p>(</span><span class=n>stubData</span><span class=p>,</span> <span class=n>stubError</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>现在你可以使用这个存根来测试你的代码如何处理不同的数据情况：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=kd>func</span> <span class=nf>testHandleDataFetchSuccess</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 创建存根并设置测试数据</span>
</span></span><span class=line><span class=cl>  <span class=kd>let</span> <span class=nv>stub</span> <span class=p>=</span> <span class=n>StubDataProvider</span><span class=p>()</span>
</span></span><span class=line><span class=cl>  <span class=n>stub</span><span class=p>.</span><span class=n>stubData</span> <span class=p>=</span> <span class=s>&#34;测试数据&#34;</span><span class=p>.</span><span class=n>data</span><span class=p>(</span><span class=n>using</span><span class=p>:</span> <span class=p>.</span><span class=n>utf8</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 将存根注入被测试系统</span>
</span></span><span class=line><span class=cl>  <span class=n>sut</span> <span class=p>=</span> <span class=n>SystemUnderTest</span><span class=p>(</span><span class=n>dataProvider</span><span class=p>:</span> <span class=n>stub</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 执行测试</span>
</span></span><span class=line><span class=cl>  <span class=n>sut</span><span class=p>.</span><span class=n>loadData</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 断言</span>
</span></span><span class=line><span class=cl>  <span class=n>XCTAssertEqual</span><span class=p>(</span><span class=n>sut</span><span class=p>.</span><span class=n>loadedData</span><span class=p>,</span> <span class=n>stub</span><span class=p>.</span><span class=n>stubData</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=使用模拟对象验证交互>使用模拟对象验证交互<a hidden class=anchor aria-hidden=true href=#使用模拟对象验证交互>#</a></h3><p>模拟对象除了返回数据外，还跟踪它如何被调用：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=kd>class</span> <span class=nc>MockDataProvider</span><span class=p>:</span> <span class=n>DataProvider</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kd>var</span> <span class=nv>fetchDataCallCount</span> <span class=p>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>  <span class=kd>var</span> <span class=nv>stubbedData</span><span class=p>:</span> <span class=n>Data</span><span class=p>?</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kd>func</span> <span class=nf>fetchData</span><span class=p>(</span><span class=n>completion</span><span class=p>:</span> <span class=p>@</span><span class=n>escaping</span> <span class=p>(</span><span class=n>Data</span><span class=p>?,</span> <span class=n>Error</span><span class=p>?)</span> <span class=p>-&gt;</span> <span class=nb>Void</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>fetchDataCallCount</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=n>completion</span><span class=p>(</span><span class=n>stubbedData</span><span class=p>,</span> <span class=kc>nil</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>然后可以验证模拟对象是否按预期被调用：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=kd>func</span> <span class=nf>testDataProviderIsCalledOnRefresh</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 创建模拟对象</span>
</span></span><span class=line><span class=cl>  <span class=kd>let</span> <span class=nv>mock</span> <span class=p>=</span> <span class=n>MockDataProvider</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 注入模拟对象</span>
</span></span><span class=line><span class=cl>  <span class=n>sut</span> <span class=p>=</span> <span class=n>SystemUnderTest</span><span class=p>(</span><span class=n>dataProvider</span><span class=p>:</span> <span class=n>mock</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 在刷新时应该调用数据提供者</span>
</span></span><span class=line><span class=cl>  <span class=n>sut</span><span class=p>.</span><span class=n>refresh</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 验证交互</span>
</span></span><span class=line><span class=cl>  <span class=n>XCTAssertEqual</span><span class=p>(</span><span class=n>mock</span><span class=p>.</span><span class=n>fetchDataCallCount</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=s>&#34;刷新应该调用一次数据提供者&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=xcode-中的-ui-测试>Xcode 中的 UI 测试<a hidden class=anchor aria-hidden=true href=#xcode-中的-ui-测试>#</a></h2><p>UI 测试模拟用户与应用程序界面的交互。这些测试非常有价值，因为它们验证整个应用程序从用户角度的工作方式。</p><h3 id=创建-ui-测试目标>创建 UI 测试目标<a hidden class=anchor aria-hidden=true href=#创建-ui-测试目标>#</a></h3><p>与单元测试类似，你可以从测试导航器创建 UI 测试目标，选择 &ldquo;New UI Test Target&mldr;"。</p><p>UI 测试使用 XCUIApplication 类启动你的应用程序，并通过 XCUIElement 查询与 UI 元素交互：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=kd>func</span> <span class=nf>testExample</span><span class=p>()</span> <span class=kr>throws</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 启动应用</span>
</span></span><span class=line><span class=cl>  <span class=kd>let</span> <span class=nv>app</span> <span class=p>=</span> <span class=n>XCUIApplication</span><span class=p>()</span>
</span></span><span class=line><span class=cl>  <span class=n>app</span><span class=p>.</span><span class=n>launch</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 与 UI 交互</span>
</span></span><span class=line><span class=cl>  <span class=n>app</span><span class=p>.</span><span class=n>buttons</span><span class=p>[</span><span class=s>&#34;增加&#34;</span><span class=p>].</span><span class=n>tap</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 验证 UI 状态</span>
</span></span><span class=line><span class=cl>  <span class=n>XCTAssertEqual</span><span class=p>(</span><span class=n>app</span><span class=p>.</span><span class=n>staticTexts</span><span class=p>[</span><span class=s>&#34;计数器&#34;</span><span class=p>].</span><span class=n>label</span><span class=p>,</span> <span class=s>&#34;1&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=记录-ui-测试>记录 UI 测试<a hidden class=anchor aria-hidden=true href=#记录-ui-测试>#</a></h3><p>Xcode 提供了一个记录功能，可以自动生成 UI 测试代码。在编辑器中放置光标，然后点击记录按钮，与应用交互。Xcode 将生成相应的测试代码。</p><h2 id=测试性能>测试性能<a hidden class=anchor aria-hidden=true href=#测试性能>#</a></h2><p>除了测试功能正确性，Xcode 还支持性能测试，用于确保你的代码保持高效：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=kd>func</span> <span class=nf>testPerformanceExample</span><span class=p>()</span> <span class=kr>throws</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>measure</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 放置要测量性能的代码</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=kc>_</span> <span class=k>in</span> <span class=mf>1.</span><span class=p>..</span><span class=mi>1000</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=kc>_</span> <span class=p>=</span> <span class=n>complexAlgorithm</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>当你运行这个测试时，Xcode 会多次执行 <code>measure</code> 块内的代码，并报告平均执行时间。如果执行时间明显变慢，测试将失败。</p><h2 id=启用代码覆盖率>启用代码覆盖率<a hidden class=anchor aria-hidden=true href=#启用代码覆盖率>#</a></h2><p>代码覆盖率是衡量测试质量的指标，它显示了你的测试覆盖了多少代码。</p><p>启用代码覆盖率步骤：</p><ol><li>编辑方案 (Edit Scheme)</li><li>选择 &ldquo;Test&rdquo; 操作</li><li>选择 &ldquo;Options&rdquo; 选项卡</li><li>勾选 &ldquo;Code Coverage&rdquo; 选项</li></ol><p>运行测试后，可以在报告导航器中查看覆盖率报告。</p><h3 id=追求-100-覆盖率>追求 100% 覆盖率？<a hidden class=anchor aria-hidden=true href=#追求-100-覆盖率>#</a></h3><p>虽然高代码覆盖率是好事，但盲目追求 100% 的覆盖率可能适得其反。测试的目标是确保代码的正确性，而不仅仅是提高覆盖率数字。</p><p>关注测试以下方面：</p><ul><li>容易出错的复杂逻辑</li><li>经常变化的代码</li><li>核心业务功能</li><li>已修复的 bug</li></ul><h2 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h2><p>本教程介绍了如何在 Xcode 中进行单元测试和 UI 测试。掌握这些测试技术将帮助你创建更可靠、更健壮的 iOS 应用。</p><p>关键要点：</p><ul><li>使用 <code>XCTAssert</code> 函数测试模型层</li><li>使用 <code>XCTestExpectation</code> 测试异步操作</li><li>使用存根和模拟对象隔离测试</li><li>创建 UI 测试验证用户交互</li><li>测量代码性能并监控变化</li><li>监控代码覆盖率，但关注测试质量而非数量</li></ul><p>最重要的是，养成编写测试的习惯。随着时间的推移，这将为你的应用程序构建一个安全网，让你能够自信地进行更改并添加新功能。</p><h2 id=参考资料>参考资料<a hidden class=anchor aria-hidden=true href=#参考资料>#</a></h2><ul><li><a href=https://developer.apple.com/documentation/xctest>Apple 官方文档：XCTest</a></li><li><a href=https://developer.apple.com/documentation/xctest/assertions_listed_by_category>Apple 按类别列出的断言</a></li><li><a href=https://developer.apple.com/videos/play/wwdc2019/413/>WWDC 视频：测试与 Xcode</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://zyf.im/tags/ios/>Ios</a></li></ul><nav class=paginav><a class=prev href=https://zyf.im/2018/03/27/self-sizing-uitextview-in-a-uitableviewcell/><span class=title>« Prev</span><br><span>UITableViewCell 自适应 UITextView 高度</span>
</a><a class=next href=https://zyf.im/2018/01/19/got-git-reading-notes-model/><span class=title>Next »</span><br><span>【Git 权威指南】读书笔记 - 协同模型</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://zyf.im/>ZYF.IM BLOG</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>