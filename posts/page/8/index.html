<!doctype html><html lang=en dir=auto data-theme=dark><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | ZYF.IM BLOG</title><meta name=keywords content><meta name=description content="Posts - ZYF.IM BLOG"><meta name=author content="Me"><link rel=canonical href=https://zyf.im/posts/><link crossorigin=anonymous href=/assets/css/stylesheet.88888b1f97bcb20b824590bc7c6603a852913a2540638b3b3e2663e642691da3.css integrity="sha256-iIiLH5e8sguCRZC8fGYDqFKROiVAY4s7PiZj5kJpHaM=" rel="preload stylesheet" as=style><link rel=icon href=https://zyf.im/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zyf.im/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://zyf.im/favicon-32x32.png><link rel=apple-touch-icon href=https://zyf.im/apple-touch-icon.png><link rel=mask-icon href=https://zyf.im/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://zyf.im/posts/index.xml title=rss><link rel=alternate hreflang=en href=https://zyf.im/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script>localStorage.getItem("pref-theme")==="light"&&(document.querySelector("html").dataset.theme="light")</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-6DVZ6E58DG"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-6DVZ6E58DG")}</script><meta property="og:url" content="https://zyf.im/posts/"><meta property="og:site_name" content="ZYF.IM BLOG"><meta property="og:title" content="Posts"><meta property="og:description" content="The limits of my language mean the limits of my world."><meta property="og:locale" content="en-us"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Posts"><meta name=twitter:description content="The limits of my language mean the limits of my world."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zyf.im/posts/"}]}</script></head><body class=list id=top><header class=header><nav class=nav><div class=logo><a href=https://zyf.im/ accesskey=h title="ZYF.IM (Alt + H)"><img src=https://zyf.im/apple-touch-icon.png alt aria-label=logo height=35>ZYF.IM</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://zyf.im/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://zyf.im/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://zyf.im/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://zyf.im/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://zyf.im/>Home</a></div><h1>Posts
<a href=/posts/index.xml title=RSS aria-label=RSS><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>m 进制转 n 进制</h2></header><div class=entry-content><p>思路 m 进制 -> 十进制 -> n 进制 利用柯里化生成函数（炫技 🐶） m 进制 -> 十进制 // carry 范围值: 2-36 // origin 范围值: 0-9 [ascii 48-58], A-Z [65-90], a-z [97-122] func carryToDecimalism(_ carry: Int) -> (_ origin: String) -> Int { return { origin in // 得到字符串对应的 ascii 码 let asciis = origin.uppercased().unicodeScalars.map { Int($0.value) } // 累加每一位 let result = asciis.reversed().enumerated().map { (index, ascii) -> Int in var standard: Int if 65 &lt;= ascii && ascii &lt;= 90 { standard = ascii - 65 + 10 } else { standard = ascii - 48 } return standard * Int(pow(Double(carry), Double(index))) }.reduce(0, +) return result } } let 十六进制转十进制 = carryToDecimalism(16) print(十六进制转十进制("1a")) // 26 let 二进制转十进制 = carryToDecimalism(2) print(二进制转十进制("110")) // 6 十进制 -> n 进制 func decimalismToCarry(_ carry: Int) -> (_ origin: Int) -> String { return { origin in var result = [Int]() var remain = origin while remain > 0 { result.append(remain % carry) remain /= carry } if carry &lt;= 10 { return result.reversed().map(String.init).joined() } else { return result.reversed().map { i -> String in return i &lt; 10 ? String(i) : String(UnicodeScalar(i + 55)!) }.joined() } } } let 十进制转二进制 = decimalismToCarry(2) print(十进制转二进制(26)) // "11010" References ASCII 码对照表 – EOF –</p></div><footer class=entry-footer><span title='2019-03-02 14:00:00 +0800 CST'>March 2, 2019</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>202 words</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to m 进制转 n 进制" href=https://zyf.im/2019/03/02/convert-m-number-to-n-number/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>超长阶乘的计算</h2></header><div class=entry-content><p>打印 n! 的结果（1 &lt;= n &lt;= 100）。注意：当 n > 20 时 64 位的 Int 将无法直接存储结果。
思路 将大数字用 数组 形式表示。比如 987 使用 [9,8,7] 代替。 每一位乘以 n，再进行进位操作，得到新数组。 let nums = [9, 8, 7] let tmpNums = nums.map { $0 * 2 } // [18, 16, 14] // 遍历 tmpNums 每一个数字，进行进制操作 [18, 16, 14] -> [18, 17, 4] -> [19, 7, 4] -> [1, 9, 7, 4] print(tmpNums.map(String.init).joined()) // 1974 解答项目 func extraLongFactorials(n: Int) -> Void { guard n > 0 else { return } // 结果数组 var result: [Int] = [1] for index in 1...n { // 数组翻转 从低位开始每一位乘以本次的数字 let tmpNums = result.reversed().map { $0 * index } // 进位数 var carryNum = 0 // 重置结果 result = [] tmpNums.forEach { // 每一位加上上一位的进的数 let tmpNum = $0 + carryNum // 向下一位进制的数 carryNum = tmpNum / 10 // 本位实际剩下的数 插入结果 result.append(tmpNum % 10) } // 处理剩余进位数 进位数是可能大于 100 while carryNum > 0 { // 逐渐插入进制 result.append(carryNum % 10) carryNum /= 10 } // 翻转回数组 result = result.reversed() } // 连接字符串 print(result.map(String.init).joined()) } References Extra Long Factorials | HackerRank Swift 3 calculate factorial number. Result becomes too high? – EOF –</p></div><footer class=entry-footer><span title='2019-03-01 14:00:00 +0800 CST'>March 1, 2019</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>187 words</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to 超长阶乘的计算" href=https://zyf.im/2019/03/01/extra-long-factorials/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>【Swifter - Swift 开发者必备 Tips】笔记</h2></header><div class=entry-content><p>再读王巍的《Swifter - Swift 开发者必备 Tips》，看看有什么新收获。
柯里化（Currying） 柯里化是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。这个词自己是第一次见到。
自己的理解是：把接受多个参数的函数变换为先接受一个参数，然后返回一个函数，这个函数再接受其他参数。
两个细节：
只有一个参数，并且这个参数是该函数的第一个参数。必须按照参数的定义顺序来调用柯里化函数。 柯里化函数的函数体只会执行一次，只会在调用完最后一个参数的时候执行柯里化函数体。 /// 一个数加 x 的函数 func addTo(_ adder: Int) -> (Int) -> Int { return { adder + $0 } } // +2 let addTwo = addTo(2) let result = addTwo(6) // 8 // +10 let addTen = addTo(10) addTen(6) // 16 柯里化是一种量产相似方法的好办法，可以通过柯里化一个方法模板来避免写出很多重复代码，也方便了今后维护。
书中还提到了一个封装 Selector 的例子，但是没懂，欢迎指教。
Reference:
Swift 函数柯里化介绍及使用场景 将 protocol 的方法声明为 mutating protocol 不仅可以被 class 类型实现，也适用于 struct 和 enum。因为这个原因，就要考虑定义的方法是否应该使用 mutating 来修饰。在 protocol 中使用 mutating 修饰的方法，对于 class 的实现是完全透明的。
多元组（Tuple） Python 中有见过类似用法。
/// 交互数据 func swapMe&lt;T>(_ a: inout T, _ b: inout T) { (a, b) = (b, a) } var a = 10 var b = 20 swapMe(&amp;a, &amp;b) // a: 20 b: 10 /// 可读的返回值 let rect = CGRect(x: 0, y: 0, width: 100, height: 100) let (slice, remainder) = rect.divided(atDistance: 20, from: .minYEdge) // slice {x 0 y 0 w 100 h 20} // remainder {x 0 y 20 w 100 h 80} @autoclosure 和 ?? @autoclosure 做的事情就是把一句表达式自动的封装成一个闭包（closure）。这样有时候在语法上看起来就会非常漂亮。
...</p></div><footer class=entry-footer><span title='2019-02-15 17:00:00 +0800 CST'>February 15, 2019</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>401 words</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to 【Swifter - Swift 开发者必备 Tips】笔记" href=https://zyf.im/2019/02/15/swifter-tips-reading-notes/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>回顾 2018</h2></header><div class=entry-content><p>重新翻阅的自己工作邮件的发件箱，回顾一年工作。新年伊始自己还是在开发 P 项目的 iOS App，开始写 Q&amp;A 功能。一些不算太难的 tableView 布局的需求，对我来说，都是头大的问题。
这段时期招聘时的面试，竟成为我学习 App 开发的一扇小窗。
年前收到了奖金还是挺开心的。leader 新年寄语：
要发声，要当主力 当有好的想法时，要学会说服别人 要有耐心，Yifan 需要时间的沉淀 前两点意思差不多，这段时间思想上困扰我的是：自己对自己的定位是一个初级工程师，认为会的东西、经验不多，见识少，我尊重比我年长的工程师的想法与观点，也相信他们是经过长远思考过的。这个思维设定，我觉得没有什么问题。但是也许有人忽略了 责任，对方案负责，对项目负责。开发方案一再重建性修改，接口结构没有规范。
2017 的总结说胜利属于伏地魔，本想苟着发育，这时发现：苟是苟不住的，这个世界 需要英雄 carry。
后来我感觉应该将公司看做一个舞台，舞台上有灯光、音效就要利用，展示自己、锻炼自己，即使是出糗，那就整理整理再来一次，who care? 成长是最重要的。
Course 模块是前工程师用 Objective-C 写的，离职后一直没有再维护，过年期间自己重构了所有 Objective-C 的代码，项目完全转为了一个纯 Swift 项目。使用 Realm 作为数据本地化方案，选择的原因也很朴素，GitHub 哪个星多我就优先选用什么。
后来参考 Jack Feng - 6ag 的几个 Swift 开源项目，新创建了 P 项目的工具 App，也对主项目结构做了重新的整理，在这里再次特别感谢。
西安运营部的成立，加多了 C 项目的后台需求，难以都顾及项目两头。使用 laravel-admin 搭建新后台，也开始使用 Docker 部署项目，感觉从此离不开 Docker 了，像极了遇到 Git 时的感觉。
C 项目主站的前端是在服务端渲染，非常传统的模式，多个工程师转手也是十分混乱。参考了 白俊遥 工程的博客、laravel 项目，修改了项目结构，添加了 gulp 工具制定了工作流，虽然没有实现前后端的完全分离，但终究是向现代化前端走出了一步。
转眼就到了年中调薪，公司不含糊，薪水涨到了我满意的值。这对我很关键，调整的不单单是我的薪水，也调整了我的心态。因为当时我认为没有强的工程师、甚至归我负责，却拿着比我还高的薪水。现在总算是有了一个平衡。
不断向 C 项目投入更多的资源，项目 指标 的要求越来越多。比如：优化了项目、优化了查询，到底优化了多少，怎么量化？这些在之前一直不被重视，改好了就都算叫优化了。项目中出现的问题错误，都要查找真实具体的原因，而不是说一个可能的什么原因，就当解答的了。我一开始也很难适应这些，但心里是认同的。
...</p></div><footer class=entry-footer><span title='2018-12-31 21:00:00 +0800 CST'>December 31, 2018</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>136 words</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to 回顾 2018" href=https://zyf.im/2018/12/31/review-2018/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>二分查找 Binary Search</h2></header><div class=entry-content><p>快速从一个数组中查找一个元素。
Linear Search 线性查找 func linearSearch&lt;T: Equatable>(_ a: [T], _ key: T) -> Int? { for i in 0 ..&lt; a.count { if a[i] == key { return i } } return nil } 线性查找在最坏情况：遍历了整个数组，但没有找到合适的元素。平均要遍历一半的元素性能为 O(n)，而二分查找的效率为 O(log n)，也就是说一个有 1,000,000 元素的数组只需要 20 步就可以找到想要的元素 log_2(1,000,000) = 19.9。
但是二分查找要求数组必须是排好序。
二分查找步骤：
将数组分为两半。 判断想要找的元素是在左边数组还是右边，这也是数组需要排好顺序的原因。 如果要的元素在左边，就将左边的数组分成更小的两部分，并判断要的元素在哪部分。 重复步骤直到找到想要的元素。如果数组不能进一步查分，就说明要找的元素不在数组中。 divide-and-conquer
The code func binarySearch&lt;T: Comparable>(_ a: [T], key: T, range: Range&lt;Int>) -> Int? { if range.lowerBound >= range.upperBound { // If we get here, then the search key is not present in the array. return nil } else { // Calculate where to split the array. let midIndex = range.lowerBound + (range.upperBound - range.lowerBound) / 2 // Is the search key in the left half? if a[midIndex] > key { return binarySearch(a, key: key, range: range.lowerBound ..&lt; midIndex) // Is the search key in the right half? // 这里 + 1 的原因是排除 midIndex 中间值 } else if a[midIndex] &lt; key { return binarySearch(a, key: key, range: midIndex + 1 ..&lt; range.upperBound) // If we get here, then we've found the search key! } else { return midIndex } } } // 19 numbers let numbers = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67] // 0 ..&lt; numbers.count 覆盖所有范围 binarySearch(numbers, key: 43, range: 0 ..&lt; numbers.count) // gives 13 二分查找是将数组分为两个，但是我们不需要正真的创建两个新数组。取而代之，我们使用 Swift Range 对象跟踪这些拆分。左闭右开。upperBound 总是比最后一个元素的索引多一。
...</p></div><footer class=entry-footer><span title='2018-12-10 14:00:00 +0800 CST'>December 10, 2018</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>329 words</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to 二分查找 Binary Search" href=https://zyf.im/2018/12/10/binary-search/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>插入排序 Insertion Sort</h2></header><div class=entry-content><p>将一个数组从高到低或者从低到高排序。
插入排序算法的工作原理：
将若干数字放在一个数组里，数组是乱序的。 从数组中挑选一个数字，它是哪个并不重要，但是为了方便我们挑选数组头部的这个。 将这个数字插入到一个新的数组里。 从乱序数组里挑选下一个数字也将它放到新数组里。这个数字要么在第一个数字前或者后，所以这个两个数字是被排序的。 再次重从乱序数组里挑选下一个数字也将它放到新数组里，并将数字放在正确的位置。 一直如此进行直到乱序数组中没有数字。这时也将等到一个排序好的新数组。 自己的一个实现：
let array = [2, 1, 3, 8, 3, 5, 4] var newArray = [Int]() for (k, v) in array.enumerated() { for (nK, nV) in newArray.enumerated() { // 本次的数 小于 存在的数的第一个(nv) if v &lt; nV { newArray.insert(v, at: nK) break } } // 没有插入成功 放在末尾 if newArray.count &lt; k + 1 { newArray.append(v) } } In-place sort 上面的排序需要两个数组，一个原始的，一个排好顺序的。但是我们也可以 就地排序 无需创建一个额外的数组。我们只需要跟踪记录原始数组中哪里部分排好顺序了，哪一部分还没有排序。
...</p></div><footer class=entry-footer><span title='2018-11-24 16:00:00 +0800 CST'>November 24, 2018</span>&nbsp;·&nbsp;<span>3 min</span>&nbsp;·&nbsp;<span>574 words</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to 插入排序 Insertion Sort" href=https://zyf.im/2018/11/24/insertion-sort/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>队列 Queue Data Structure</h2></header><div class=entry-content><p>实现一个 队列，包括 enqueue、dequeue、peek。
Queue 队列 核心也是 array，A queue gives you a FIFO or first-in, first-out order. 队列是：先进先出的。
public struct Queue&lt;T> { fileprivate var array = [T]() } enqueue 进队，在数组尾部追加元素。
public mutating func enqueue(_ element: T) { array.append(element) } dequeue 出队，将首位的元素移除。因为首位元素移除后，其他元素依次向前移动，所以是 O(n)。
public var isEmpty: Bool { // 使用数组自身的方法，而不是 array.count > 0 return array.isEmpty } public mutating func dequeue() -> T? { // 使用定义的变量 if isEmpty { return nil } else { return array.removeLast() } } peek 查看队首元素。
/// peek() 改为更有语义话的只读变量 public var front: T? { return array.first } 优化出队 在出队后不移动元素而是移动 起始索引，就像动的收银台而不是排队的人。
/// 优化 队列 的出队 public struct OptimizedQueue&lt;T> { /// 这里改为了可选型，为了可以清理无效的元素 fileprivate var array = [T?]() /// 起始索引 fileprivate var head = 0 public var count: Int { // 减去 起始索引 前面的数量 return array.count - head } public var isEmpty: Bool { // 根据实际数量判断 return count == 0 } // 保持不变 public mutating func enqueue(_ element: T) { array.append(element) } public mutating func dequeue() -> T? { guard head &lt; array.count, let element = array[head] else { return nil } // 置空当前位置元素 array[head] = nil // 前移起始索引 head += 1 // 空索引的占用比例 let percentage = Double(head)/Double(array.count) // 50 0.25 都是魔法数字，主要是为了控制数组修剪的频率，可以自行调整 if array.count > 50 && percentage > 0.25 { // 将起始空元素删除 array.removeFirst(head) // 重置 起始索引 head = 0 } return element } public var front: T? { if isEmpty { return nil } else { // 根据 起始索引进行 返回 return array[head] } } } 文章代码：GitHub - imzyf/data-structure-and-algorithm/002-Queue/。
...</p></div><footer class=entry-footer><span title='2018-11-22 16:00:00 +0800 CST'>November 22, 2018</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>239 words</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to 队列 Queue Data Structure" href=https://zyf.im/2018/11/22/queue-data-structure/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>栈 Stack Data Structure</h2></header><div class=entry-content><p>加入 Swift Algorithm Club /‘ælgə’rɪðəm/，回炉重新学习数据结构与算法。
自己创建的项目：GitHub - imzyf/data-structure-and-algorithm。
实现一个 栈 /stæk/，包含 push peek pop 与 Generics 泛型。
stack 栈 非常像一个数组，它包括少量的方法。
push 添加一个新元素到栈顶 pop 从栈顶移除一个元素 peek 查看栈顶的一个元素但是不 pop A stack gives you a LIFO or last-in first-out order. 栈是后进先出，队列是先进先出。
public struct Stack&lt;Element> { fileprivate var array: [Element] = [] } push push 是在数组的尾部添加元素是以 O(1)，如果是在数组最前添加是 O(n) 这是昂贵的。
public mutating func push(_ element: Element) { array.append(element) } 因为使用的 struct，修改属性值的方法要加 mutating。
pop 想从一个空栈中弹出最后一个元素将返回 nil。
...</p></div><footer class=entry-footer><span title='2018-11-22 14:00:00 +0800 CST'>November 22, 2018</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>126 words</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to 栈 Stack Data Structure" href=https://zyf.im/2018/11/22/stack-data-structure/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>在 MySQL 中选择合适的日期类型</h2></header><div class=entry-content><p>如何在 MySQL 中选择合适的日期类型困扰了很久，varchar、int、timestamp、datetime 都有尝试过，近来有所感悟，做此总结。
注：此总结考虑了 PHP 和 Laravel 框架的特点。
使用 varchar varchar 存储日期时间的格式完全可以自己控制，月/日/年 还是 年-月-日 需求怎么说就怎么存，读取后展示是也不用在格式化。同时伏笔也就此埋下：日期时间格式没强制约束，总有一天字段里出现了与众不同的格式；要是日期时间会 变化 或作为 查询条件 或要进行 排序 时就又是一坑，还是要格式化标准格式再处理。可以说 varchar 应该是最差的选择了。
使用 int 与 timestamp PHP time() 可以直接获取当前时间戳秒数，数据库字段要也是 int 一存就完事了，不会有格式问题，谁用什么样转什么样。但是在数据库工具中查看此字段时显示不够直观，范围时会不方便，这些在使用 timestamp 是会得到解决。
timestamp 是我一直迷惑的一个类型。我写了几个例子做测试：
将 Laravel 项目设置为 CST 中国标准时间，MySQL 时区设置为 UTC，使用 now() 获取当前日期时间，比如：2018-5-25 11:00:00 存入 timestamp 类型的字段中，使用数据库工具查看字段结果为仍然为 2018-5-25 11:00:00。 继续上面的操作，项目中使用查询语句查询刚才的记录，结果显示为 2018-5-25 11:00:00，将项目时区从 CST 改为 UTC 后再次查询的结果仍然为 2018-5-25 11:00:00 没有变化。 继续上面的操作，将数据库的时区改为 +8:00，数据库工具、项目查询后的结果为 2018-5-25 19:00:00 发生了变化，修改项目为 CST 查询结果是 2018-5-25 19:00:00 和刚才一样也变化了。 这个测试说明了：
...</p></div><footer class=entry-footer><span title='2018-05-25 16:00:00 +0800 CST'>May 25, 2018</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>254 words</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to 在 MySQL 中选择合适的日期类型" href=https://zyf.im/2018/05/25/select-the-appropriate-date-type-in-mysql/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>【Modern PHP】笔记</h2></header><div class=entry-content><p>又回到 PHP Web 开发，使用 Laravel 框架，重读《Modern PHP》。
PHP 正在重生。
特性 命名空间 声明命名空间：
&lt;?php namespace Oreilly\ModernPHP; 导入和别名：
&lt;?php use Symfony\Component\HttpFoundation\Response as Res; $r = new Res('Oops', 400); $r->send(); PHP 5.6 开始可以导入函数和常量：
&lt;?php use func Namespace\functionName; use constant Namespace\CONST_NAME; functionName(); echo CONST_NAME; 使用接口 接口是两个 PHP 对象之间的契约，其目的不是让一个对象依赖另一个对象的身份，而是依赖另一个对象的能力。
使用接口编写更加灵活，能委托别人实现细节。
性状 trait 性状是类的部分实现，可以混入一个或者多个现有的 PHP 类中。性状有两个作用：表明类可以做什么（像是接口）；提供模块化实现（像是类）。
如果想让两个无关的 PHP 类具有类似的行为，应该怎么呢？性状就是为了解决这种问题而诞生的。性状能把模块化的实现方式注入多个无关的类中。而且性状还能促进代码的重用。
这与创建一个接口，两个无关的类实现这个接口的优势在于：不用写相同的实现代码，符合 DRY 原则。
PHP 解释器在编译时会把性状复制粘贴到类的定义体中，但是不会处理这个操作引入的不兼容问题。如果性状假定类中有特定的属性和方法（在性状中没有定义），要确保相应的类中有对应的属性和方法。
生成器 Generator 是 PHP 5.5.0 引入的功能。生成器是简单的迭代器，仅此而已。
PHP 生成器不要求类实现 Iterator 接口，从而减轻了类的负担。生成器会根据需求计算并产生要迭代的值。这对应该的性能有重大影响。假如标准的 PHP 迭代器经常在内存中执行迭代操作，这要预先计算出数据集，性能低；此时我们可以使用生成器，即时计算并产出后续值，不占用宝贵的内存资源。
PHP 生成器不能满足所有迭代操作的需求，因为如果不查询，生成器永远不知道下一个要迭代的值是什么，在生成器中无法后退和快进。生成器还是一次性，无法多次迭代同一个生成器。不过，如果需要，可以重建或克隆生成器。
PHP 生成器是 PHP 函数，只不过要在函数中一次或者多次使用 yield 关键字。生成器从不返回值，值产出值。
function myGenerator() { yield 'value1'; yield 'value2'; yield 'value3'; } foreach (myGenerator() as $yieldedValue) { echo $yieldedValue, PHP_EOL; } value1 value2 value3 使用生成器处理 CSV：
...</p></div><footer class=entry-footer><span title='2018-05-08 17:00:00 +0800 CST'>May 8, 2018</span>&nbsp;·&nbsp;<span>3 min</span>&nbsp;·&nbsp;<span>572 words</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to 【Modern PHP】笔记" href=https://zyf.im/2018/05/08/modern-php-reading-notes/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://zyf.im/posts/page/7/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://zyf.im/posts/page/9/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://zyf.im/>ZYF.IM BLOG</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>