<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Composer vendor 提交至 Git | ZYF.IM BLOG</title>
<meta name=keywords content="php,composer,git"><meta name=description content='应该将 vendor 提交到 Git 吗
一般建议是 不。vendor 目录应添加到 .gitignore。
最佳实践是让所有开发人员使用 Composer 来安装依赖项。类似地，构建服务器、CI、部署工具等都应该作为项目启动的一部分来运行 Composer。
虽然在某些环境下这样做很诱人，但也会导致一些问题：

大型 VCS 存储库的大小和更新代码时的差异。
在你自己的 VCS 复制你所有依赖的历史。
将通过 git 安装的依赖项添加到 git repo 中将显示为 submodules。这是有问题的，因为它们不是真正的 submodules，您将会遇到问题。

如果你真的觉得你必须这样做，你有几个选择：

限制自己安装带标记的版本（没有 dev 版本），这样就只能安装压缩版，并避免与 git submodules 有关的问题。
Use --prefer-dist or set preferred-install to dist in your config.
Remove the .git directory of every dependency after the installation, then you can add them to your git repo. You can do that with rm -rf vendor/\*\*/.git in ZSH or find vendor/ -type d -name ".git" -exec rm -rf {} \; in Bash. 但这意味着您必须在运行 composer 更新之前从磁盘中删除这些依赖项。
Add a .gitignore rule /vendor/**/.git to ignore all the vendor .git folders. 这种方法不需要在运行编写器更新之前从磁盘删除依赖项。

我的做法

问题解决了，但是不确信做法是否正确。'><meta name=author content="Me"><link rel=canonical href=https://zyf.im/2020/08/10/commit-composer-vendor-to-git/><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://zyf.im/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zyf.im/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://zyf.im/favicon-32x32.png><link rel=apple-touch-icon href=https://zyf.im/apple-touch-icon.png><link rel=mask-icon href=https://zyf.im/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://zyf.im/2020/08/10/commit-composer-vendor-to-git/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:url" content="https://zyf.im/2020/08/10/commit-composer-vendor-to-git/"><meta property="og:site_name" content="ZYF.IM BLOG"><meta property="og:title" content="Composer vendor 提交至 Git"><meta property="og:description" content='应该将 vendor 提交到 Git 吗 一般建议是 不。vendor 目录应添加到 .gitignore。
最佳实践是让所有开发人员使用 Composer 来安装依赖项。类似地，构建服务器、CI、部署工具等都应该作为项目启动的一部分来运行 Composer。
虽然在某些环境下这样做很诱人，但也会导致一些问题：
大型 VCS 存储库的大小和更新代码时的差异。 在你自己的 VCS 复制你所有依赖的历史。 将通过 git 安装的依赖项添加到 git repo 中将显示为 submodules。这是有问题的，因为它们不是真正的 submodules，您将会遇到问题。 如果你真的觉得你必须这样做，你有几个选择：
限制自己安装带标记的版本（没有 dev 版本），这样就只能安装压缩版，并避免与 git submodules 有关的问题。 Use --prefer-dist or set preferred-install to dist in your config. Remove the .git directory of every dependency after the installation, then you can add them to your git repo. You can do that with rm -rf vendor/\*\*/.git in ZSH or find vendor/ -type d -name ".git" -exec rm -rf {} \; in Bash. 但这意味着您必须在运行 composer 更新之前从磁盘中删除这些依赖项。 Add a .gitignore rule /vendor/**/.git to ignore all the vendor .git folders. 这种方法不需要在运行编写器更新之前从磁盘删除依赖项。 我的做法 问题解决了，但是不确信做法是否正确。'><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-08-10T14:24:47+00:00"><meta property="article:modified_time" content="2020-08-10T14:24:47+00:00"><meta property="article:tag" content="Php"><meta property="article:tag" content="Composer"><meta property="article:tag" content="Git"><meta name=twitter:card content="summary"><meta name=twitter:title content="Composer vendor 提交至 Git"><meta name=twitter:description content='应该将 vendor 提交到 Git 吗
一般建议是 不。vendor 目录应添加到 .gitignore。
最佳实践是让所有开发人员使用 Composer 来安装依赖项。类似地，构建服务器、CI、部署工具等都应该作为项目启动的一部分来运行 Composer。
虽然在某些环境下这样做很诱人，但也会导致一些问题：

大型 VCS 存储库的大小和更新代码时的差异。
在你自己的 VCS 复制你所有依赖的历史。
将通过 git 安装的依赖项添加到 git repo 中将显示为 submodules。这是有问题的，因为它们不是真正的 submodules，您将会遇到问题。

如果你真的觉得你必须这样做，你有几个选择：

限制自己安装带标记的版本（没有 dev 版本），这样就只能安装压缩版，并避免与 git submodules 有关的问题。
Use --prefer-dist or set preferred-install to dist in your config.
Remove the .git directory of every dependency after the installation, then you can add them to your git repo. You can do that with rm -rf vendor/\*\*/.git in ZSH or find vendor/ -type d -name ".git" -exec rm -rf {} \; in Bash. 但这意味着您必须在运行 composer 更新之前从磁盘中删除这些依赖项。
Add a .gitignore rule /vendor/**/.git to ignore all the vendor .git folders. 这种方法不需要在运行编写器更新之前从磁盘删除依赖项。

我的做法

问题解决了，但是不确信做法是否正确。'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zyf.im/posts/"},{"@type":"ListItem","position":2,"name":"Composer vendor 提交至 Git","item":"https://zyf.im/2020/08/10/commit-composer-vendor-to-git/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Composer vendor 提交至 Git","name":"Composer vendor 提交至 Git","description":"应该将 vendor 提交到 Git 吗 一般建议是 不。vendor 目录应添加到 .gitignore。\n最佳实践是让所有开发人员使用 Composer 来安装依赖项。类似地，构建服务器、CI、部署工具等都应该作为项目启动的一部分来运行 Composer。\n虽然在某些环境下这样做很诱人，但也会导致一些问题：\n大型 VCS 存储库的大小和更新代码时的差异。 在你自己的 VCS 复制你所有依赖的历史。 将通过 git 安装的依赖项添加到 git repo 中将显示为 submodules。这是有问题的，因为它们不是真正的 submodules，您将会遇到问题。 如果你真的觉得你必须这样做，你有几个选择：\n限制自己安装带标记的版本（没有 dev 版本），这样就只能安装压缩版，并避免与 git submodules 有关的问题。 Use --prefer-dist or set preferred-install to dist in your config. Remove the .git directory of every dependency after the installation, then you can add them to your git repo. You can do that with rm -rf vendor/\\*\\*/.git in ZSH or find vendor/ -type d -name \u0026quot;.git\u0026quot; -exec rm -rf {} \\; in Bash. 但这意味着您必须在运行 composer 更新之前从磁盘中删除这些依赖项。 Add a .gitignore rule /vendor/**/.git to ignore all the vendor .git folders. 这种方法不需要在运行编写器更新之前从磁盘删除依赖项。 我的做法 问题解决了，但是不确信做法是否正确。\n","keywords":["php","composer","git"],"articleBody":"应该将 vendor 提交到 Git 吗 一般建议是 不。vendor 目录应添加到 .gitignore。\n最佳实践是让所有开发人员使用 Composer 来安装依赖项。类似地，构建服务器、CI、部署工具等都应该作为项目启动的一部分来运行 Composer。\n虽然在某些环境下这样做很诱人，但也会导致一些问题：\n大型 VCS 存储库的大小和更新代码时的差异。 在你自己的 VCS 复制你所有依赖的历史。 将通过 git 安装的依赖项添加到 git repo 中将显示为 submodules。这是有问题的，因为它们不是真正的 submodules，您将会遇到问题。 如果你真的觉得你必须这样做，你有几个选择：\n限制自己安装带标记的版本（没有 dev 版本），这样就只能安装压缩版，并避免与 git submodules 有关的问题。 Use --prefer-dist or set preferred-install to dist in your config. Remove the .git directory of every dependency after the installation, then you can add them to your git repo. You can do that with rm -rf vendor/\\*\\*/.git in ZSH or find vendor/ -type d -name \".git\" -exec rm -rf {} \\; in Bash. 但这意味着您必须在运行 composer 更新之前从磁盘中删除这些依赖项。 Add a .gitignore rule /vendor/**/.git to ignore all the vendor .git folders. 这种方法不需要在运行编写器更新之前从磁盘删除依赖项。 我的做法 问题解决了，但是不确信做法是否正确。\n因为网络环境与部署的原因，在生产环境下是将 vendor 目录提交到 git 中的。使用过程中确实出现了，部分类库成为了 submodules，无法把真实的代码提交进 git。\n可尝试执行：\ngit rm rf --cache vendor git add . git commit -m \"add vendor\" References Should I commit the dependencies in my vendor directory? | getcomposer – EOF –\n","wordCount":"142","inLanguage":"en","datePublished":"2020-08-10T14:24:47Z","dateModified":"2020-08-10T14:24:47Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zyf.im/2020/08/10/commit-composer-vendor-to-git/"},"publisher":{"@type":"Organization","name":"ZYF.IM BLOG","logo":{"@type":"ImageObject","url":"https://zyf.im/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://zyf.im/ accesskey=h title="ZYF.IM (Alt + H)"><img src=https://zyf.im/apple-touch-icon.png alt aria-label=logo height=35>ZYF.IM</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://zyf.im/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://zyf.im/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://zyf.im/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://zyf.im/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://zyf.im/>Home</a>&nbsp;»&nbsp;<a href=https://zyf.im/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Composer vendor 提交至 Git</h1><div class=post-meta><span title='2020-08-10 14:24:47 +0000 UTC'>August 10, 2020</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;142 words&nbsp;·&nbsp;Me</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#应该将-vendor-提交到-git-吗>应该将 vendor 提交到 Git 吗</a></li><li><a href=#我的做法>我的做法</a></li><li><a href=#references>References</a></li></ul></nav></div></details></div><div class=post-content><h2 id=应该将-vendor-提交到-git-吗>应该将 vendor 提交到 Git 吗<a hidden class=anchor aria-hidden=true href=#应该将-vendor-提交到-git-吗>#</a></h2><p>一般建议是 <strong>不</strong>。<code>vendor</code> 目录应添加到 <code>.gitignore</code>。</p><p>最佳实践是让所有开发人员使用 Composer 来安装依赖项。类似地，构建服务器、CI、部署工具等都应该作为项目启动的一部分来运行 Composer。</p><p>虽然在某些环境下这样做很诱人，但也会导致一些问题：</p><ul><li>大型 VCS 存储库的大小和更新代码时的差异。</li><li>在你自己的 VCS 复制你所有依赖的历史。</li><li>将通过 git 安装的依赖项添加到 git repo 中将显示为 <code>submodules</code>。这是有问题的，因为它们不是真正的 <code>submodules</code>，您将会遇到问题。</li></ul><p>如果你真的觉得你必须这样做，你有几个选择：</p><ul><li>限制自己安装带标记的版本（没有 dev 版本），这样就只能安装压缩版，并避免与 git <code>submodules</code> 有关的问题。</li><li>Use <code>--prefer-dist</code> or set <code>preferred-install</code> to <code>dist</code> in your config.</li><li>Remove the <code>.git</code> directory of every dependency after the installation, then you can add them to your git repo. You can do that with <code>rm -rf vendor/\*\*/.git</code> in ZSH or <code>find vendor/ -type d -name ".git" -exec rm -rf {} \;</code> in Bash. 但这意味着您必须在运行 composer 更新之前从磁盘中删除这些依赖项。</li><li>Add a <code>.gitignore</code> rule <code>/vendor/**/.git</code> to ignore all the vendor <code>.git</code> folders. 这种方法不需要在运行编写器更新之前从磁盘删除依赖项。</li></ul><h2 id=我的做法>我的做法<a hidden class=anchor aria-hidden=true href=#我的做法>#</a></h2><blockquote><p>问题解决了，但是不确信做法是否正确。</p></blockquote><p>因为网络环境与部署的原因，在生产环境下是将 <code>vendor</code> 目录提交到 <code>git</code> 中的。使用过程中确实出现了，部分类库成为了 <code>submodules</code>，无法把真实的代码提交进 git。</p><p>可尝试执行：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git rm rf --cache vendor
</span></span><span class=line><span class=cl>git add .
</span></span><span class=line><span class=cl>git commit -m <span class=s2>&#34;add vendor&#34;</span>
</span></span></code></pre></div><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><ul><li><a href=https://getcomposer.org/doc/faqs/should-i-commit-the-dependencies-in-my-vendor-directory.md>Should I commit the dependencies in my vendor directory? | getcomposer</a></li></ul><p>&ndash; EOF &ndash;</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://zyf.im/tags/php/>Php</a></li><li><a href=https://zyf.im/tags/composer/>Composer</a></li><li><a href=https://zyf.im/tags/git/>Git</a></li></ul><nav class=paginav><a class=prev href=https://zyf.im/2020/08/14/mysql-json-data-type/><span class=title>« Prev</span><br><span>MySQL JSON 数据类型</span>
</a><a class=next href=https://zyf.im/2020/06/29/tcpdump-getting-started/><span class=title>Next »</span><br><span>tcpdump 入门使用</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://zyf.im/>ZYF.IM BLOG</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>