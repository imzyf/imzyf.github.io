<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>tcpdump 入门使用 | ZYF.IM BLOG</title><meta name=keywords content="linux"><meta name=description content="tcpdump 是 Unix/Linux 下的抓包工具，可以针对指定网卡、端口、协议进行抓包。

字太多不看
sudo tcpdump host api.test and tcp port 80 -A -nn
sudo tcpdump dst api.test and tcp port 80 -A
一举成名天下知
man tcpdump
获取适配器列表
tcpdump -D
tcpdump --list-interfaces

1.en0 [Up, Running]
2.p2p0 [Up, Running]
3.awdl0 [Up, Running]
4.llw0 [Up, Running]
5.utun0 [Up, Running]
6.utun1 [Up, Running]
7.utun2 [Up, Running]
8.en5 [Up, Running]
9.lo0 [Up, Running, Loopback]
10.bridge0 [Up, Running]
11.en1 [Up, Running]
12.en2 [Up, Running]
13.en3 [Up, Running]
14.en4 [Up, Running]
15.gif0 [none]
16.stf0 [none]
17.XHC0 [none]
18.XHC1 [none]
19.ap1 [none]
20.XHC20 [none]
21.VHC128 [none]
监听适配器
Listen on interface."><meta name=author content="Me"><link rel=canonical href=https://zyf.im/2020/06/29/tcpdump-getting-started/><link crossorigin=anonymous href=/assets/css/stylesheet.63618a0fd0c7dd946ad6f368012c097fc6e5a8464cefd289c140dd28c01ec58d.css integrity="sha256-Y2GKD9DH3ZRq1vNoASwJf8blqEZM79KJwUDdKMAexY0=" rel="preload stylesheet" as=style><link rel=icon href=https://zyf.im/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zyf.im/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://zyf.im/favicon-32x32.png><link rel=apple-touch-icon href=https://zyf.im/apple-touch-icon.png><link rel=mask-icon href=https://zyf.im/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://zyf.im/2020/06/29/tcpdump-getting-started/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-6DVZ6E58DG"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-6DVZ6E58DG")}</script><meta property="og:url" content="https://zyf.im/2020/06/29/tcpdump-getting-started/"><meta property="og:site_name" content="ZYF.IM BLOG"><meta property="og:title" content="tcpdump 入门使用"><meta property="og:description" content="tcpdump 是 Unix/Linux 下的抓包工具，可以针对指定网卡、端口、协议进行抓包。
字太多不看 sudo tcpdump host api.test and tcp port 80 -A -nn sudo tcpdump dst api.test and tcp port 80 -A 一举成名天下知 man tcpdump 获取适配器列表 tcpdump -D tcpdump --list-interfaces 1.en0 [Up, Running] 2.p2p0 [Up, Running] 3.awdl0 [Up, Running] 4.llw0 [Up, Running] 5.utun0 [Up, Running] 6.utun1 [Up, Running] 7.utun2 [Up, Running] 8.en5 [Up, Running] 9.lo0 [Up, Running, Loopback] 10.bridge0 [Up, Running] 11.en1 [Up, Running] 12.en2 [Up, Running] 13.en3 [Up, Running] 14.en4 [Up, Running] 15.gif0 [none] 16.stf0 [none] 17.XHC0 [none] 18.XHC1 [none] 19.ap1 [none] 20.XHC20 [none] 21.VHC128 [none] 监听适配器 Listen on interface."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-06-29T10:24:16+00:00"><meta property="article:modified_time" content="2020-06-29T10:24:16+00:00"><meta property="article:tag" content="Linux"><meta property="og:image" content="https://images.unsplash.com/photo-1556228841-7c69921649bb?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=960&amp;q=80"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://images.unsplash.com/photo-1556228841-7c69921649bb?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=960&amp;q=80"><meta name=twitter:title content="tcpdump 入门使用"><meta name=twitter:description content="tcpdump 是 Unix/Linux 下的抓包工具，可以针对指定网卡、端口、协议进行抓包。

字太多不看
sudo tcpdump host api.test and tcp port 80 -A -nn
sudo tcpdump dst api.test and tcp port 80 -A
一举成名天下知
man tcpdump
获取适配器列表
tcpdump -D
tcpdump --list-interfaces

1.en0 [Up, Running]
2.p2p0 [Up, Running]
3.awdl0 [Up, Running]
4.llw0 [Up, Running]
5.utun0 [Up, Running]
6.utun1 [Up, Running]
7.utun2 [Up, Running]
8.en5 [Up, Running]
9.lo0 [Up, Running, Loopback]
10.bridge0 [Up, Running]
11.en1 [Up, Running]
12.en2 [Up, Running]
13.en3 [Up, Running]
14.en4 [Up, Running]
15.gif0 [none]
16.stf0 [none]
17.XHC0 [none]
18.XHC1 [none]
19.ap1 [none]
20.XHC20 [none]
21.VHC128 [none]
监听适配器
Listen on interface."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zyf.im/posts/"},{"@type":"ListItem","position":2,"name":"tcpdump 入门使用","item":"https://zyf.im/2020/06/29/tcpdump-getting-started/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"tcpdump 入门使用","name":"tcpdump 入门使用","description":"tcpdump 是 Unix/Linux 下的抓包工具，可以针对指定网卡、端口、协议进行抓包。\n字太多不看 sudo tcpdump host api.test and tcp port 80 -A -nn sudo tcpdump dst api.test and tcp port 80 -A 一举成名天下知 man tcpdump 获取适配器列表 tcpdump -D tcpdump --list-interfaces 1.en0 [Up, Running] 2.p2p0 [Up, Running] 3.awdl0 [Up, Running] 4.llw0 [Up, Running] 5.utun0 [Up, Running] 6.utun1 [Up, Running] 7.utun2 [Up, Running] 8.en5 [Up, Running] 9.lo0 [Up, Running, Loopback] 10.bridge0 [Up, Running] 11.en1 [Up, Running] 12.en2 [Up, Running] 13.en3 [Up, Running] 14.en4 [Up, Running] 15.gif0 [none] 16.stf0 [none] 17.XHC0 [none] 18.XHC1 [none] 19.ap1 [none] 20.XHC20 [none] 21.VHC128 [none] 监听适配器 Listen on interface.\n","keywords":["linux"],"articleBody":"tcpdump 是 Unix/Linux 下的抓包工具，可以针对指定网卡、端口、协议进行抓包。\n字太多不看 sudo tcpdump host api.test and tcp port 80 -A -nn sudo tcpdump dst api.test and tcp port 80 -A 一举成名天下知 man tcpdump 获取适配器列表 tcpdump -D tcpdump --list-interfaces 1.en0 [Up, Running] 2.p2p0 [Up, Running] 3.awdl0 [Up, Running] 4.llw0 [Up, Running] 5.utun0 [Up, Running] 6.utun1 [Up, Running] 7.utun2 [Up, Running] 8.en5 [Up, Running] 9.lo0 [Up, Running, Loopback] 10.bridge0 [Up, Running] 11.en1 [Up, Running] 12.en2 [Up, Running] 13.en3 [Up, Running] 14.en4 [Up, Running] 15.gif0 [none] 16.stf0 [none] 17.XHC0 [none] 18.XHC1 [none] 19.ap1 [none] 20.XHC20 [none] 21.VHC128 [none] 监听适配器 Listen on interface.\nmacOS 下监听适配器，必须使用 root 权限。\nsudo tcpdump -i en0 sudo tcpdump -i 1 过滤监听适配器 过滤主机 # 抓取所有经过 en0，目的或源地址是 192.168.50.1 的网络数据 sudo tcpdump -i en0 host 192.168.50.1 # 源地址 sudo tcpdump -i en0 src host 192.168.50.1 # 目的地址 sudo tcpdump -i en0 dst host 192.168.50.1 过滤端口 sudo tcpdump -i en0 port 8080 过滤网段 sudo tcpdump -i en0 net 192.168 协议过滤 sudo tcpdump -i en0 tcp sudo tcpdump -i en0 udp sudo tcpdump -i en0 ip sudo tcpdump -i en0 arp sudo tcpdump -i en0 icmp 使用表达式 与：\u0026\u0026 或 and 或：|| 或 or 非：! 或 not 选项 tcpdump 默认只会截取前 96 字节的内容，要想截取所有的报文内容，可以使用 -s number， number 就是你要截取的报文字节数，如果是 0 的话，表示截取报文全部内容。\n-i any 监听所有的网卡 -n 不要解析域名，会优先暂时主机的名字 -nn 不展示主机名和端口名（比如 443 端口会被展示成 https） -A 只使用 ascii 打印报文的全部数据，不要和 -X 一起使用。截取 http 请求的时候可以用 sudo tcpdump -nSA port 80 -X 同时用 hex 和 ascii 显示报文的内容 -XX 同 -X，但同时显示以太网头部 -S 显示绝对的序列号（sequence number），而不是相对编号 -s 截取的包字节长度，默认情况下 tcpdump 会展示 96 字节的长度，要获取完整的长度可以用 -s0 或者 -s1600。 -v, -vv, -vvv：显示更多的详细信息 -c number 截取 number 个报文，然后结束 Flags tcpdump Flags | readthedocs\nTCP Flag Flag Meaning SYN S Syn packet, a session establishment request. 一个会话建立请求 ACK A Ack packet, acknowledge sender’s data. 确认发送方的数据 FIN F Finish flag, indication of termination. 终止的的标识 RESET R Reset, indication of immediate abort of conn. 指令立即中止 PUSH P Push, immediate push of data from sender. 从发送方立即推送数据 URGENT U Urgent, takes precedence over other data. 优先于其他数据 NONE A dot . Placeholder, usually used for ACK. 占位符，通常用于 ACK 实例 抓取所有经过 eth1，目的地址是 192.168.1.254 或 192.168.1.200 端口是 80 的 TCP 数据：\nsudo tcpdump -i eth1 '((tcp) and (port 80) and ((dst host 192.168.1.254) or (dst host 192.168.1.200)))' 抓取所有经过 eth1，目的网络是 192.168，但目的主机不是 192.168.1.200 的 TCP 数据：\nsudo tcpdump -i eth1 '((tcp) and ((dst net 192.168) and (not dst host 192.168.1.200)))' 只抓 SYN 包：\nsudo tcpdump -i eth1 'tcp[tcpflags] = tcp-syn' 抓 SYN, ACK：\nsudo tcpdump -i eth1 'tcp[tcpflags] \u0026 tcp-syn != 0 and tcp[tcpflags] \u0026 tcp-ack != 0' 抓 DNS 请求数据：\nsudo tcpdump -i en0 udp dst port 53 -c 参数对于运维人员来说也比较常用，因为流量比较大的服务器，靠人工 CTRL+C 还是抓的太多，于是可以用 -c 参数指定抓多少个包：\nsudo time tcpdump -nn -i en0 'tcp[tcpflags] = tcp-syn' -c 10000 \u003e /dev/null 实时抓取端口号 8000 的 GET 包，然后写入 GET.log：\nsudo tcpdump -i eth0 '((port 8000) and (tcp[(tcp[12]\u003e\u003e2):4]=0x47455420))' -nnAl -w /tmp/GET.log 三次握手 四次挥手 TCP 连接建立（三次握手） 客户端 A，服务器 B，初始序号 seq，确认号 ack。\n初始状态：B 处于监听状态，A 处于打开状态。\nA -\u003e B : seq = x （A 向 B 发送连接请求报文段，A 进入同步发送状态 SYN-SENT） B -\u003e A : ack = x + 1,seq = y （B 收到报文段，向 A 发送确认，B 进入同步收到状态 SYN-RCVD） A -\u003e B : ack = y + 1 （A 收到 B 的确认后，再次确认，A 进入连接状态 ESTABLISHED） 连接后的状态：B 收到 A 的确认后，进入连接状态 ESTABLISHED。\n为什么要握手要三次？防止失效的连接请求突然传到服务器端，让服务器端误认为要建立连接。\nTCP 连接释放（四次挥手） A -\u003e B : seq = u （A 发出连接释放报文段，进入终止等待 1 状态 FIN-WAIT-1） B -\u003e A : ack = u + 1,seq = v （B 收到报文段，发出确认，TCP 处于半关闭，B 还可向 A 发数据，B 进入关闭等待状态 WAIT） B -\u003e A : ack = u + 1,seq = w （B 重复发送确认号，进入最后确认状态 LAST-ACK） A -\u003e B : ack = w + 1,seq = u + 1 （A 发出确认，进入时间等待状态 TIME-WAIT） 经过时间等待计时器设置的时间 2MSL 后，A 才进入 CLOSED 状态。\n为什么 A 进入 TIME-WAIT 后必须等待 2MSL：\n保证 A 发送的最后一个 ACK 报文段能达到 B 防止失效的报文段出现在连接中 需要思考的问题 问题 1: 请详细描述三次握手和四次挥手的过程 要求熟悉三次握手和四次挥手的机制，要求画出状态图。\n问题 2: 四次挥手中 TIME_WAIT 状态存在的目的是什么? 这个问题是画出四次挥手状态图，会引申问你。不排除还会问为什么四次挥手是四次不是二次等问题。最好是把相关问题均掌握。\n问题 3: TCP 是通过什么机制保障可靠性的? 从四个方面进行回答，ACK 确认机制、超时重传、滑动窗口以及流量控制，深入的话要求详细讲出流量控制的机制。\n抓包分析握手过程 sudo tcpdump -i en0 host www.qq.com and tcp -S -c 50 References macOS 下使用 tcpdump 抓包 | jianshu tcpdump | readthedocs TCP 三次握手、四次挥手与 TcpDump 抓包分析 | 清泉白石 – EOF –\n","wordCount":"639","inLanguage":"en","image":"https://images.unsplash.com/photo-1556228841-7c69921649bb?ixlib=rb-1.2.1\u0026ixid=eyJhcHBfaWQiOjEyMDd9\u0026auto=format\u0026fit=crop\u0026w=960\u0026q=80","datePublished":"2020-06-29T10:24:16Z","dateModified":"2020-06-29T10:24:16Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zyf.im/2020/06/29/tcpdump-getting-started/"},"publisher":{"@type":"Organization","name":"ZYF.IM BLOG","logo":{"@type":"ImageObject","url":"https://zyf.im/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://zyf.im/ accesskey=h title="ZYF.IM (Alt + H)"><img src=https://zyf.im/apple-touch-icon.png alt aria-label=logo height=35>ZYF.IM</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://zyf.im/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://zyf.im/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://zyf.im/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://zyf.im/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://zyf.im/>Home</a>&nbsp;»&nbsp;<a href=https://zyf.im/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">tcpdump 入门使用</h1><div class=post-meta><span title='2020-06-29 10:24:16 +0000 UTC'>June 29, 2020</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;639 words&nbsp;·&nbsp;Me</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#字太多不看>字太多不看</a></li><li><a href=#一举成名天下知>一举成名天下知</a></li><li><a href=#获取适配器列表>获取适配器列表</a></li><li><a href=#监听适配器>监听适配器</a></li><li><a href=#过滤监听适配器>过滤监听适配器</a><ul><li><a href=#过滤主机>过滤主机</a></li><li><a href=#过滤端口>过滤端口</a></li><li><a href=#过滤网段>过滤网段</a></li><li><a href=#协议过滤>协议过滤</a></li><li><a href=#使用表达式>使用表达式</a></li></ul></li><li><a href=#选项>选项</a></li><li><a href=#flags>Flags</a></li><li><a href=#实例>实例</a></li><li><a href=#三次握手-四次挥手>三次握手 四次挥手</a><ul><li><a href=#tcp-连接建立三次握手>TCP 连接建立（三次握手）</a></li><li><a href=#tcp-连接释放四次挥手>TCP 连接释放（四次挥手）</a></li><li><a href=#需要思考的问题>需要思考的问题</a></li><li><a href=#抓包分析握手过程>抓包分析握手过程</a></li></ul></li><li><a href=#references>References</a></li></ul></nav></div></details></div><div class=post-content><p>tcpdump 是 Unix/Linux 下的抓包工具，可以针对指定网卡、端口、协议进行抓包。</p><h2 id=字太多不看>字太多不看<a hidden class=anchor aria-hidden=true href=#字太多不看>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>sudo tcpdump host api.test and tcp port <span class=m>80</span> -A -nn
</span></span><span class=line><span class=cl>sudo tcpdump dst api.test and tcp port <span class=m>80</span> -A
</span></span></code></pre></div><h2 id=一举成名天下知>一举成名天下知<a hidden class=anchor aria-hidden=true href=#一举成名天下知>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>man tcpdump
</span></span></code></pre></div><h2 id=获取适配器列表>获取适配器列表<a hidden class=anchor aria-hidden=true href=#获取适配器列表>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>tcpdump -D
</span></span><span class=line><span class=cl>tcpdump --list-interfaces
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>1.en0 <span class=o>[</span>Up, Running<span class=o>]</span>
</span></span><span class=line><span class=cl>2.p2p0 <span class=o>[</span>Up, Running<span class=o>]</span>
</span></span><span class=line><span class=cl>3.awdl0 <span class=o>[</span>Up, Running<span class=o>]</span>
</span></span><span class=line><span class=cl>4.llw0 <span class=o>[</span>Up, Running<span class=o>]</span>
</span></span><span class=line><span class=cl>5.utun0 <span class=o>[</span>Up, Running<span class=o>]</span>
</span></span><span class=line><span class=cl>6.utun1 <span class=o>[</span>Up, Running<span class=o>]</span>
</span></span><span class=line><span class=cl>7.utun2 <span class=o>[</span>Up, Running<span class=o>]</span>
</span></span><span class=line><span class=cl>8.en5 <span class=o>[</span>Up, Running<span class=o>]</span>
</span></span><span class=line><span class=cl>9.lo0 <span class=o>[</span>Up, Running, Loopback<span class=o>]</span>
</span></span><span class=line><span class=cl>10.bridge0 <span class=o>[</span>Up, Running<span class=o>]</span>
</span></span><span class=line><span class=cl>11.en1 <span class=o>[</span>Up, Running<span class=o>]</span>
</span></span><span class=line><span class=cl>12.en2 <span class=o>[</span>Up, Running<span class=o>]</span>
</span></span><span class=line><span class=cl>13.en3 <span class=o>[</span>Up, Running<span class=o>]</span>
</span></span><span class=line><span class=cl>14.en4 <span class=o>[</span>Up, Running<span class=o>]</span>
</span></span><span class=line><span class=cl>15.gif0 <span class=o>[</span>none<span class=o>]</span>
</span></span><span class=line><span class=cl>16.stf0 <span class=o>[</span>none<span class=o>]</span>
</span></span><span class=line><span class=cl>17.XHC0 <span class=o>[</span>none<span class=o>]</span>
</span></span><span class=line><span class=cl>18.XHC1 <span class=o>[</span>none<span class=o>]</span>
</span></span><span class=line><span class=cl>19.ap1 <span class=o>[</span>none<span class=o>]</span>
</span></span><span class=line><span class=cl>20.XHC20 <span class=o>[</span>none<span class=o>]</span>
</span></span><span class=line><span class=cl>21.VHC128 <span class=o>[</span>none<span class=o>]</span>
</span></span></code></pre></div><h2 id=监听适配器>监听适配器<a hidden class=anchor aria-hidden=true href=#监听适配器>#</a></h2><p>Listen on interface.</p><p>macOS 下监听适配器，必须使用 root 权限。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>sudo tcpdump -i en0
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>sudo tcpdump -i <span class=m>1</span>
</span></span></code></pre></div><h2 id=过滤监听适配器>过滤监听适配器<a hidden class=anchor aria-hidden=true href=#过滤监听适配器>#</a></h2><h3 id=过滤主机>过滤主机<a hidden class=anchor aria-hidden=true href=#过滤主机>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 抓取所有经过 en0，目的或源地址是 192.168.50.1 的网络数据</span>
</span></span><span class=line><span class=cl>sudo tcpdump -i en0 host 192.168.50.1
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 源地址</span>
</span></span><span class=line><span class=cl>sudo tcpdump -i en0 src host 192.168.50.1
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 目的地址</span>
</span></span><span class=line><span class=cl>sudo tcpdump -i en0 dst host 192.168.50.1
</span></span></code></pre></div><h3 id=过滤端口>过滤端口<a hidden class=anchor aria-hidden=true href=#过滤端口>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>sudo tcpdump -i en0 port <span class=m>8080</span>
</span></span></code></pre></div><h3 id=过滤网段>过滤网段<a hidden class=anchor aria-hidden=true href=#过滤网段>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>sudo tcpdump -i en0 net 192.168
</span></span></code></pre></div><h3 id=协议过滤>协议过滤<a hidden class=anchor aria-hidden=true href=#协议过滤>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>sudo tcpdump -i en0 tcp
</span></span><span class=line><span class=cl>sudo tcpdump -i en0 udp
</span></span><span class=line><span class=cl>sudo tcpdump -i en0 ip
</span></span><span class=line><span class=cl>sudo tcpdump -i en0 arp
</span></span><span class=line><span class=cl>sudo tcpdump -i en0 icmp
</span></span></code></pre></div><h3 id=使用表达式>使用表达式<a hidden class=anchor aria-hidden=true href=#使用表达式>#</a></h3><ul><li>与：&& 或 and</li><li>或：|| 或 or</li><li>非：! 或 not</li></ul><h2 id=选项>选项<a hidden class=anchor aria-hidden=true href=#选项>#</a></h2><p>tcpdump 默认只会截取前 96 字节的内容，要想截取所有的报文内容，可以使用 -s number， number 就是你要截取的报文字节数，如果是 0 的话，表示截取报文全部内容。</p><ul><li>-i any 监听所有的网卡</li><li>-n 不要解析域名，会优先暂时主机的名字</li><li>-nn 不展示主机名和端口名（比如 443 端口会被展示成 https）</li><li>-A 只使用 ascii 打印报文的全部数据，不要和 -X 一起使用。截取 http 请求的时候可以用 sudo tcpdump -nSA port 80</li><li>-X 同时用 hex 和 ascii 显示报文的内容</li><li>-XX 同 -X，但同时显示以太网头部</li><li>-S 显示绝对的序列号（sequence number），而不是相对编号</li><li>-s 截取的包字节长度，默认情况下 tcpdump 会展示 96 字节的长度，要获取完整的长度可以用 -s0 或者 -s1600。</li><li>-v, -vv, -vvv：显示更多的详细信息</li><li>-c number 截取 number 个报文，然后结束</li></ul><h2 id=flags>Flags<a hidden class=anchor aria-hidden=true href=#flags>#</a></h2><blockquote><p><a href=https://amits-notes.readthedocs.io/en/latest/networking/tcpdump.html#id2>tcpdump Flags | readthedocs</a></p></blockquote><table><thead><tr><th>TCP Flag</th><th>Flag</th><th>Meaning</th></tr></thead><tbody><tr><td>SYN</td><td>S</td><td>Syn packet, a session establishment request. 一个会话建立请求</td></tr><tr><td>ACK</td><td>A</td><td>Ack packet, acknowledge sender’s data. 确认发送方的数据</td></tr><tr><td>FIN</td><td>F</td><td>Finish flag, indication of termination. 终止的的标识</td></tr><tr><td>RESET</td><td>R</td><td>Reset, indication of immediate abort of conn. 指令立即中止</td></tr><tr><td>PUSH</td><td>P</td><td>Push, immediate push of data from sender. 从发送方立即推送数据</td></tr><tr><td>URGENT</td><td>U</td><td>Urgent, takes precedence over other data. 优先于其他数据</td></tr><tr><td>NONE</td><td>A dot .</td><td>Placeholder, usually used for ACK. 占位符，通常用于 ACK</td></tr></tbody></table><h2 id=实例>实例<a hidden class=anchor aria-hidden=true href=#实例>#</a></h2><p>抓取所有经过 eth1，目的地址是 192.168.1.254 或 192.168.1.200 端口是 80 的 TCP 数据：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>sudo tcpdump -i eth1 <span class=s1>&#39;((tcp) and (port 80) and ((dst host 192.168.1.254) or (dst host
</span></span></span><span class=line><span class=cl><span class=s1>192.168.1.200)))&#39;</span>
</span></span></code></pre></div><p>抓取所有经过 eth1，目的网络是 192.168，但目的主机不是 192.168.1.200 的 TCP 数据：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>sudo tcpdump -i eth1 <span class=s1>&#39;((tcp) and ((dst net 192.168) and (not dst host 192.168.1.200)))&#39;</span>
</span></span></code></pre></div><p>只抓 SYN 包：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>sudo tcpdump -i eth1 <span class=s1>&#39;tcp[tcpflags] = tcp-syn&#39;</span>
</span></span></code></pre></div><p>抓 SYN, ACK：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>sudo tcpdump -i eth1 <span class=s1>&#39;tcp[tcpflags] &amp; tcp-syn != 0 and tcp[tcpflags] &amp; tcp-ack != 0&#39;</span>
</span></span></code></pre></div><p>抓 DNS 请求数据：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>sudo tcpdump -i en0 udp dst port <span class=m>53</span>
</span></span></code></pre></div><p>-c 参数对于运维人员来说也比较常用，因为流量比较大的服务器，靠人工 CTRL+C 还是抓的太多，于是可以用 -c 参数指定抓多少个包：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>sudo <span class=nb>time</span> tcpdump -nn -i en0 <span class=s1>&#39;tcp[tcpflags] = tcp-syn&#39;</span> -c <span class=m>10000</span> &gt; /dev/null
</span></span></code></pre></div><p>实时抓取端口号 8000 的 GET 包，然后写入 GET.log：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>sudo tcpdump -i eth0 <span class=s1>&#39;((port 8000) and (tcp[(tcp[12]&gt;&gt;2):4]=0x47455420))&#39;</span> -nnAl -w /tmp/GET.log
</span></span></code></pre></div><h2 id=三次握手-四次挥手>三次握手 四次挥手<a hidden class=anchor aria-hidden=true href=#三次握手-四次挥手>#</a></h2><h3 id=tcp-连接建立三次握手>TCP 连接建立（三次握手）<a hidden class=anchor aria-hidden=true href=#tcp-连接建立三次握手>#</a></h3><p>客户端 A，服务器 B，初始序号 seq，确认号 ack。</p><p>初始状态：B 处于监听状态，A 处于打开状态。</p><ul><li>A -> B : seq = x （A 向 B 发送连接请求报文段，A 进入同步发送状态 SYN-SENT）</li><li>B -> A : ack = x + 1,seq = y （B 收到报文段，向 A 发送确认，B 进入同步收到状态 SYN-RCVD）</li><li>A -> B : ack = y + 1 （A 收到 B 的确认后，再次确认，A 进入连接状态 ESTABLISHED）</li></ul><p>连接后的状态：B 收到 A 的确认后，进入连接状态 ESTABLISHED。</p><p>为什么要握手要三次？防止失效的连接请求突然传到服务器端，让服务器端误认为要建立连接。</p><h3 id=tcp-连接释放四次挥手>TCP 连接释放（四次挥手）<a hidden class=anchor aria-hidden=true href=#tcp-连接释放四次挥手>#</a></h3><ul><li>A -> B : seq = u （A 发出连接释放报文段，进入终止等待 1 状态 FIN-WAIT-1）</li><li>B -> A : ack = u + 1,seq = v （B 收到报文段，发出确认，TCP 处于半关闭，B 还可向 A 发数据，B 进入关闭等待状态 WAIT）</li><li>B -> A : ack = u + 1,seq = w （B 重复发送确认号，进入最后确认状态 LAST-ACK）</li><li>A -> B : ack = w + 1,seq = u + 1 （A 发出确认，进入时间等待状态 TIME-WAIT）</li></ul><p>经过时间等待计时器设置的时间 2MSL 后，A 才进入 CLOSED 状态。</p><p>为什么 A 进入 TIME-WAIT 后必须等待 2MSL：</p><ul><li>保证 A 发送的最后一个 ACK 报文段能达到 B</li><li>防止失效的报文段出现在连接中</li></ul><h3 id=需要思考的问题>需要思考的问题<a hidden class=anchor aria-hidden=true href=#需要思考的问题>#</a></h3><p>问题 1: 请详细描述三次握手和四次挥手的过程
要求熟悉三次握手和四次挥手的机制，要求画出状态图。</p><p>问题 2: 四次挥手中 TIME_WAIT 状态存在的目的是什么?
这个问题是画出四次挥手状态图，会引申问你。不排除还会问为什么四次挥手是四次不是二次等问题。最好是把相关问题均掌握。</p><p>问题 3: TCP 是通过什么机制保障可靠性的?
从四个方面进行回答，ACK 确认机制、超时重传、滑动窗口以及流量控制，深入的话要求详细讲出流量控制的机制。</p><h3 id=抓包分析握手过程>抓包分析握手过程<a hidden class=anchor aria-hidden=true href=#抓包分析握手过程>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>sudo tcpdump -i en0 host www.qq.com and tcp -S -c <span class=m>50</span>
</span></span></code></pre></div><p><img alt="tcpdump 抓包分析握手过程" loading=lazy src=https://user-images.githubusercontent.com/9289792/87918568-3377e280-caa9-11ea-831a-95000e308ad8.png></p><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><ul><li><a href=https://www.jianshu.com/p/a57a5b0e58f0>macOS 下使用 tcpdump 抓包 | jianshu</a></li><li><a href=https://amits-notes.readthedocs.io/en/latest/networking/tcpdump.html>tcpdump | readthedocs</a></li><li><a href=https://www.cnblogs.com/fonxian/p/6565209.html>TCP 三次握手、四次挥手与 TcpDump 抓包分析 | 清泉白石</a></li></ul><p>&ndash; EOF &ndash;</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://zyf.im/tags/linux/>Linux</a></li></ul><nav class=paginav><a class=prev href=https://zyf.im/2020/08/07/deploy-swoft-framework/><span class=title>« Prev</span><br><span>PHP Swoft 框架环境配置</span>
</a><a class=next href=https://zyf.im/2020/05/26/config-laradock-phpstorm-xdubug/><span class=title>Next »</span><br><span>配置 Laradock PhpStorm Xdubug</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://zyf.im/>ZYF.IM BLOG</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>