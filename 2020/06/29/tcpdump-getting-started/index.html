<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>tcpdump 入门使用 | ZYF.IM BLOG</title><meta name=keywords content="devops"><meta name=description content="tcpdump 是类 Unix 系统上最常用、最轻量的网络抓包与分析工具。它直接调用 libpcap 库，在内核层抓取链路层的数据包，然后解析输出文本格式的“数据包头部摘要”，也可将原始数据保存为 pcap 文件供 Wireshark 等 GUI 工具进一步分析。
字多不看
sudo tcpdump host httpforever.com and tcp port 80 -A -nn
一举成名天下知
man tcpdump
常用参数速查

  
      
          参数
          作用
      
  
  
      
          -i 
          指定接口（不指定默认第一个可用接口）
      
      
          -nn
          不解析主机名和端口名（仅显示数字）
      
      
          -v/-vv/-vvv
          详细级别（-v/-vv/-vvv）
      
      
          -c 
          捕获指定数量后退出
      
      
          -s 
          抓取长度（0 = 全包；新版默认 262144 bytes）
      
      
          -w 
          将原始数据写入 pcap 文件
      
      
          -r 
          读取 pcap 文件离线解析
      
      
          -A / -X
          以 ASCII / 十六进制+ASCII 方式打印负载
      
  


-i any 监听所有的网卡
-A 只使用 ascii 打印报文的全部数据，不要和 -X 一起使用。截取 http 请求的时候可以用 sudo tcpdump -nSA port 80
-S 显示绝对的序列号（sequence number），而不是相对编号

过滤语法
tcpdump 采用 BPF 过滤语法（Berkeley Packet Filter"><meta name=author content="Me, LLM"><link rel=canonical href=https://zyf.im/2020/06/29/tcpdump-getting-started/><link crossorigin=anonymous href=/assets/css/stylesheet.63618a0fd0c7dd946ad6f368012c097fc6e5a8464cefd289c140dd28c01ec58d.css integrity="sha256-Y2GKD9DH3ZRq1vNoASwJf8blqEZM79KJwUDdKMAexY0=" rel="preload stylesheet" as=style><link rel=icon href=https://zyf.im/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zyf.im/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://zyf.im/favicon-32x32.png><link rel=apple-touch-icon href=https://zyf.im/apple-touch-icon.png><link rel=mask-icon href=https://zyf.im/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://zyf.im/2020/06/29/tcpdump-getting-started/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-6DVZ6E58DG"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-6DVZ6E58DG")}</script><meta property="og:url" content="https://zyf.im/2020/06/29/tcpdump-getting-started/"><meta property="og:site_name" content="ZYF.IM BLOG"><meta property="og:title" content="tcpdump 入门使用"><meta property="og:description" content="tcpdump 是类 Unix 系统上最常用、最轻量的网络抓包与分析工具。它直接调用 libpcap 库，在内核层抓取链路层的数据包，然后解析输出文本格式的“数据包头部摘要”，也可将原始数据保存为 pcap 文件供 Wireshark 等 GUI 工具进一步分析。
字多不看 sudo tcpdump host httpforever.com and tcp port 80 -A -nn 一举成名天下知 man tcpdump 常用参数速查 参数 作用 -i 指定接口（不指定默认第一个可用接口） -nn 不解析主机名和端口名（仅显示数字） -v/-vv/-vvv 详细级别（-v/-vv/-vvv） -c 捕获指定数量后退出 -s 抓取长度（0 = 全包；新版默认 262144 bytes） -w 将原始数据写入 pcap 文件 -r 读取 pcap 文件离线解析 -A / -X 以 ASCII / 十六进制+ASCII 方式打印负载 -i any 监听所有的网卡 -A 只使用 ascii 打印报文的全部数据，不要和 -X 一起使用。截取 http 请求的时候可以用 sudo tcpdump -nSA port 80 -S 显示绝对的序列号（sequence number），而不是相对编号 过滤语法 tcpdump 采用 BPF 过滤语法（Berkeley Packet Filter"><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-06-29T10:24:16+08:00"><meta property="article:modified_time" content="2020-06-29T10:24:16+08:00"><meta property="article:tag" content="Devops"><meta name=twitter:card content="summary"><meta name=twitter:title content="tcpdump 入门使用"><meta name=twitter:description content="tcpdump 是类 Unix 系统上最常用、最轻量的网络抓包与分析工具。它直接调用 libpcap 库，在内核层抓取链路层的数据包，然后解析输出文本格式的“数据包头部摘要”，也可将原始数据保存为 pcap 文件供 Wireshark 等 GUI 工具进一步分析。
字多不看
sudo tcpdump host httpforever.com and tcp port 80 -A -nn
一举成名天下知
man tcpdump
常用参数速查

  
      
          参数
          作用
      
  
  
      
          -i 
          指定接口（不指定默认第一个可用接口）
      
      
          -nn
          不解析主机名和端口名（仅显示数字）
      
      
          -v/-vv/-vvv
          详细级别（-v/-vv/-vvv）
      
      
          -c 
          捕获指定数量后退出
      
      
          -s 
          抓取长度（0 = 全包；新版默认 262144 bytes）
      
      
          -w 
          将原始数据写入 pcap 文件
      
      
          -r 
          读取 pcap 文件离线解析
      
      
          -A / -X
          以 ASCII / 十六进制+ASCII 方式打印负载
      
  


-i any 监听所有的网卡
-A 只使用 ascii 打印报文的全部数据，不要和 -X 一起使用。截取 http 请求的时候可以用 sudo tcpdump -nSA port 80
-S 显示绝对的序列号（sequence number），而不是相对编号

过滤语法
tcpdump 采用 BPF 过滤语法（Berkeley Packet Filter"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zyf.im/posts/"},{"@type":"ListItem","position":2,"name":"tcpdump 入门使用","item":"https://zyf.im/2020/06/29/tcpdump-getting-started/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"tcpdump 入门使用","name":"tcpdump 入门使用","description":"tcpdump 是类 Unix 系统上最常用、最轻量的网络抓包与分析工具。它直接调用 libpcap 库，在内核层抓取链路层的数据包，然后解析输出文本格式的“数据包头部摘要”，也可将原始数据保存为 pcap 文件供 Wireshark 等 GUI 工具进一步分析。\n字多不看 sudo tcpdump host httpforever.com and tcp port 80 -A -nn 一举成名天下知 man tcpdump 常用参数速查 参数 作用 -i 指定接口（不指定默认第一个可用接口） -nn 不解析主机名和端口名（仅显示数字） -v/-vv/-vvv 详细级别（-v/-vv/-vvv） -c 捕获指定数量后退出 -s 抓取长度（0 = 全包；新版默认 262144 bytes） -w 将原始数据写入 pcap 文件 -r 读取 pcap 文件离线解析 -A / -X 以 ASCII / 十六进制+ASCII 方式打印负载 -i any 监听所有的网卡 -A 只使用 ascii 打印报文的全部数据，不要和 -X 一起使用。截取 http 请求的时候可以用 sudo tcpdump -nSA port 80 -S 显示绝对的序列号（sequence number），而不是相对编号 过滤语法 tcpdump 采用 BPF 过滤语法（Berkeley Packet Filter\n","keywords":["devops"],"articleBody":"tcpdump 是类 Unix 系统上最常用、最轻量的网络抓包与分析工具。它直接调用 libpcap 库，在内核层抓取链路层的数据包，然后解析输出文本格式的“数据包头部摘要”，也可将原始数据保存为 pcap 文件供 Wireshark 等 GUI 工具进一步分析。\n字多不看 sudo tcpdump host httpforever.com and tcp port 80 -A -nn 一举成名天下知 man tcpdump 常用参数速查 参数 作用 -i 指定接口（不指定默认第一个可用接口） -nn 不解析主机名和端口名（仅显示数字） -v/-vv/-vvv 详细级别（-v/-vv/-vvv） -c 捕获指定数量后退出 -s 抓取长度（0 = 全包；新版默认 262144 bytes） -w 将原始数据写入 pcap 文件 -r 读取 pcap 文件离线解析 -A / -X 以 ASCII / 十六进制+ASCII 方式打印负载 -i any 监听所有的网卡 -A 只使用 ascii 打印报文的全部数据，不要和 -X 一起使用。截取 http 请求的时候可以用 sudo tcpdump -nSA port 80 -S 显示绝对的序列号（sequence number），而不是相对编号 过滤语法 tcpdump 采用 BPF 过滤语法（Berkeley Packet Filter\n[proto] [src|dst] [host|net|port] \u003c对象\u003e [逻辑运算] tcp and dst port 80 and src net 10.0.0.0/8 协议：ip, tcp, udp, icmp, arp, vlan, ip6, … 方向：src, dst, src or dst, src and dst 对象：host 10.0.0.1, net 192.168.0.0/16, port 443 逻辑：and, or, not, ( ) 与：\u0026\u0026 或 and 或：|| 或 or 非：! 或 not # 抓取所有经过 en0，目的或源地址是 192.168.50.1 的网络数据 sudo tcpdump -i en0 host 192.168.50.1 # 源地址 sudo tcpdump -i en0 src host 192.168.50.1 # 目的地址 sudo tcpdump -i en0 dst host 192.168.50.1 # 端口 sudo tcpdump -i en0 port 8080 ### 过滤网段 sudo tcpdump -i en0 net 192.168 ### 协议过滤 sudo tcpdump -i en0 tcp sudo tcpdump -i en0 udp sudo tcpdump -i en0 ip sudo tcpdump -i en0 arp sudo tcpdump -i en0 icmp 输出格式拆解 14:24:12.196582 IP 192.168.91.29.56930 \u003e 146.190.62.39.http: Flags [SEW], seq 193726297, win 65535, options [mss 1460,nop,wscale 6,nop,nop,TS val 2297696209 ecr 0,sackOK,eol], length 0 时间戳 协议层 (IP/ARP/…) 源地址.端口 \u003e 目标地址.端口 TCP 标志位 seq/ack/win 等字段 报文长度 可加 -tttt 打印完整日期；-e 显示以太网头（MAC 地址）。\n获取适配器列表 sudo tcpdump -D sudo tcpdump --list-interfaces 1.en0 [Up, Running] 2.p2p0 [Up, Running] 3.awdl0 [Up, Running] ... 监听适配器 Listen on interface.\nmacOS 下监听适配器，必须使用 root 权限。\nsudo tcpdump -i en0 sudo tcpdump -i 1 Flags tcpdump Flags | readthedocs\nTCP Flag Flag Meaning SYN S Syn packet, a session establishment request. 一个会话建立请求 ACK A Ack packet, acknowledge sender’s data. 确认发送方的数据 FIN F Finish flag, indication of termination. 终止的的标识 RESET R Reset, indication of immediate abort of conn. 指令立即中止 PUSH P Push, immediate push of data from sender. 从发送方立即推送数据 URGENT U Urgent, takes precedence over other data. 优先于其他数据 NONE A dot . Placeholder, usually used for ACK. 占位符，通常用于 ACK 实例 抓取所有经过 eth1，目的地址是 192.168.1.254 或 192.168.1.200 端口是 80 的 TCP 数据：\nsudo tcpdump -i eth1 '((tcp) and (port 80) and ((dst host 192.168.1.254) or (dst host 192.168.1.200)))' 抓取所有经过 eth1，目的网络是 192.168，但目的主机不是 192.168.1.200 的 TCP 数据：\nsudo tcpdump -i eth1 '((tcp) and ((dst net 192.168) and (not dst host 192.168.1.200)))' 只抓 SYN 包：\nsudo tcpdump -i eth1 'tcp[tcpflags] = tcp-syn' 抓 SYN, ACK：\nsudo tcpdump -i eth1 'tcp[tcpflags] \u0026 tcp-syn != 0 and tcp[tcpflags] \u0026 tcp-ack != 0' 抓 DNS 请求数据：\nsudo tcpdump -i en0 udp dst port 53 -c 参数对于运维人员来说也比较常用，因为流量比较大的服务器，靠人工 CTRL+C 还是抓的太多，于是可以用 -c 参数指定抓多少个包：\nsudo time tcpdump -nn -i en0 'tcp[tcpflags] = tcp-syn' -c 10000 \u003e /dev/null 实时抓取端口号 8000 的 GET 包，然后写入 GET.log：\nsudo tcpdump -i eth0 '((port 8000) and (tcp[(tcp[12]\u003e\u003e2):4]=0x47455420))' -nnAl -w /tmp/GET.log 三次握手 四次挥手 TCP 连接建立（三次握手） 客户端 A，服务器 B，初始序号 seq，确认号 ack。\n初始状态：B 处于监听状态，A 处于打开状态。\nA -\u003e B : seq = x （A 向 B 发送连接请求报文段，A 进入同步发送状态 SYN-SENT） B -\u003e A : ack = x + 1,seq = y （B 收到报文段，向 A 发送确认，B 进入同步收到状态 SYN-RCVD） A -\u003e B : ack = y + 1 （A 收到 B 的确认后，再次确认，A 进入连接状态 ESTABLISHED） 连接后的状态：B 收到 A 的确认后，进入连接状态 ESTABLISHED。\n为什么要握手要三次？防止失效的连接请求突然传到服务器端，让服务器端误认为要建立连接。\nTCP 连接释放（四次挥手） A -\u003e B : seq = u （A 发出连接释放报文段，进入终止等待 1 状态 FIN-WAIT-1） B -\u003e A : ack = u + 1,seq = v （B 收到报文段，发出确认，TCP 处于半关闭，B 还可向 A 发数据，B 进入关闭等待状态 WAIT） B -\u003e A : ack = u + 1,seq = w （B 重复发送确认号，进入最后确认状态 LAST-ACK） A -\u003e B : ack = w + 1,seq = u + 1 （A 发出确认，进入时间等待状态 TIME-WAIT） 经过时间等待计时器设置的时间 2MSL 后，A 才进入 CLOSED 状态。\n为什么 A 进入 TIME-WAIT 后必须等待 2MSL：\n保证 A 发送的最后一个 ACK 报文段能达到 B 防止失效的报文段出现在连接中 需要思考的问题 问题 1: 请详细描述三次握手和四次挥手的过程 要求熟悉三次握手和四次挥手的机制，要求画出状态图。\n问题 2: 四次挥手中 TIME_WAIT 状态存在的目的是什么? 这个问题是画出四次挥手状态图，会引申问你。不排除还会问为什么四次挥手是四次不是二次等问题。最好是把相关问题均掌握。\n问题 3: TCP 是通过什么机制保障可靠性的? 从四个方面进行回答，ACK 确认机制、超时重传、滑动窗口以及流量控制，深入的话要求详细讲出流量控制的机制。\n抓包分析握手过程 sudo tcpdump -i en0 host www.qq.com and tcp -S -c 50 References macOS 下使用 tcpdump 抓包 | jianshu tcpdump | readthedocs TCP 三次握手、四次挥手与 TcpDump 抓包分析 | 清泉白石 – EOF –\n","wordCount":"668","inLanguage":"en","datePublished":"2020-06-29T10:24:16+08:00","dateModified":"2020-06-29T10:24:16+08:00","author":[{"@type":"Person","name":"Me"},{"@type":"Person","name":"LLM"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://zyf.im/2020/06/29/tcpdump-getting-started/"},"publisher":{"@type":"Organization","name":"ZYF.IM BLOG","logo":{"@type":"ImageObject","url":"https://zyf.im/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://zyf.im/ accesskey=h title="ZYF.IM (Alt + H)"><img src=https://zyf.im/apple-touch-icon.png alt aria-label=logo height=35>ZYF.IM</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://zyf.im/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://zyf.im/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://zyf.im/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://zyf.im/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://zyf.im/>Home</a>&nbsp;»&nbsp;<a href=https://zyf.im/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">tcpdump 入门使用</h1><div class=post-meta><span title='2020-06-29 10:24:16 +0800 CST'>June 29, 2020</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;668 words&nbsp;·&nbsp;Me, LLM</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#字多不看>字多不看</a></li><li><a href=#一举成名天下知>一举成名天下知</a><ul><li><a href=#常用参数速查>常用参数速查</a></li><li><a href=#过滤语法>过滤语法</a></li><li><a href=#输出格式拆解>输出格式拆解</a></li></ul></li><li><a href=#获取适配器列表>获取适配器列表</a></li><li><a href=#监听适配器>监听适配器</a></li><li><a href=#flags>Flags</a></li><li><a href=#实例>实例</a></li><li><a href=#三次握手-四次挥手>三次握手 四次挥手</a><ul><li><a href=#tcp-连接建立三次握手>TCP 连接建立（三次握手）</a></li><li><a href=#tcp-连接释放四次挥手>TCP 连接释放（四次挥手）</a></li><li><a href=#需要思考的问题>需要思考的问题</a></li><li><a href=#抓包分析握手过程>抓包分析握手过程</a></li></ul></li><li><a href=#references>References</a></li></ul></nav></div></details></div><div class=post-content><p>tcpdump 是类 Unix 系统上最常用、最轻量的网络抓包与分析工具。它直接调用 libpcap 库，在内核层抓取链路层的数据包，然后解析输出文本格式的“数据包头部摘要”，也可将原始数据保存为 pcap 文件供 Wireshark 等 GUI 工具进一步分析。</p><h2 id=字多不看>字多不看<a hidden class=anchor aria-hidden=true href=#字多不看>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>sudo tcpdump host httpforever.com and tcp port <span class=m>80</span> -A -nn
</span></span></code></pre></div><h2 id=一举成名天下知>一举成名天下知<a hidden class=anchor aria-hidden=true href=#一举成名天下知>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>man tcpdump
</span></span></code></pre></div><h3 id=常用参数速查>常用参数速查<a hidden class=anchor aria-hidden=true href=#常用参数速查>#</a></h3><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-i <iface></td><td>指定接口（不指定默认第一个可用接口）</td></tr><tr><td>-nn</td><td>不解析主机名和端口名（仅显示数字）</td></tr><tr><td>-v/-vv/-vvv</td><td>详细级别（-v/-vv/-vvv）</td></tr><tr><td>-c <num></td><td>捕获指定数量后退出</td></tr><tr><td>-s <len></td><td>抓取长度（0 = 全包；新版默认 262144 bytes）</td></tr><tr><td>-w <file></td><td>将原始数据写入 pcap 文件</td></tr><tr><td>-r <file></td><td>读取 pcap 文件离线解析</td></tr><tr><td>-A / -X</td><td>以 ASCII / 十六进制+ASCII 方式打印负载</td></tr></tbody></table><ul><li>-i any 监听所有的网卡</li><li>-A 只使用 ascii 打印报文的全部数据，不要和 -X 一起使用。截取 http 请求的时候可以用 <code>sudo tcpdump -nSA port 80</code></li><li>-S 显示绝对的序列号（sequence number），而不是相对编号</li></ul><h3 id=过滤语法>过滤语法<a hidden class=anchor aria-hidden=true href=#过滤语法>#</a></h3><p>tcpdump 采用 BPF 过滤语法（Berkeley Packet Filter</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=o>[</span>proto<span class=o>]</span> <span class=o>[</span>src<span class=p>|</span>dst<span class=o>]</span> <span class=o>[</span>host<span class=p>|</span>net<span class=p>|</span>port<span class=o>]</span> &lt;对象&gt; <span class=o>[</span>逻辑运算<span class=o>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>tcp and dst port <span class=m>80</span> and src net 10.0.0.0/8
</span></span></code></pre></div><ol><li>协议：ip, tcp, udp, icmp, arp, vlan, ip6, &mldr;</li><li>方向：src, dst, src or dst, src and dst</li><li>对象：host 10.0.0.1, net 192.168.0.0/16, port 443</li><li>逻辑：and, or, not, ( )<ul><li>与：&& 或 and</li><li>或：|| 或 or</li><li>非：! 或 not</li></ul></li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 抓取所有经过 en0，目的或源地址是 192.168.50.1 的网络数据</span>
</span></span><span class=line><span class=cl>sudo tcpdump -i en0 host 192.168.50.1
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 源地址</span>
</span></span><span class=line><span class=cl>sudo tcpdump -i en0 src host 192.168.50.1
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 目的地址</span>
</span></span><span class=line><span class=cl>sudo tcpdump -i en0 dst host 192.168.50.1
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 端口</span>
</span></span><span class=line><span class=cl>sudo tcpdump -i en0 port <span class=m>8080</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>### 过滤网段</span>
</span></span><span class=line><span class=cl>sudo tcpdump -i en0 net 192.168
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>### 协议过滤</span>
</span></span><span class=line><span class=cl>sudo tcpdump -i en0 tcp
</span></span><span class=line><span class=cl>sudo tcpdump -i en0 udp
</span></span><span class=line><span class=cl>sudo tcpdump -i en0 ip
</span></span><span class=line><span class=cl>sudo tcpdump -i en0 arp
</span></span><span class=line><span class=cl>sudo tcpdump -i en0 icmp
</span></span></code></pre></div><h3 id=输出格式拆解>输出格式拆解<a hidden class=anchor aria-hidden=true href=#输出格式拆解>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>14:24:12.196582 IP 192.168.91.29.56930 &gt; 146.190.62.39.http: Flags <span class=o>[</span>SEW<span class=o>]</span>, seq 193726297, win 65535, options <span class=o>[</span>mss 1460,nop,wscale 6,nop,nop,TS val <span class=m>2297696209</span> ecr 0,sackOK,eol<span class=o>]</span>, length <span class=m>0</span>
</span></span></code></pre></div><ol><li>时间戳</li><li>协议层 (IP/ARP/&mldr;)</li><li>源地址.端口 > 目标地址.端口</li><li>TCP 标志位</li><li>seq/ack/win 等字段</li><li>报文长度</li></ol><p>可加 -tttt 打印完整日期；-e 显示以太网头（MAC 地址）。</p><h2 id=获取适配器列表>获取适配器列表<a hidden class=anchor aria-hidden=true href=#获取适配器列表>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>sudo tcpdump -D
</span></span><span class=line><span class=cl>sudo tcpdump --list-interfaces
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>1.en0 <span class=o>[</span>Up, Running<span class=o>]</span>
</span></span><span class=line><span class=cl>2.p2p0 <span class=o>[</span>Up, Running<span class=o>]</span>
</span></span><span class=line><span class=cl>3.awdl0 <span class=o>[</span>Up, Running<span class=o>]</span>
</span></span><span class=line><span class=cl>...
</span></span></code></pre></div><h2 id=监听适配器>监听适配器<a hidden class=anchor aria-hidden=true href=#监听适配器>#</a></h2><p>Listen on interface.</p><p>macOS 下监听适配器，必须使用 root 权限。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>sudo tcpdump -i en0
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>sudo tcpdump -i <span class=m>1</span>
</span></span></code></pre></div><h2 id=flags>Flags<a hidden class=anchor aria-hidden=true href=#flags>#</a></h2><blockquote><p><a href=https://amits-notes.readthedocs.io/en/latest/networking/tcpdump.html#id2>tcpdump Flags | readthedocs</a></p></blockquote><table><thead><tr><th>TCP Flag</th><th>Flag</th><th>Meaning</th></tr></thead><tbody><tr><td>SYN</td><td>S</td><td>Syn packet, a session establishment request. 一个会话建立请求</td></tr><tr><td>ACK</td><td>A</td><td>Ack packet, acknowledge sender’s data. 确认发送方的数据</td></tr><tr><td>FIN</td><td>F</td><td>Finish flag, indication of termination. 终止的的标识</td></tr><tr><td>RESET</td><td>R</td><td>Reset, indication of immediate abort of conn. 指令立即中止</td></tr><tr><td>PUSH</td><td>P</td><td>Push, immediate push of data from sender. 从发送方立即推送数据</td></tr><tr><td>URGENT</td><td>U</td><td>Urgent, takes precedence over other data. 优先于其他数据</td></tr><tr><td>NONE</td><td>A dot .</td><td>Placeholder, usually used for ACK. 占位符，通常用于 ACK</td></tr></tbody></table><h2 id=实例>实例<a hidden class=anchor aria-hidden=true href=#实例>#</a></h2><p>抓取所有经过 eth1，目的地址是 192.168.1.254 或 192.168.1.200 端口是 80 的 TCP 数据：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>sudo tcpdump -i eth1 <span class=s1>&#39;((tcp) and (port 80) and ((dst host 192.168.1.254) or (dst host
</span></span></span><span class=line><span class=cl><span class=s1>192.168.1.200)))&#39;</span>
</span></span></code></pre></div><p>抓取所有经过 eth1，目的网络是 192.168，但目的主机不是 192.168.1.200 的 TCP 数据：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>sudo tcpdump -i eth1 <span class=s1>&#39;((tcp) and ((dst net 192.168) and (not dst host 192.168.1.200)))&#39;</span>
</span></span></code></pre></div><p>只抓 SYN 包：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>sudo tcpdump -i eth1 <span class=s1>&#39;tcp[tcpflags] = tcp-syn&#39;</span>
</span></span></code></pre></div><p>抓 SYN, ACK：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>sudo tcpdump -i eth1 <span class=s1>&#39;tcp[tcpflags] &amp; tcp-syn != 0 and tcp[tcpflags] &amp; tcp-ack != 0&#39;</span>
</span></span></code></pre></div><p>抓 DNS 请求数据：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>sudo tcpdump -i en0 udp dst port <span class=m>53</span>
</span></span></code></pre></div><p>-c 参数对于运维人员来说也比较常用，因为流量比较大的服务器，靠人工 CTRL+C 还是抓的太多，于是可以用 -c 参数指定抓多少个包：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>sudo <span class=nb>time</span> tcpdump -nn -i en0 <span class=s1>&#39;tcp[tcpflags] = tcp-syn&#39;</span> -c <span class=m>10000</span> &gt; /dev/null
</span></span></code></pre></div><p>实时抓取端口号 8000 的 GET 包，然后写入 GET.log：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>sudo tcpdump -i eth0 <span class=s1>&#39;((port 8000) and (tcp[(tcp[12]&gt;&gt;2):4]=0x47455420))&#39;</span> -nnAl -w /tmp/GET.log
</span></span></code></pre></div><h2 id=三次握手-四次挥手>三次握手 四次挥手<a hidden class=anchor aria-hidden=true href=#三次握手-四次挥手>#</a></h2><h3 id=tcp-连接建立三次握手>TCP 连接建立（三次握手）<a hidden class=anchor aria-hidden=true href=#tcp-连接建立三次握手>#</a></h3><p>客户端 A，服务器 B，初始序号 seq，确认号 ack。</p><p>初始状态：B 处于监听状态，A 处于打开状态。</p><ul><li>A -> B : seq = x （A 向 B 发送连接请求报文段，A 进入同步发送状态 SYN-SENT）</li><li>B -> A : ack = x + 1,seq = y （B 收到报文段，向 A 发送确认，B 进入同步收到状态 SYN-RCVD）</li><li>A -> B : ack = y + 1 （A 收到 B 的确认后，再次确认，A 进入连接状态 ESTABLISHED）</li></ul><p>连接后的状态：B 收到 A 的确认后，进入连接状态 ESTABLISHED。</p><p>为什么要握手要三次？防止失效的连接请求突然传到服务器端，让服务器端误认为要建立连接。</p><h3 id=tcp-连接释放四次挥手>TCP 连接释放（四次挥手）<a hidden class=anchor aria-hidden=true href=#tcp-连接释放四次挥手>#</a></h3><ul><li>A -> B : seq = u （A 发出连接释放报文段，进入终止等待 1 状态 FIN-WAIT-1）</li><li>B -> A : ack = u + 1,seq = v （B 收到报文段，发出确认，TCP 处于半关闭，B 还可向 A 发数据，B 进入关闭等待状态 WAIT）</li><li>B -> A : ack = u + 1,seq = w （B 重复发送确认号，进入最后确认状态 LAST-ACK）</li><li>A -> B : ack = w + 1,seq = u + 1 （A 发出确认，进入时间等待状态 TIME-WAIT）</li></ul><p>经过时间等待计时器设置的时间 2MSL 后，A 才进入 CLOSED 状态。</p><p>为什么 A 进入 TIME-WAIT 后必须等待 2MSL：</p><ul><li>保证 A 发送的最后一个 ACK 报文段能达到 B</li><li>防止失效的报文段出现在连接中</li></ul><h3 id=需要思考的问题>需要思考的问题<a hidden class=anchor aria-hidden=true href=#需要思考的问题>#</a></h3><p>问题 1: 请详细描述三次握手和四次挥手的过程
要求熟悉三次握手和四次挥手的机制，要求画出状态图。</p><p>问题 2: 四次挥手中 TIME_WAIT 状态存在的目的是什么?
这个问题是画出四次挥手状态图，会引申问你。不排除还会问为什么四次挥手是四次不是二次等问题。最好是把相关问题均掌握。</p><p>问题 3: TCP 是通过什么机制保障可靠性的?
从四个方面进行回答，ACK 确认机制、超时重传、滑动窗口以及流量控制，深入的话要求详细讲出流量控制的机制。</p><h3 id=抓包分析握手过程>抓包分析握手过程<a hidden class=anchor aria-hidden=true href=#抓包分析握手过程>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>sudo tcpdump -i en0 host www.qq.com and tcp -S -c <span class=m>50</span>
</span></span></code></pre></div><p><img alt="tcpdump 抓包分析握手过程" loading=lazy src=https://user-images.githubusercontent.com/9289792/87918568-3377e280-caa9-11ea-831a-95000e308ad8.png></p><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><ul><li><a href=https://www.jianshu.com/p/a57a5b0e58f0>macOS 下使用 tcpdump 抓包 | jianshu</a></li><li><a href=https://amits-notes.readthedocs.io/en/latest/networking/tcpdump.html>tcpdump | readthedocs</a></li><li><a href=https://www.cnblogs.com/fonxian/p/6565209.html>TCP 三次握手、四次挥手与 TcpDump 抓包分析 | 清泉白石</a></li></ul><p>&ndash; EOF &ndash;</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://zyf.im/tags/devops/>Devops</a></li></ul><nav class=paginav><a class=prev href=https://zyf.im/2020/08/07/deploy-swoft-framework/><span class=title>« Prev</span><br><span>PHP Swoft 框架环境配置</span>
</a><a class=next href=https://zyf.im/2020/05/26/config-laradock-phpstorm-xdubug/><span class=title>Next »</span><br><span>配置 Laradock PhpStorm Xdubug</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://zyf.im/>ZYF.IM BLOG</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>