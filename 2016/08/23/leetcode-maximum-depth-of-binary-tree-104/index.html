<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>LeetCode Maximum Depth of Binary Tree 104 | ZYF.IM BLOG</title>
<meta name=keywords content="leetcode"><meta name=description content="104. Maximum Depth of Binary Tree
  Given a binary tree, find its maximum depth.
  The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.

自己的解法
自己想到应该用递归、为空的返回 0，不为空的返回 1，递归累加；但是有两个点这么判断呢？其实很容易取两数字的 MAX
public int maxDepth(TreeNode root) {
     if (root == null) {
        return 0;
    }
    return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));
}
参考：
104 Maximum Depth of Binary Tree | Data Structure and algorithm analysis"><meta name=author content="Me"><link rel=canonical href=https://zyf.im/2016/08/23/leetcode-maximum-depth-of-binary-tree-104/><link crossorigin=anonymous href=/assets/css/stylesheet.4997c86cdc3165a43745858554a5b14aaf4d3769db9f06a36b0c69ef98eb2927.css integrity="sha256-SZfIbNwxZaQ3RYWFVKWxSq9NN2nbnwajawxp75jrKSc=" rel="preload stylesheet" as=style><link rel=icon href=https://zyf.im/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zyf.im/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://zyf.im/favicon-32x32.png><link rel=apple-touch-icon href=https://zyf.im/apple-touch-icon.png><link rel=mask-icon href=https://zyf.im/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://zyf.im/2016/08/23/leetcode-maximum-depth-of-binary-tree-104/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-6DVZ6E58DG"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-6DVZ6E58DG")}</script><meta property="og:url" content="https://zyf.im/2016/08/23/leetcode-maximum-depth-of-binary-tree-104/"><meta property="og:site_name" content="ZYF.IM BLOG"><meta property="og:title" content="LeetCode Maximum Depth of Binary Tree 104"><meta property="og:description" content="104. Maximum Depth of Binary Tree Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.
自己的解法 自己想到应该用递归、为空的返回 0，不为空的返回 1，递归累加；但是有两个点这么判断呢？其实很容易取两数字的 MAX
public int maxDepth(TreeNode root) { if (root == null) { return 0; } return 1 + Math.max(maxDepth(root.left), maxDepth(root.right)); } 参考： 104 Maximum Depth of Binary Tree | Data Structure and algorithm analysis"><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2016-08-23T11:30:00+00:00"><meta property="article:modified_time" content="2016-08-23T11:30:00+00:00"><meta property="article:tag" content="Leetcode"><meta name=twitter:card content="summary"><meta name=twitter:title content="LeetCode Maximum Depth of Binary Tree 104"><meta name=twitter:description content="104. Maximum Depth of Binary Tree
  Given a binary tree, find its maximum depth.
  The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.

自己的解法
自己想到应该用递归、为空的返回 0，不为空的返回 1，递归累加；但是有两个点这么判断呢？其实很容易取两数字的 MAX
public int maxDepth(TreeNode root) {
     if (root == null) {
        return 0;
    }
    return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));
}
参考：
104 Maximum Depth of Binary Tree | Data Structure and algorithm analysis"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zyf.im/posts/"},{"@type":"ListItem","position":2,"name":"LeetCode Maximum Depth of Binary Tree 104","item":"https://zyf.im/2016/08/23/leetcode-maximum-depth-of-binary-tree-104/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"LeetCode Maximum Depth of Binary Tree 104","name":"LeetCode Maximum Depth of Binary Tree 104","description":"104. Maximum Depth of Binary Tree Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\n自己的解法 自己想到应该用递归、为空的返回 0，不为空的返回 1，递归累加；但是有两个点这么判断呢？其实很容易取两数字的 MAX\npublic int maxDepth(TreeNode root) { if (root == null) { return 0; } return 1 + Math.max(maxDepth(root.left), maxDepth(root.right)); } 参考： 104 Maximum Depth of Binary Tree | Data Structure and algorithm analysis\n","keywords":["leetcode"],"articleBody":"104. Maximum Depth of Binary Tree Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\n自己的解法 自己想到应该用递归、为空的返回 0，不为空的返回 1，递归累加；但是有两个点这么判断呢？其实很容易取两数字的 MAX\npublic int maxDepth(TreeNode root) { if (root == null) { return 0; } return 1 + Math.max(maxDepth(root.left), maxDepth(root.right)); } 参考： 104 Maximum Depth of Binary Tree | Data Structure and algorithm analysis\n","wordCount":"73","inLanguage":"en","datePublished":"2016-08-23T11:30:00Z","dateModified":"2016-08-23T11:30:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zyf.im/2016/08/23/leetcode-maximum-depth-of-binary-tree-104/"},"publisher":{"@type":"Organization","name":"ZYF.IM BLOG","logo":{"@type":"ImageObject","url":"https://zyf.im/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://zyf.im/ accesskey=h title="ZYF.IM (Alt + H)"><img src=https://zyf.im/apple-touch-icon.png alt aria-label=logo height=35>ZYF.IM</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://zyf.im/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://zyf.im/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://zyf.im/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://zyf.im/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://zyf.im/>Home</a>&nbsp;»&nbsp;<a href=https://zyf.im/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">LeetCode Maximum Depth of Binary Tree 104</h1><div class=post-meta><span title='2016-08-23 11:30:00 +0000 UTC'>August 23, 2016</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;73 words&nbsp;·&nbsp;Me</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><ul><li><a href=#自己的解法>自己的解法</a></li></ul></li></ul></nav></div></details></div><div class=post-content><p><a href=https://leetcode.com/problems/maximum-depth-of-binary-tree/>104. Maximum Depth of Binary Tree</a>
  Given a binary tree, find its maximum depth.
  The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p><h3 id=自己的解法>自己的解法<a hidden class=anchor aria-hidden=true href=#自己的解法>#</a></h3><p>自己想到应该用递归、为空的返回 0，不为空的返回 1，递归累加；但是有两个点这么判断呢？其实很容易取两数字的 MAX</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=nf>maxDepth</span><span class=p>(</span><span class=n>TreeNode</span><span class=w> </span><span class=n>root</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>     </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>root</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=n>1</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>Math</span><span class=p>.</span><span class=na>max</span><span class=p>(</span><span class=n>maxDepth</span><span class=p>(</span><span class=n>root</span><span class=p>.</span><span class=na>left</span><span class=p>),</span><span class=w> </span><span class=n>maxDepth</span><span class=p>(</span><span class=n>root</span><span class=p>.</span><span class=na>right</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>参考：
<a href=https://jingjingshao.gitbooks.io/data-structure-and-algorithm-analysis/content/Tree/104_maximum_depth_of_binary_tree.html>104 Maximum Depth of Binary Tree | Data Structure and algorithm analysis</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://zyf.im/tags/leetcode/>Leetcode</a></li></ul><nav class=paginav><a class=prev href=https://zyf.im/2016/08/23/leetcode-first-unique-character-in-a-string-387/><span class=title>« Prev</span><br><span>LeetCode First Unique Character in a String 387</span>
</a><a class=next href=https://zyf.im/2016/08/22/being-alive-is-a-gift-reading-notes/><span class=title>Next »</span><br><span>【此生为完成】随笔</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://zyf.im/>ZYF.IM BLOG</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>