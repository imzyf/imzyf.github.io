<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>全力以赴</title>
  
  <subtitle>Yifans_Z&#39;s Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zyf.im/"/>
  <updated>2022-09-06T10:53:58.000Z</updated>
  <id>https://zyf.im/</id>
  
  <author>
    <name>Yifans_Z</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《MySQL 实战 45 讲》笔记 01</title>
    <link href="https://zyf.im/2022/08/14/mysql-course-45-reading-notes-01/"/>
    <id>https://zyf.im/2022/08/14/mysql-course-45-reading-notes-01/</id>
    <published>2022-08-14T07:53:16.000Z</published>
    <updated>2022-09-06T10:53:58.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="http://gk.link/a/11AmM" target="_blank" rel="noopener">MySQL 实战 45 讲 | 林晓斌</a></p></blockquote><h2 id="01-基础架构：一条-SQL-查询语句是如何执行的？"><a href="#01-基础架构：一条-SQL-查询语句是如何执行的？" class="headerlink" title="01 | 基础架构：一条 SQL 查询语句是如何执行的？"></a>01 | 基础架构：一条 SQL 查询语句是如何执行的？</h2><p><img alt="image" src="https://user-images.githubusercontent.com/9289792/184530380-826038a0-335a-45f7-a56e-cff7b336b4a4.png" style="width:420px"></p><p>连接器：跟客户端建立连接、获取权限、维持和管理连接。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">PROCESSLIST</span>;</span><br><span class="line"></span><br><span class="line">137462239  db  10.135.4.7:41261  db  Query  0  starting  <span class="keyword">show</span> <span class="keyword">processlist</span></span><br><span class="line"><span class="comment">-- 一个空闲连接</span></span><br><span class="line"><span class="number">137462293</span>  db  <span class="number">10.130</span><span class="number">.128</span><span class="number">.1</span>:<span class="number">47174</span>  db  <span class="keyword">Sleep</span>  <span class="number">24</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 客户端如果太长时间没动静，连接器就会自动将它断开</span></span><br><span class="line"><span class="keyword">select</span> @@wait_timeout;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'wait_timeout'</span>;</span><br><span class="line"><span class="comment">-- 28800 8h</span></span><br></pre></td></tr></table></figure><p>通过执行 <code>mysql_reset_connection</code> 来重新初始化连接资源，这是个接口函数，不是一个 SQL 语句。</p><p>查询缓存：不建议使用。在一个表上有更新的时候，跟这个表有关的查询缓存都会失效。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> @@query_cache_type;</span><br><span class="line"><span class="comment">-- OFF</span></span><br></pre></td></tr></table></figure><ul><li><a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_query_cache_type" target="_blank" rel="noopener">sysvar_query_cache_type | mysql</a></li></ul><p>分析器：词法分析、语法分析。进行分词和验证语法规则。解析器和预处理器。</p><ul><li>解析器处理语法和解析查询，生成一课对应的解析树。</li><li>预处理器进一步检查解析树的合法。比如: 数据表和数据列是否存在，别名是否有歧义等。如果通过则生成新的解析树，再提交给优化器。</li></ul><p>优化器：决定使用哪个索引，决定各个表的连接顺序。</p><p>执行器：有没有执行查询的权限，操作引擎，返回结果。执行器调用的次数（rows_examined）与引擎总共扫描行数可能是不等的，后文有例子。</p><p>读写、存取数据在 engine 引擎层，连接、鉴权、计算在 server 服务层。</p><p>连接的长短是由客户端来决定的，MySQL 服务端不会主动断开连接，除非到了 waiting_timeout 所设置的时间。</p><p>查询一个没用 k 列的表 <code>1054 - Unknown column &#39;k&#39; in &#39;field list&#39;</code> 是在哪阶段报错的？</p><ul><li>答案是：分析器。分析器在词法分析阶段，需要知道 SQL 中的每个字段代表什么意思，所以在这个阶段就可以判断表中存不存在 k 这一列。</li><li>不是执行器的原因：有人说在执行器时才打开表获取数据，但是表的字段不是数据，是事先定义好的，所以可以直接读取的，不需要打开表。</li></ul><h2 id="02-日志系统：一条-SQL-更新语句是如何执行的？"><a href="#02-日志系统：一条-SQL-更新语句是如何执行的？" class="headerlink" title="02 | 日志系统：一条 SQL 更新语句是如何执行的？"></a>02 | 日志系统：一条 SQL 更新语句是如何执行的？</h2><p>WAL 的全称是 Write-Ahead Logging，先写日志，再写磁盘。</p><ol><li>redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用</li><li>redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1”。</li><li>redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</li></ol><ul><li>物理：InnoDB 存储引擎提供接口给执行器调用（操作数据），数据库的数据是存在磁盘上的（或者说硬盘上），那么 redo log 记录存储引擎修改硬盘上的数据的操作就叫做物理操作；物理日志就只有“我”自己能用，别人没有共享我的“物理格式”。</li><li>逻辑：binlog 归档日志，有两种模式 1 statement 记录 SQL；2 row 格式记录两条数据，数据修改前的样子，数据修改后的样子。记录的是一种逻辑上的变化 。逻辑日志可以给别的数据库，别的引擎使用，已经大家都讲得通这个“逻辑”。</li></ul><p><img alt="image" src="https://user-images.githubusercontent.com/9289792/184621469-ce7bea97-685a-421f-a582-0d571badc226.png" style="width:420px"></p><p>把 binlog 夹在 redo log 中间，就是为了保证如果 redo 提交前的任何失败，都会带来回滚，binlog 的写入也应该不会成功，只有这样，才能保证两个一致。</p><ul><li>如果提交了 binlog，提交事务接口崩溃了，恢复时 redo log 有日志记录，binlog 有日志记录，一致，直接自动提交事务，事务完成确认数据修改成功。</li><li>如果提交 binlog 前就崩了，redo log 是 prepare 阶段，binlog 没有记录不一致，事务回滚，事务执行失败。</li></ul><p>redo log 负责事务、crash-safe；binlog 负责归档恢复。redo log 是物理的，binlog 是逻辑的。</p><p>redo log 是顺序写，数据文件是随机写。</p><p>MySQL 的记录是以“页”为单位存取的，默认大小 16K。也就是说，你要访问磁盘中一个记录，不会只读这个记录，而会把它所在的 16K 数据一起读入内存。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 每个 binlog 文件的大小</span></span><br><span class="line"><span class="keyword">SELECT</span> @@max_binlog_size / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line"><span class="comment">-- 256.00000000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 一页数据大小</span></span><br><span class="line"><span class="keyword">SELECT</span> @@innodb_page_size / <span class="number">1024</span>;</span><br><span class="line"><span class="comment">-- 16.0000</span></span><br></pre></td></tr></table></figure><p>redo log 和 binlog 都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 保证 crash-safe 能力；每次事务的 redo log 都直接持久化到磁盘</span></span><br><span class="line"><span class="keyword">select</span> @@innodb_flush_log_at_trx_commit;</span><br><span class="line"><span class="comment">-- 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 每次事务的 binlog 都持久化到磁盘</span></span><br><span class="line"><span class="keyword">select</span> @@sync_binlog;</span><br><span class="line"><span class="comment">-- 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> @@binlog_format;</span><br><span class="line"><span class="comment">-- STATEMENT 是记 SQL 语句，但是有风险比如时间函数</span></span><br><span class="line"><span class="comment">-- ROW 记录行的内容，记两条，更新前和更新后都有</span></span><br></pre></td></tr></table></figure><ul><li><a href="https://segmentfault.com/a/1190000042041728" target="_blank" rel="noopener">彻底搞懂三大 MySQL 日志，Redo Log、Undo Log、Bin Log</a></li><li><a href="https://blog.51cto.com/u_3664660/3212550" target="_blank" rel="noopener">彻底搞懂 mysql 日志系统 binlog,redolog,undolog</a></li></ul><h2 id="03-事务隔离：为什么你改了我还看不见？"><a href="#03-事务隔离：为什么你改了我还看不见？" class="headerlink" title="03 | 事务隔离：为什么你改了我还看不见？"></a>03 | 事务隔离：为什么你改了我还看不见？</h2><p>脏读（dirty read）读到其他事务未提交的数据，仅发生在读未提交的的隔离级别下：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- session1 当数据库中一个事务A正在修改一个数据但是还未提交或者回滚</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SELECT</span> k <span class="keyword">FROM</span> T1 <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 1</span></span><br><span class="line"><span class="keyword">UPDATE</span> T1 <span class="keyword">SET</span> k=<span class="number">2</span> <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- session2</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">SESSION</span> <span class="keyword">TRANSACTION</span> <span class="keyword">ISOLATION</span> <span class="keyword">LEVEL</span> <span class="keyword">READ</span> UNCOMMITTED;</span><br><span class="line"><span class="keyword">SELECT</span> k <span class="keyword">FROM</span> T1 <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 2 session2 出现脏读</span></span><br></pre></td></tr></table></figure><p>不可重复读（non-repeatable read）前后读取的记录内容不一致，发生在读未提交、读提交的隔离级别：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- session1 在一个事务A中多次操作数据，在事务操作过程中(未最终提交)</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">SESSION</span> <span class="keyword">TRANSACTION</span> <span class="keyword">ISOLATION</span> <span class="keyword">LEVEL</span> <span class="keyword">READ</span> COMMITTED;</span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SELECT</span> k <span class="keyword">FROM</span> T1 <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- session2 修改改值</span></span><br><span class="line"><span class="keyword">UPDATE</span> T1 <span class="keyword">SET</span> k=<span class="number">2</span> <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- session1</span></span><br><span class="line"><span class="keyword">SELECT</span> k <span class="keyword">FROM</span> T1 <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 2 session1 出现不可重复读</span></span><br></pre></td></tr></table></figure><p>幻读（phantom read）前后读取的记录数量不一致，发生在读未提交、读提交的隔离级别，InnoDB RR 不发生幻读：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- session1 获取当前行数量</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">SESSION</span> <span class="keyword">TRANSACTION</span> <span class="keyword">ISOLATION</span> <span class="keyword">LEVEL</span> <span class="keyword">READ</span> COMMITTED;</span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> T1 <span class="keyword">WHERE</span> k=<span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- session2 插入一行数</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> T1 (k) <span class="keyword">VALUES</span> (<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- session1</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">count</span>(*) <span class="keyword">FROM</span> T1;</span><br><span class="line"><span class="comment">-- 2</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- session1 表数据</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> T1;</span><br><span class="line"><span class="comment">-- id,k 1,1 只有一行数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- session2 更新 id 主键</span></span><br><span class="line"><span class="keyword">UPDATE</span> T1 <span class="keyword">SET</span> <span class="keyword">id</span>=<span class="number">5</span> <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- session1</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> T1;</span><br><span class="line"><span class="comment">-- id,k 1,1</span></span><br><span class="line"><span class="keyword">UPDATE</span> T1 <span class="keyword">SET</span> <span class="keyword">id</span>=<span class="keyword">id</span>+<span class="number">1</span>;</span><br><span class="line"><span class="comment">-- ok</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> T1;</span><br><span class="line"><span class="comment">-- 竟然看到了两行 1,1 6,1</span></span><br><span class="line"><span class="comment">-- 1,1 MVCC 保证了 1,1 的存在</span></span><br><span class="line"><span class="comment">-- 因为主键的 UPDATE 在 MySQL 里是以 insert+delete 方式执行的。这个 6 和 1 在 MySQL 看来已经不是同一行数据了，1 的 delete version 是在事务 1 的可见范围，所以才能看得到。如果是非主键就只用一行，就是下面的例子.</span></span><br><span class="line"><span class="comment">-- 这个例子不能被归类为幻读，只不过是当前最新读带来的问题。</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- session1 获取 id=1 的 k</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SELECT</span> k <span class="keyword">FROM</span> T1;</span><br><span class="line"><span class="comment">-- 1 一行数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- session2 更新</span></span><br><span class="line"><span class="keyword">UPDATE</span> T1 <span class="keyword">SET</span> k=<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- session1</span></span><br><span class="line"><span class="keyword">SELECT</span> k <span class="keyword">FROM</span> T1;</span><br><span class="line"><span class="comment">-- 1</span></span><br><span class="line"><span class="keyword">UPDATE</span> T1 <span class="keyword">SET</span> k=k+<span class="number">1</span>;</span><br><span class="line"><span class="comment">-- ok</span></span><br><span class="line"><span class="keyword">SELECT</span> k <span class="keyword">FROM</span> T1;</span><br><span class="line"><span class="comment">-- 3</span></span><br></pre></td></tr></table></figure><ul><li><a href="https://www.zhihu.com/question/47007926" target="_blank" rel="noopener">关于幻读，可重复读的真实用例是什么？| zhihu</a></li></ul><p>不可重复读和幻读区别：由于在 InnoDB RR 下模拟不出幻读的场景，退回到 RC 隔离级别的话就容易把幻读和不可重复读搞混淆。理论上 RR 级别是无法解决幻读的问题, 但是由于 InnoDB 引擎的 RR 级别还使用了 MVCC，所以也就避免了幻读的出现。</p><p>后文有讲到 FOR UPDATE 下的幻读。</p><p>事务隔离级别：</p><ul><li>读未提交（READ UNCOMMITTED）一个事务还没提交时，它做的变更就能被别的事务看到。直接返回记录上的最新值，没有视图概念。</li><li>读提交（READ COMMITTED）一个事务提交之后，它做的变更才会被其他事务看到。这个视图是在每个 SQL 语句开始执行的时候创建的。</li><li>可重复读（REPEATABLE READ）一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的 read-view。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。这个视图是在事务启动时（第一个 SQL 执行时）创建的，整个事务存在期间都用这个视图。</li><li>串行化（SERIALIZABLE）对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。用加锁的方式来避免并行访问。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%tx_isolation%'</span>;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'transaction_isolation'</span>;</span><br><span class="line"><span class="comment">-- tx_isolation  REPEATABLE-READ</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> @@tx_isolation;</span><br><span class="line"><span class="comment">-- REPEATABLE-READ</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">SESSION</span> <span class="keyword">TRANSACTION</span> <span class="keyword">ISOLATION</span> <span class="keyword">LEVEL</span> <span class="keyword">READ</span> UNCOMMITTED;</span><br><span class="line"><span class="comment">-- 修改 session 事务隔离级别</span></span><br></pre></td></tr></table></figure><blockquote><p><a href="https://dev.mysql.com/doc/refman/8.0/en/set-transaction.html" target="_blank" rel="noopener">SET TRANSACTION Statement | mysql</a></p></blockquote><p>多版本并发控制（MVCC）</p><p><code>set autocommit=0</code>，这个命令会将这个线程的自动提交关掉。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 持续时间超过 60s 的事务</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> information_schema.innodb_trx <span class="keyword">where</span> TIME_TO_SEC(<span class="keyword">timediff</span>(<span class="keyword">now</span>(),trx_started))&gt;<span class="number">60</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">commit</span> <span class="keyword">work</span> <span class="keyword">and</span> <span class="keyword">chain</span>;</span><br><span class="line"><span class="comment">-- 等价于 commit; begin;</span></span><br></pre></td></tr></table></figure><p>如何避免长事务对业务的影响？</p><ul><li>确认是否使用了 set autocommit=0，如果没有，则可以使用 set autocommit=1 来避免长事务对业务的影响。</li><li>确认是否有不必要的只读事务。有些框架会习惯不管什么语句先用 begin/commit 框起来。</li><li>业务连接数据库的时候，根据业务本身的预估，通过 SET MAX_EXECUTION_TIME 命令，来控制每个语句执行的最长时间，避免单个语句意外执行太长时间。</li><li>监控 information_schema.Innodb_trx 表，设置长事务阈值。</li><li>开发测试阶段输出所用 general_log，分析日志提前发现问题。</li></ul><h2 id="04-深入浅出索引（上）"><a href="#04-深入浅出索引（上）" class="headerlink" title="04 | 深入浅出索引（上）"></a>04 | 深入浅出索引（上）</h2><ul><li>哈希表：这种结构适用于只有等值查询的场景。</li><li>有序数组：有序数组在等值查询和范围查询场景中的性能就都非常优秀。但有序数组索引只适用于静态存储引擎</li><li>搜索树：平衡二叉树是 O(log(N)) 的查询复杂度；N 叉树，以 InnoDB 整数字段索引为例，这个 N 差不多是 1200。</li></ul><blockquote><p>MySQL 默认一个节点的长度为 16K，一个整数（bigint）字段索引的长度为 8B，另外每个索引还跟着 6B 的指向其子树的指针；所以 16K/14B ≈ 1170</p></blockquote><p>innodb B+树主键索引的叶子节点存的是什么：</p><p>回复 1：</p><blockquote><p>InnoDB 磁盘管理的最小单位就是“页”，也就是说无论是叶子节点、非叶子节点和行数据，都是存放在页当中。页组成结构有头部数据、主体数据和尾部数据。头部数据主要存的是页相关数据，例如上一页、下一页、当前页号等。是一个双向链表结构。主体数据主要关注索引和数据的存储，也就是我们常说的索引和数据的存储位置。主体数据当中有一个“User Records”的概念，用来存储索引和数据，是一个单链表结构。<br>User Records 根据节点的不同，User Records 又分为四种不同类型：主键索引树叶子节点和非叶子节点，二级索引树叶子节点和非叶子节点。<br>有了页和 User Records 的认识，其实说叶子节点存的是页是一种笼统的回答，基于我的理解，我认为叶子节点（主键索引树叶子节点）存放的是行数据更为贴切。</p></blockquote><p>回复 2：</p><blockquote><p>B+树的叶子节点是 page（页），一个页里面可以存多个行。 B+树的结点跟 innoDB 的“页”都属于一种抽象逻辑概念。如果你要问“存”的是什么？我觉得回答行数据没毛病。因为存的不可能是“页”。这一逻辑概念，只能说这个叶结点大小等于 innoDB 里设置的页大小，或者说这个叶结点其实就是“页”。但存的是什么？那当然是数据，什么数据？当然是表中的行数据。</p></blockquote><p>索引类型分为主键索引和非主键索引。</p><ul><li>主键索引也被称为聚簇索引（clustered index）</li><li>非主键索引也被称为二级索引（secondary index）</li></ul><p>基于非主键索引的查询需要多扫描一棵索引树，也就是主键索引树，也就是回表操作。</p><p>自增主键的意义：</p><ul><li>性能方面：每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂（页分裂）。</li><li>存储空间方面：主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。</li></ul><p>有没有什么场景适合用业务字段直接做主键的呢？</p><ul><li>只有一个索引</li><li>该索引必须是唯一索引</li></ul><p>即典型的 KV 场景。</p><p>非聚集索引上为啥叶子节点的 value 为什么不是地址，这样可以直接定位到整条数据，而不用再次对整棵树进行查询？</p><p>这个叫作“堆组织表”，MyISAM 就是这样的，各有利弊。你想一下如果修改了数据的位置的情况，InnoDB 这种模式是不是就方便些。主键索引页分裂的场景，就可能会导致主键记录的地址发生变化，这时候需要更新每一个索引上面对主键记录地址的引用。</p><h2 id="05-深入浅出索引（下）"><a href="#05-深入浅出索引（下）" class="headerlink" title="05 | 深入浅出索引（下）"></a>05 | 深入浅出索引（下）</h2><p>覆盖索引：在查询里索引已经覆盖了查询需要的列。覆盖索引可以减少树的搜索次数，显著提升查询性能，是一个常用的性能优化手段。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> T <span class="keyword">where</span> k <span class="keyword">between</span> <span class="number">3</span> <span class="keyword">and</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>表中 k 的值是：1，2，3，5，6，7。引擎内部使用覆盖索引在索引 k 上其实读了三个记录（第一次 3，第二次 3 的下一个 5，第三次 5 的下一个 6 不满足 ），但是对于 MySQL 的 Server 层来说，它只是找引擎拿到了两条记录，因此 MySQL 认为扫描行数是 2。这就是引擎实际扫描条数不等于 MySQL explain 语句中的 rows 字段的原因。</p><p>最左前缀原则：B+树这种索引结构，可以利用索引的“最左前缀”，来定位记录。</p><p>第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。</p><p>如果需要常查人的名字与年龄。可以建立索引 (name,age) 与 (age)，而不是 (age,name) 与 (age)，考虑的原则就是空间。</p><p>索引下推优化（index condition pushdown)：</p><p>联合索引（name,age）为例，名字第一个字是张，而且年龄是 10 岁的所有男孩：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tuser <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'张%'</span> <span class="keyword">and</span> age=<span class="number">10</span> <span class="keyword">and</span> ismale=<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>这个语句在搜索索引树的时候，只能用 “张”。</p><ul><li>在 MySQL 5.6 之前，只能从符合 ‘张%’ 开始一个个回表。到主键索引上找出数据行，再对比字段值。</li><li>而 MySQL 5.6 引入的索引下推优化（index condition pushdown)，可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。</li></ul><p><img alt="image" src="https://user-images.githubusercontent.com/9289792/185831784-b6f62f71-a0f7-49c8-afe4-dda0f2dc335a.png" style="width:420px"></p><p>InnoDB 在（name,age）索引内部就判断了 age 是否等于 10，对于不等于 10 的记录，直接判断并跳过。</p><p>联合索引中是按索引列的顺序，来排序的。（name,age）先排 name 列的值，再排 age 列的值。</p><p>在满足语句需求的情况下，尽量少地访问资源是数据库设计的重要原则之一。</p><h2 id="06-全局锁和表锁：给表加个字段怎么有这么多阻碍？"><a href="#06-全局锁和表锁：给表加个字段怎么有这么多阻碍？" class="headerlink" title="06 | 全局锁和表锁：给表加个字段怎么有这么多阻碍？"></a>06 | 全局锁和表锁：给表加个字段怎么有这么多阻碍？</h2><p>全局锁：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 加全局读锁 FTWRL，整个库处于只读状态；做全库逻辑备份</span></span><br><span class="line"><span class="keyword">FLUSH</span> <span class="keyword">TABLES</span> <span class="keyword">WITH</span> <span class="keyword">READ</span> <span class="keyword">LOCK</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入一行数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">PROCESSLIST</span>;</span><br><span class="line"><span class="comment">-- Waiting for global read lock</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 释放锁</span></span><br><span class="line"><span class="keyword">UNLOCK</span> <span class="keyword">TABLES</span>;</span><br></pre></td></tr></table></figure><p>但是让整库都只读，听上去就很危险：</p><ul><li>如果你在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆。</li><li>如果你在从库上备份，那么备份期间从库不能执行主库同步过来的 binlog，会导致主从延迟。</li></ul><p>在可重复读隔离级别下开启一个事务，来确保拿到一致性视图。mysqldump 使用参数 <code>-single-transaction</code> 就是如此执行的。而由于 MVCC 的支持，这个过程中数据是可以正常更新的。</p><p>有了可重复读的事务隔离级别却还需要 FTWRL 的原因是：引擎不都支持这个事务隔离级别。</p><p>既然要全库只读，为什么不使用 <code>set global readonly=true</code> 的方式</p><ul><li>在有些系统中，readonly 的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。修改 global 变量的方式影响面更大。</li><li>在异常处理机制上有差异。如果执行 FTWRL 命令之后由于客户端发生异常断开，那么 MySQL 会自动释放这个全局锁，整个库回到可以正常更新的状态。而将<br>整个库设置为 readonly 之后，如果客户端发生异常，则数据库就会一直保持 readonly 状态，这样会导致整个库长时间处于不可写状态，风险较高。</li></ul><p>表级锁：</p><p>第一类表锁：<a href="https://dev.mysql.com/doc/refman/5.7/en/lock-tables.html" target="_blank" rel="noopener">lock-tables | mysql</a></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">LOCK</span> <span class="keyword">TABLES</span> T1 <span class="keyword">READ</span>, T2 WRITE;</span><br><span class="line"><span class="comment">-- 其他线程 写 T1、读写 T2 的语句都会被阻塞</span></span><br><span class="line"><span class="comment">-- 当前线程也只能执行 读 T1、读写 T2 的操作，其他表都不能访问</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 当前线程读 T2</span></span><br><span class="line"><span class="comment">-- Waiting for table metadata lock</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 当前线程读 T3</span></span><br><span class="line"><span class="comment">-- 1100 - Table 'T3' was not locked with LOCK TABLES</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看表锁</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">OPEN</span> <span class="keyword">TABLES</span> <span class="keyword">WHERE</span> In_use &gt; <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>第二类 MDL（metadata lock)：</p><p>MDL 不需要显式使用：</p><ul><li>当对一个表做增删改查操作的时候，加 MDL 读锁。读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。共享锁。</li><li>当要对表做结构变更操作的时候，加 MDL 写锁。读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。排他锁。</li></ul><p>给一个小表加个字段，导致整个库挂了：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- session1</span></span><br><span class="line"><span class="keyword">SET</span> autocommit = <span class="number">0</span>;</span><br><span class="line"><span class="comment">-- 关闭自动提交</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="comment">-- 开启使用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> T;</span><br><span class="line"><span class="comment">-- 查询 T 表，一切 ok</span></span><br><span class="line"><span class="comment">-- 获取 MDL 读锁 ok，因为在事务中，查询结束后没有释放读锁。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 事务中的 MDL 锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> information_schema.innodb_trx;</span><br><span class="line"><span class="comment">-- 查询事务有个 RUNNING</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- session2</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> T;</span><br><span class="line"><span class="comment">-- 查询 T 表，一切 ok</span></span><br><span class="line"><span class="comment">-- 获取 MDL 读锁 ok，查询结束后释放读锁。</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- session3</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`T`</span> <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> <span class="string">`c2`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">-- 修改字段，卡住</span></span><br><span class="line"><span class="comment">-- blocked 原因：是因为 session1 的 MDL 读锁还没有释放，而 session3 需要 MDL 写锁，因此只能被阻塞。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">OPEN</span> <span class="keyword">TABLES</span> <span class="keyword">WHERE</span> In_use &gt; <span class="number">0</span>;</span><br><span class="line"><span class="comment">-- In_use 1</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- session4</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> T;</span><br><span class="line"><span class="comment">-- 查询 T 表，卡住</span></span><br><span class="line"><span class="comment">-- blocked 原因：对表的增删改查操作都需要先申请 MDL 读锁，都被 session3 阻塞。</span></span><br></pre></td></tr></table></figure><p><img alt="image" src="https://user-images.githubusercontent.com/9289792/185884836-f36feff9-1668-4f37-ad06-1fff9d9c18ef.png" style="width:420px"></p><p>这里自己想了一个问题：session4 卡住后，session1 COMMIT 后，session4 的 SELECT 执行结果是否有 session3 的新列呢？</p><p>从结果上看是没有的。开始以为是事务级别，但是调整为 READ UNCOMMITTED，session4 仍然没有新列。后来了解到 online DDL 意识到应该有关系。测试后得出 session3 在获取写锁后，在做 DDL 前会释放写锁加读锁，这时 session4 就可以执行了，但是这时 DDL 还没有执行，所以 session4 的执行结果没有新列。</p><p>如果 session3 执行语句是：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`T`</span> <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> <span class="string">`c2`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="literal">NULL</span>, <span class="keyword">LOCK</span>=EXCLUSIVE;</span><br><span class="line"><span class="comment">-- NONE：允许并发查询和DML操作；</span></span><br><span class="line"><span class="comment">-- SHARED：允许并发查询，但不允许DML操作；</span></span><br><span class="line"><span class="comment">-- DEFAULT：允许尽可能多的并发查询或DML操作(或两者都允许)，没指定LOCK选项默认就为DEFAULT；</span></span><br><span class="line"><span class="comment">-- EXCLUSIVE：不允许并发查询和DML操作。</span></span><br></pre></td></tr></table></figure><p>EXCLUSIVE 时写锁会一直持有，一直等到 DDL 完毕 session4 才开始执行，所以 session4 的执行结果有新列。</p><p>衍生问题：session3 如果没有 <code>LOCK=EXCLUSIVE</code>，session4 查询前 <code>BEGIN;</code> 开启事务那结果是如何呢？实验结果：session1 提交后，session3 session4 依然阻塞。</p><p>衍生问题：session3 添加 <code>LOCK=EXCLUSIVE</code>，session4 查询前 <code>BEGIN;</code> 开启事务那结果是如何呢？实验结果：ssession1 提交后，session3 session4 正常结束。</p><p>分析猜测 session3 阻塞的原因是：session1 提交后释放了读锁，session3 session4 拿到读锁，session3 DDL 操作完成后又要拿写锁，但是 session4 的读锁未释放，所以 session3 阻塞。那 session4 为啥阻塞呢？session4 可以获取读锁就应该可以执行完毕，遗留问题。</p><p>如何安全地给小表加字段？</p><ul><li>解决长事务，事务不提交，就会一直占着 MDL 锁。</li><li>在 ALTER TABLE 语句里面设定等待时间，如果在这个指定的等待时间里面能够拿到 MDL 写锁最好，拿不到也不要阻塞后面的业务语句，先放弃。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name <span class="keyword">NOWAIT</span> <span class="keyword">add</span> <span class="keyword">column</span> ...</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name <span class="keyword">WAIT</span> N <span class="keyword">add</span> <span class="keyword">column</span> ...</span><br></pre></td></tr></table></figure><p>实测：MySQL 5.7.30 不支持。腾讯云 MySQL 5.7.18-txsql-log 支持。</p><ul><li><a href="https://cloud.tencent.com/document/product/236/48838" target="_blank" rel="noopener">支持 NOWAIT 语法 | cloud.tencent</a></li></ul><h2 id="07-行锁功过：怎么减少行锁对性能的影响？"><a href="#07-行锁功过：怎么减少行锁对性能的影响？" class="headerlink" title="07 | 行锁功过：怎么减少行锁对性能的影响？"></a>07 | 行锁功过：怎么减少行锁对性能的影响？</h2><p>在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。</p><p>如果事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。</p><p>举例：</p><ol><li>从顾客 A 账户余额中扣除电影票价；UPDATE</li><li>给影院 B 的账户余额增加这张电影票价；UPDATE 最容易发送锁等待的地方</li><li>记录一条交易日志。INSERT</li></ol><p>以 3、1、2 顺序执行可以最大程度地减少了事务之间的锁等待，提升了并发度。</p><p>当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁。</p><p><img alt="image" src="https://user-images.githubusercontent.com/9289792/186377931-53a1b737-3149-4985-820f-87ffd1319158.png" style="width:420px"></p><p>上图 session1 在等 session2 id=2 的锁，session2 在等 session1 id=1 的锁，进入死锁状态。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 所等待超时时间 s</span></span><br><span class="line"><span class="keyword">SELECT</span> @@innodb_lock_wait_timeout;</span><br><span class="line"><span class="comment">-- 7200 2h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务</span></span><br><span class="line"><span class="keyword">SELECT</span> @@innodb_deadlock_detect;</span><br><span class="line"><span class="comment">-- 1213 - Deadlock found when trying to get lock; try restarting transaction</span></span><br></pre></td></tr></table></figure><p>主动死锁检测在发生死锁的时候，是能够快速发现并进行处理的，但是它也是有额外负担的：</p><p>每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待，也就是死锁。</p><p>每个新来的被堵住的线程，都要判断会不会由于自己的加入导致了死锁，这是一个时间复杂度是 O(n)的操作。假设有 1000 个并发线程要同时更新同一行，那么死锁检测操作就是 100 万这个量级的。这期间要消耗大量的 CPU 资源。即：热点行更新导致的性能问题。</p><p>可以通过尝试将热点数据拆分多行进行处理，提高并发处理。</p><h2 id="08-事务到底是隔离的还是不隔离的？"><a href="#08-事务到底是隔离的还是不隔离的？" class="headerlink" title="08 | 事务到底是隔离的还是不隔离的？"></a>08 | 事务到底是隔离的还是不隔离的？</h2><p><code>begin/start transaction</code> 命令并不是一个事务的起点，在执行到它们之后的第一个操作 InnoDB 表的语句，事务才真正启动。如果你想要马上启动一个事务：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span> <span class="keyword">WITH</span> <span class="keyword">CONSISTENT</span> <span class="keyword">SNAPSHOT</span>;</span><br></pre></td></tr></table></figure><p>有两个“视图”的概念：</p><ul><li>一个是 view。它是一个用查询语句定义的虚拟表，在调用的时候执行查询语句并生成结果。创建视图的语法是 create view …，而它的查询方法与表一样。</li><li>另一个是 InnoDB 在实现 MVCC 时用到的一致性读视图，即 consistent read view，用于支持 RC（Read Committed，读提交）和 RR（Repeatable Read，可重复读）隔离级别的实现。</li></ul><p>在可重复读隔离级别下，事务在启动的时候就“拍了个快照”。注意，这个快照是基于整库的。</p><p>InnoDB 里面每个事务有一个唯一的事务 ID，叫作 transaction id。它是在事务开始的时候向 InnoDB 的事务系统申请的，是按申请顺序严格递增的。</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://gk.link/a/11AmM&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MySQL 实战 45 讲 | 林晓斌&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&quot;01-基础架构：一条-SQ
      
    
    </summary>
    
    
      <category term="mysql" scheme="https://zyf.im/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Shell Code Snippet</title>
    <link href="https://zyf.im/2022/07/28/shell-code-snippet/"/>
    <id>https://zyf.im/2022/07/28/shell-code-snippet/</id>
    <published>2022-07-28T03:51:46.000Z</published>
    <updated>2022-09-15T02:49:39.255Z</updated>
    
    <content type="html"><![CDATA[<h2 id="查找大文件"><a href="#查找大文件" class="headerlink" title="查找大文件"></a>查找大文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">du -s ./*|sort -nr|head -3</span><br></pre></td></tr></table></figure><p>一般说来不会出现删除文件后空间不释放的情况，但是也存在例外，比如文件被进程锁定，或者有进程一直在向这个文件写数据等等，要理解这个问题，就需要知道 Linux 下文件的存储机制和存储结构。</p><p>一个文件在文件系统中的存放分为两个部分：数据部分和指针部分，指针位于文件系统的 meta-data 中，数据被删除后，这个指针就从 meta-data 中清除了，而数据部分存储在磁盘中，数据对应的指针从 meta-data 中清除后，文件数据部分占用的空间就可以被覆盖并写入新的内容，之所以出现删除 access_log 文件后，空间还没释放，就是因为 httpd 进程还在一直向这个文件写入内容，导致虽然删除了 access_log 文件，但文件对应的指针部分由于进程锁定，并未从 meta-data 中清除，而由于指针并未被删除，那么系统内核就认为文件并未被删除，因此通过 df 命令查询空间并未释放也就不足为奇了。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取一个已经被删除但仍然被应用程序占用的文件列表</span></span><br><span class="line">lsof | grep delete</span><br></pre></td></tr></table></figure><p>通过这种方法，磁盘空间不但可以马上释放，也可保障进程继续向文件写入日志，这种方法经常用于在线清理 Apache、Tomcat、Nginx 等 Web 服务产生的日志文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">" "</span> &gt;/tmp/acess.log</span><br></pre></td></tr></table></figure><h2 id="grep-遍历文件夹查找文本内容"><a href="#grep-遍历文件夹查找文本内容" class="headerlink" title="grep 遍历文件夹查找文本内容"></a>grep 遍历文件夹查找文本内容</h2><p>有时候我们需要在某一个包含很多子目录的目录中搜索查找包含某个文本内容的文本，我们可以在 grep 中加上 -r 选项让 grep 命令迭代进入子目录查找。同时在命令最后加上代表文件通配符的*号，不然 grep 会一直等待输入。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep -r <span class="string">"查找文本内容"</span> *</span><br></pre></td></tr></table></figure><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><ul><li><a href="https://www.gnu.org/software/bash/manual/html_node/The-Set-Builtin.html" target="_blank" rel="noopener">The Set Builtin | gnu</a></li><li><a href="http://www.ruanyifeng.com/blog/2017/11/bash-set.html" target="_blank" rel="noopener">Bash 脚本 set 命令教程 | ruanyifeng</a></li></ul><a id="more"></a><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> -o errexit <span class="comment">#等价 set -e。只要发生错误，就终止执行。认为非0就是错误。</span></span><br><span class="line"><span class="built_in">set</span> +o nounset <span class="comment"># 等价 set +u。遇到不存在的变量不报错。默认如此。</span></span><br><span class="line"><span class="built_in">set</span> -o pipefail <span class="comment"># 只要一个子命令失败，整个管道命令就失败，脚本就会终止执行。</span></span><br><span class="line"><span class="built_in">set</span> -o xtrace <span class="comment"># 等价 set -x。在运行结果之前，先输出执行的那一行命令，调试复杂的脚本是很有用。</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> -o errexit</span><br><span class="line"><span class="built_in">set</span> -o nounset</span><br><span class="line"><span class="built_in">set</span> -o pipefail</span><br><span class="line"><span class="built_in">set</span> -o xtrace</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4合1</span></span><br><span class="line"><span class="built_in">set</span> -euxo pipefail</span><br><span class="line"><span class="comment">## 写法二</span></span><br><span class="line"><span class="built_in">set</span> -eux</span><br><span class="line"><span class="built_in">set</span> -o pipefail</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者执行命令时</span></span><br><span class="line">bash -euxo pipefail script.sh</span><br></pre></td></tr></table></figure><p>如果脚本里面有运行失败的命令（返回值非 0），Bash 默认会继续执行后面的命令。</p><p>实际开发中，如果某个命令失败，往往需要脚本停止执行，防止错误累积。这时，一般采用下面的写法：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">command</span> || <span class="built_in">exit</span> 1</span><br></pre></td></tr></table></figure><p>上面的写法表示只要 command 有非零返回值，脚本就会停止执行。</p><p>如果停止执行之前需要完成多个操作，就要采用下面三种写法：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 写法一</span></span><br><span class="line"><span class="built_in">command</span> || &#123; <span class="built_in">echo</span> <span class="string">"command failed"</span>; <span class="built_in">exit</span> 1; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写法二</span></span><br><span class="line"><span class="keyword">if</span> ! <span class="built_in">command</span>; <span class="keyword">then</span> <span class="built_in">echo</span> <span class="string">"command failed"</span>; <span class="built_in">exit</span> 1; <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 写法三</span></span><br><span class="line"><span class="built_in">command</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"$?"</span> -ne 0 ]; <span class="keyword">then</span> <span class="built_in">echo</span> <span class="string">"command failed"</span>; <span class="built_in">exit</span> 1; <span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>如果两个命令有继承关系，只有第一个命令成功了，才能继续执行第二个命令，那么就要采用下面的写法：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">command1 &amp;&amp; command2</span><br></pre></td></tr></table></figure><h2 id="CDPATH"><a href="#CDPATH" class="headerlink" title="CDPATH"></a>CDPATH</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Unset CDPATH so that path interpolation can work correctly</span></span><br><span class="line"><span class="built_in">unset</span> CDPATH</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> CDPATH=/etc</span><br><span class="line"><span class="built_in">cd</span> mail</span><br><span class="line">/etc/mail</span><br></pre></td></tr></table></figure><h2 id="Ubuntu-命令行下设置时区"><a href="#Ubuntu-命令行下设置时区" class="headerlink" title="Ubuntu 命令行下设置时区"></a>Ubuntu 命令行下设置时区</h2><ul><li>Ubuntu 16.04</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo dpkg-reconfigure tzdata</span><br></pre></td></tr></table></figure><p>按提示进行选择完成。</p><p>设置完成后发现在 <code>crontab</code> 仍然是按 UTC 执行的，应该是需要重启下系统或者：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/etc/init.d/rsyslog restart</span><br></pre></td></tr></table></figure><h2 id="Ubuntu-命令行下打开-PDF"><a href="#Ubuntu-命令行下打开-PDF" class="headerlink" title="Ubuntu 命令行下打开 PDF"></a>Ubuntu 命令行下打开 PDF</h2><p>一个文件夹中存放了大量的文件后，在窗口打开中被打开时是非常耗时的。当我们已经明确知道文件名时，可以直接在 Terminal 中使用命令，调用应用打开文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">evince filename.pdf</span><br></pre></td></tr></table></figure><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="http://askubuntu.com/questions/323131/setting-timezone-from-terminal" target="_blank" rel="noopener">setting timezone from terminal - Ask Ubuntu</a></li><li><a href="https://askubuntu.com/questions/54364/how-do-you-set-the-timezone-for-crontab" target="_blank" rel="noopener">cron - How do you set the timezone for crontab? - Ask Ubuntu</a></li><li><a href="http://blog.csdn.net/bigmarco/article/details/6555582" target="_blank" rel="noopener">Ubuntu 命令行打开 PDF 文件 - bigmarco 的专栏</a></li><li><a href="https://www.cnblogs.com/xd502djj/p/6668632.html" target="_blank" rel="noopener">Linux 文件删除，但是 df 之后磁盘空间没有释放</a></li></ul><p>– EOF –</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;查找大文件&quot;&gt;&lt;a href=&quot;#查找大文件&quot; class=&quot;headerlink&quot; title=&quot;查找大文件&quot;&gt;&lt;/a&gt;查找大文件&lt;/h2&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;du -s ./*|sort -nr|head -3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;一般说来不会出现删除文件后空间不释放的情况，但是也存在例外，比如文件被进程锁定，或者有进程一直在向这个文件写数据等等，要理解这个问题，就需要知道 Linux 下文件的存储机制和存储结构。&lt;/p&gt;&lt;p&gt;一个文件在文件系统中的存放分为两个部分：数据部分和指针部分，指针位于文件系统的 meta-data 中，数据被删除后，这个指针就从 meta-data 中清除了，而数据部分存储在磁盘中，数据对应的指针从 meta-data 中清除后，文件数据部分占用的空间就可以被覆盖并写入新的内容，之所以出现删除 access_log 文件后，空间还没释放，就是因为 httpd 进程还在一直向这个文件写入内容，导致虽然删除了 access_log 文件，但文件对应的指针部分由于进程锁定，并未从 meta-data 中清除，而由于指针并未被删除，那么系统内核就认为文件并未被删除，因此通过 df 命令查询空间并未释放也就不足为奇了。&lt;/p&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 获取一个已经被删除但仍然被应用程序占用的文件列表&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;lsof | grep delete&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;通过这种方法，磁盘空间不但可以马上释放，也可保障进程继续向文件写入日志，这种方法经常用于在线清理 Apache、Tomcat、Nginx 等 Web 服务产生的日志文件：&lt;/p&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot; &quot;&lt;/span&gt; &amp;gt;/tmp/acess.log&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h2 id=&quot;grep-遍历文件夹查找文本内容&quot;&gt;&lt;a href=&quot;#grep-遍历文件夹查找文本内容&quot; class=&quot;headerlink&quot; title=&quot;grep 遍历文件夹查找文本内容&quot;&gt;&lt;/a&gt;grep 遍历文件夹查找文本内容&lt;/h2&gt;&lt;p&gt;有时候我们需要在某一个包含很多子目录的目录中搜索查找包含某个文本内容的文本，我们可以在 grep 中加上 -r 选项让 grep 命令迭代进入子目录查找。同时在命令最后加上代表文件通配符的*号，不然 grep 会一直等待输入。&lt;/p&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;grep -r &lt;span class=&quot;string&quot;&gt;&quot;查找文本内容&quot;&lt;/span&gt; *&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h2 id=&quot;set&quot;&gt;&lt;a href=&quot;#set&quot; class=&quot;headerlink&quot; title=&quot;set&quot;&gt;&lt;/a&gt;set&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://www.gnu.org/software/bash/manual/html_node/The-Set-Builtin.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;The Set Builtin | gnu&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2017/11/bash-set.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Bash 脚本 set 命令教程 | ruanyifeng&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="code-snippet" scheme="https://zyf.im/categories/code-snippet/"/>
    
    
  </entry>
  
  <entry>
    <title>Front-end Code Snippet</title>
    <link href="https://zyf.im/2022/07/26/front-end-code-snippet/"/>
    <id>https://zyf.im/2022/07/26/front-end-code-snippet/</id>
    <published>2022-07-26T03:51:46.000Z</published>
    <updated>2022-07-28T11:35:30.627Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="库推荐"><a href="#库推荐" class="headerlink" title="库推荐"></a>库推荐</h2><h3 id="nrm"><a href="#nrm" class="headerlink" title="nrm"></a>nrm</h3><p><a href="https://github.com/Pana/nrm" target="_blank" rel="noopener">Pana/nrm</a></p><p>nrm can help you easy and fast switch between different npm registries, now include: npm, cnpm, taobao, nj(nodejitsu).</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g nrm</span><br><span class="line"></span><br><span class="line">nrm ls</span><br><span class="line"></span><br><span class="line">nrm use tencent</span><br></pre></td></tr></table></figure><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p>– EOF –</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;h2 id=&quot;库推荐&quot;&gt;&lt;a href=&quot;#库推荐&quot; class=&quot;headerlink&quot; title=&quot;库推荐&quot;&gt;&lt;/a&gt;库推荐&lt;/h2&gt;&lt;h3 id=&quot;nrm&quot;&gt;&lt;a href=&quot;#nrm&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
      <category term="code-snippet" scheme="https://zyf.im/categories/code-snippet/"/>
    
    
  </entry>
  
  <entry>
    <title>2022Q3 随想录</title>
    <link href="https://zyf.im/2022/07/01/2022-q3-thinking/"/>
    <id>https://zyf.im/2022/07/01/2022-q3-thinking/</id>
    <published>2022-07-01T13:08:08.000Z</published>
    <updated>2022-09-15T06:26:55.670Z</updated>
    
    <content type="html"><![CDATA[<p>生活或者工作中总有些值得记录下的小感想，没必单独写一篇独立文章那就写在 <code>随想录</code> 里吧。<code>随想录</code> 以季度为单位开设。</p><p>开 <code>随想录</code> 专题的直接原因是：在翻看扔进 <code>_drafts</code> 里 18 年写的工作笔记，看到当时留下的一些技术疑问而现在已有答案。这真是一种很棒的感觉，可以感觉到自己的成长、变化，可以复盘自己是否走向自己希望的方向。</p><p>自己每天都和自己在一起，很不容感觉到自己变化。不记录事件下当时的想法，在之后回顾此时身处事情之外很容易对当时的想法进行修饰或者修正，变的面目全非。</p><p>还是多写写吧，就当快照一样记录下当时的想法。“正经人谁写日记啊。”</p><h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><h2 id="迁移-2018-笔记"><a href="#迁移-2018-笔记" class="headerlink" title="迁移 2018 笔记"></a>迁移 2018 笔记</h2><h3 id="未明确指定字段所属表的隐患"><a href="#未明确指定字段所属表的隐患" class="headerlink" title="未明确指定字段所属表的隐患"></a>未明确指定字段所属表的隐患</h3><p>在修改表结构时，在 <code>a</code> 表新添加 <code>name</code> 字段，<code>b</code> 表本事就有 <code>name</code> 字段；原来的项目中有 <code>a</code> <code>b</code> 表的关联查询，并用到了 <code>name</code> 字段。这时，原来 <code>name</code> 指的是 <code>a</code> 还是 <code>b</code> 表中的变的不确定了，造成报错。</p><p>主要原因就是在连表时：未明确指定字段所属表，造成了伏笔。</p><blockquote><p>2022Q3：关联查询现在多用模型的方案。</p></blockquote><h3 id="数据库枚举值的坑"><a href="#数据库枚举值的坑" class="headerlink" title="数据库枚举值的坑"></a>数据库枚举值的坑</h3><p>在数据库使用枚举时可以规范数据字典，但是也造成了要添加值时，需要修改数据库结构，这是不可接受的。</p><p>而且枚举值查询可以使用 <code>0</code>,<code>1</code>,<code>2</code>.. 索引值进行查询，也可以使用 ‘public’ ‘private’ 这样的规定的字典值查询，有二义性，可能有伏笔。</p><ul><li>典类型的字段我都以 <code>_type</code> 结尾，<code>tinyint</code> 型，无符号，数字代表的值写在字段注释里。eg: book_type</li><li>有 <code>是否</code> 概念的字段也不要用 枚举，我会使用 <code>is_</code> 开头。eg: is_review</li></ul><blockquote><p>2022Q3：数据库枚举值没再用过。<code>is_</code> <code>_type</code> 的命名方式沿用至今。</p></blockquote><p>补充说明：枚举类型不但可以使用下标 <code>0</code>,<code>1</code>,<code>2</code>.. 查询，也可以使用不加引号的 <code>0</code>,<code>1</code>,<code>2</code>..（下标）来写入某个类型。</p><p>举个栗子：</p><p>类型：<code>enum(&#39;none&#39;,&#39;public&#39;,&#39;private&#39;,&#39;1&#39;)</code> 当你 <code>insert into ... set a = 1</code> 时：</p><ul><li>当 <code>a = 1</code> 是插入 enum 的第一个值，即 public。</li><li>当 <code>a = &#39;1&#39;</code> 是插入 enum 值为 1 的类型。</li></ul><p>所以在 PHP 弱类型语言中，数字可以不加单引号，所以要注意到这点。</p><h3 id="NGINX-没有配置结束符的伏笔"><a href="#NGINX-没有配置结束符的伏笔" class="headerlink" title="NGINX 没有配置结束符的伏笔"></a>NGINX 没有配置结束符的伏笔</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location ~*.xml$ &#123;</span><br><span class="line">    rewrite &#39;^&#x2F;sitemap&#x2F;([a-z_0-9]*)\.(xml)$&#39; &#x2F;sitemap&#x2F;$1 last;</span><br><span class="line">    add_header X-Robots-Tag noindex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是配置 sitemap XML 转发和添加 header，在 <code>~*.xml$</code> 中，如果没有 <code>$</code> 会造成只要 slug 中有 <code>xml</code> 就进行了转发。eg: <code>/abc/abcxmldef</code> 将被转发 这是不符合预期的。</p><h3 id="MySQL-连接遇到的端口问题"><a href="#MySQL-连接遇到的端口问题" class="headerlink" title="MySQL 连接遇到的端口问题"></a>MySQL 连接遇到的端口问题</h3><p>自己的电脑有两个 MySQL 服务，一个 3306 一个 3307。在使用 <code>mysql -uroot -p -P3307</code> 这样指定端口连接是无效的。</p><p>其实这个是 MySQL 故意设计的，如果你的 host 是 localhost（如果不指定默认也是 localhost），那 MySQL 必须用 unix socket 连接，那样的话设置端口什么的当然没用啦。所以正确的做法是指定 host 为 127.0.0.1 再指定端口，绝对管用。</p><p>查看端口：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'port'</span>;</span><br></pre></td></tr></table></figure><ul><li><a href="https://blog.popon.top/set-no-port-when-mysql-connect-localhost.html" target="_blank" rel="noopener">MySQL 客户端的指定端口问题</a></li></ul><p>MySQL 配置文件的读取顺序和位置可以通过 <code>mysql --help</code> 查看。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Default options are <span class="built_in">read</span> from the following files <span class="keyword">in</span> the given order:</span><br><span class="line">/etc/my.cnf /etc/mysql/my.cnf /usr/<span class="built_in">local</span>/Cellar/mysql-client/8.0.30/etc/my.cnf ~/.my.cnf</span><br></pre></td></tr></table></figure><h3 id="测试，坚持如一"><a href="#测试，坚持如一" class="headerlink" title="测试，坚持如一"></a>测试，坚持如一</h3><p>今天发现了：因为测试不全导致的手机端部分页面显示异常的情况。问题的发现还是用户发现后反馈的。</p><p>原因：手机端的页面代码位置应该总体是和 PC 端是一致的，但是在整理代码时，一个两端的结构差异导致了缺少引用一个 JavaScript 库，在测试过程中，没有测试到此一级页面，PC 端代段此级正常。</p><p>还是自己懈怠了，测试，坚持如一，欠的总会还。引以为戒。</p><blockquote><p>2022Q3：近日也出现了整理代码删除了还在被使用的类文件。永远不能心存侥幸，要多看一眼。</p></blockquote><h3 id="MySQL-用户不同导致的数据库无法打开"><a href="#MySQL-用户不同导致的数据库无法打开" class="headerlink" title="MySQL 用户不同导致的数据库无法打开"></a>MySQL 用户不同导致的数据库无法打开</h3><p>使用 Navicat 无法打开数据库，提示大概是权限什么的问题，使用 mysql 命令是可以的。</p><p>后来发现是：在线上建立了一个视图，使用的是一个远程用户，后来数据备份，视图也被备份到本地了。但是这个远程用户在本地是没有的，所以导致使用 Navicat 时，无法打开数据库。</p><blockquote><p>2022Q3：现在多使用的是云数据库，授权用户权限要谨慎。</p></blockquote><h3 id="页面中-JavaScript-中正则表达式中的特殊字符被转码"><a href="#页面中-JavaScript-中正则表达式中的特殊字符被转码" class="headerlink" title="页面中 JavaScript 中正则表达式中的特殊字符被转码"></a>页面中 JavaScript 中正则表达式中的特殊字符被转码</h3><p>今天遇到 HTML 页面中直接写了 JavaScript 的验证的表达式：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"[©]+"</span>;</span><br></pre></td></tr></table></figure><p>里面涉及了一个特殊字符 <code>©</code>，页面第一次加载时，一起正常，但是 <code>ajax</code> 提交后，<code>pjax reload</code> 页面后，<code>©</code> 被 <code>encode</code>。</p><p>解决方法：使用 <code>unicode</code> <code>[\\u00A9]+·</code></p><blockquote><p>2022Q3：当时还是纯手写 JavaScript，现在使用 webpack babel 等工具，是否不会再有类似问题了？</p></blockquote><p>一款很秀的 正则表达式 工具推荐给大家 <a href="https://jex.im/regulex" target="_blank" rel="noopener">jex.im/regulex</a></p><h3 id="Firefox-word-break-break-word"><a href="#Firefox-word-break-break-word" class="headerlink" title="Firefox word-break: break-word"></a>Firefox word-break: break-word</h3><p>Firefox 疑似不支持 <code>word-break: break-word</code> 对词进行折行</p><ul><li>Use <code>word-break: break-all;</code> instead of <code>word-break: break-word;</code></li><li>Or, Use <code>word-wrap: break-word;</code> instead of <code>word-break: break-word;</code></li></ul><p>所以 CSS 编写要考虑好厂商差异，亟待使用前端工具，最近准备使用 gulp 优化项目前端。</p><ul><li><a href="https://stackoverflow.com/questions/17143614/word-breakbreak-word-not-working-in-firefox-21" target="_blank" rel="noopener">Word-break:break-word not working in Firefox 21</a></li></ul><blockquote><p>2022Q3：现在使用 Vue2 全家桶，CSS 有相关 loader 处理兼容性。</p></blockquote><h3 id="Policy-条款要认真对待"><a href="#Policy-条款要认真对待" class="headerlink" title="Policy 条款要认真对待"></a>Policy 条款要认真对待</h3><p>在做部分功能是违反了 Google Policy，被直接标记为恶意网站，流量骤降。对应敏感信息要认真对待不可轻视。</p><blockquote><p>2022Q3：现在主要做内部系统。C 端问题遇到的比较少了。</p></blockquote><h3 id="数据查询的-N-1-问题"><a href="#数据查询的-N-1-问题" class="headerlink" title="数据查询的 N+1 问题"></a>数据查询的 N+1 问题</h3><p><a href="https://laravel-china.org/topics/7778/summary-using-the-laravel-development-tool-the-n-1-problem-of-the-orm-query" target="_blank" rel="noopener">N+1 查询问题</a> 就是查询扩展字段时的循环查询问题。</p><p>为了解决 N+1 问题我使用了模型 <a href="https://laravel-china.org/docs/laravel/5.5/eloquent-relationships/1265#eager-loading" target="_blank" rel="noopener">预加载</a> 方式，但是由于后台框架限制（也可能是使用不当），将 <em>一对多</em> 的被关联的模型数据都查出来了，数据量很大，导致页面卡顿，一次反向优化。优化要权衡不能硬搬书本。</p><blockquote><p>2022Q3：消除 N+1 问题仍是开发优化必修课。</p></blockquote><h3 id="使用-…-运算符定义变长参数函数"><a href="#使用-…-运算符定义变长参数函数" class="headerlink" title="使用 … 运算符定义变长参数函数"></a>使用 … 运算符定义变长参数函数</h3><p>在写一方式时使用了 <code>...</code> 运算符，但是这个运算符是 PHP 5.6 增加的，线上是 PHP 5.5 导致 500 报错，环境问题暴露。如果可能出错，就一定会出错。</p><ul><li><a href="http://php.net/manual/zh/migration56.new-features.php" target="_blank" rel="noopener">从 PHP 5.5.x 移植到 PHP 5.6.x</a></li></ul><blockquote><p>2022Q3：开发、测试、UAT、PROD 环境一致性必须对齐。</p></blockquote><h3 id="Ubuntu-核心参数"><a href="#Ubuntu-核心参数" class="headerlink" title="Ubuntu 核心参数"></a>Ubuntu 核心参数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net.ipv4.tcp_fin_timeout &#x3D; 30</span><br><span class="line">net.ipv4.tcp_keepalive_time &#x3D; 300</span><br><span class="line">net.ipv4.tcp_syncookies &#x3D; 1</span><br><span class="line">net.ipv4.tcp_tw_reuse &#x3D; 1</span><br><span class="line">net.ipv4.tcp_tw_recycle &#x3D; 1</span><br><span class="line">net.ipv4.ip_local_port_range &#x3D; 5000 65000</span><br></pre></td></tr></table></figure><p><code>sysctl -p</code> 显示系统内核参数变化。其中含义待研究。</p><blockquote><p>2022Q3：仍然不懂。</p></blockquote><h3 id="etc-sysctl-conf"><a href="#etc-sysctl-conf" class="headerlink" title="/etc/sysctl.conf"></a>/etc/sysctl.conf</h3><p><code>net.ipv4.tcp_tw_recycle</code> 改为 <code>0</code>。</p><p><code>tcp_tw_recycle</code> 和 <code>tcp_timestmaps</code> 同时开启时，会有 risk，来自 NAT 网路的用户访问会有丢包情况从而导致 504。<code>tcp_tw_recycle</code> 默认是不开启的，之前的优化配置开启该选项时时并没有考虑这一点。从 Linux 4.12 开始，该选项已被移除。</p><blockquote><p>2022Q3：仍然不懂。</p></blockquote><h3 id="正确使用-Redis"><a href="#正确使用-Redis" class="headerlink" title="正确使用 Redis"></a>正确使用 Redis</h3><p>在读 Redis 大数组会占用大量的 PHP-FPM 内存，影响查询效率。在大量（百万级）使用存储 Redis Key 发现慢查询，拖累服务器，<strong>是否是此原因待详细查</strong>。如何正确使用 Redis、配置 Redis 需要总结。</p><blockquote><p>2022Q3：Redis 一次读取大数据是可能造成阻塞的，当时使用 Redis 都是本地安装，现在都是使用云服务。类似问题没在遇到过，遇到后再分析。</p></blockquote><h3 id="MySQL-索引选择"><a href="#MySQL-索引选择" class="headerlink" title="MySQL 索引选择"></a>MySQL 索引选择</h3><p>某查询中通过 explain 发现 MySQL 选择了一个较慢的索引，发现相同条件下不同的时间会使用不同的索引，引发了慢查询。需要研究 MySQL 如何进行索引的选择，和如何建立合理的索引。</p><blockquote><p>2022Q3：最近在读《MySQL 实战 45 讲》真的收获很多。</p></blockquote><h3 id="AWS-EC2-服务器类型"><a href="#AWS-EC2-服务器类型" class="headerlink" title="AWS EC2 服务器类型"></a>AWS EC2 服务器类型</h3><p><code>定额配置</code> 与 <code>信用积分</code>，影响服务器性能。</p><h3 id="Python-SELECT-查询事务"><a href="#Python-SELECT-查询事务" class="headerlink" title="Python SELECT 查询事务"></a>Python SELECT 查询事务</h3><p>Python 的 <code>SELECT</code> 查询默认是事务性的操作，期间无法对表 <code>DDL</code> 进行改变。</p><p><code>SELECT</code> 语句也应该进行 <code>COMMIT</code>。道听途说，待自测详查。</p><blockquote><p>2022Q3：最近在读《MySQL 实战 45 讲》真的收获很多。应该是 MDL（metadata lock) 的原因。</p></blockquote><h3 id="NGINX-Log-中挖掘项目隐藏的问题"><a href="#NGINX-Log-中挖掘项目隐藏的问题" class="headerlink" title="NGINX Log 中挖掘项目隐藏的问题"></a>NGINX Log 中挖掘项目隐藏的问题</h3><ul><li>通过 log 监控流量、访问行为、发现爬虫</li><li>通过 log 分析非 200 状态码，检查项目页面</li></ul><blockquote><p>2022Q3：现在的使用的日志监控服务就是监控 NGINX 与项目应用日志。</p></blockquote><h3 id="数据库字段中包含-HTML-元素导致页面错乱"><a href="#数据库字段中包含-HTML-元素导致页面错乱" class="headerlink" title="数据库字段中包含 HTML 元素导致页面错乱"></a>数据库字段中包含 HTML 元素导致页面错乱</h3><p>数据库数据有 <code>&lt;/div&gt;</code> 等标签，与模板元素连接在一起，导致页面错乱。要显示的数据要 <code>htmlspecialchars</code> 转码。</p><blockquote><p>2022Q3：提防 HTML 注入。</p></blockquote><h3 id="爬取检查时发生-Connection-to-the-other-side-was-lost-in-non-clean"><a href="#爬取检查时发生-Connection-to-the-other-side-was-lost-in-non-clean" class="headerlink" title="爬取检查时发生 Connection to the other side was lost in non-clean"></a>爬取检查时发生 Connection to the other side was lost in non-clean</h3><blockquote><p>thanks for xq24.</p></blockquote><p>Scrapy 快速的三次 retry 之后 give up，然后接着 url 都出现这个问题。</p><p>此时状态：这时浏览器挂上代理能访问出现问题的 url，但是本地无代理时 IP 无法访问。</p><p>查看服务器 Log：</p><p>发现有状态码 499 但是，只有访问一次这个 url 会出现俩三个 499 的 response，然后一段时间内，整个站就都不能访问了，没有反应了，NGINX 日志里面也没有记录到任何东西了，说明数据没有到 NGINX 应该是 TCP 层的网络有问题。</p><p>验证：</p><p><code>tcpdump</code> + <code>Wirsshark</code> 分析。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo tcpdump tcp -i eth0 -t -s 0 -c 1000 and dst port ! 22 -w ./target.cap</span><br></pre></td></tr></table></figure><p>出现了很多的 <code>RST</code> 导致 TCP 连接中断，仔细看，发现里面的 ACK 完全和上一个包的 Seq 对不上，我们客服端的 ACK 的是一个巨大的随机数。导致服务器端返回 <code>RST</code>。</p><p>因为项目是 HTTP 应用层的，不会影响到 TCP 层，所以 Google 关键字 <code>tcp reset + blogspot.com</code> 看到 reddit 一篇 8 年前的讨论。讲到了 <a href="https://www.reddit.com/r/programming/comments/aph4r/tcp_resets_how_the_baidublogspotgooglecomblockout/" target="_blank" rel="noopener">关于中国防火墙</a>。中国 GFW 会有根据 tcp 协议里面的关键字来进行屏蔽。然后会通过 reset 修改来屏蔽整个站几分钟。https 协议的不会。</p><p>测试了俩个国外的网站：</p><ul><li><a href="http://site.aace.org/conf/blogspot.com" target="_blank" rel="noopener">http://site.aace.org/conf/blogspot.com</a></li><li><a href="http://www.motogp.com/blogspot.com" target="_blank" rel="noopener">http://www.motogp.com/blogspot.com</a></li></ul><p>加入了 blogspot.com 就无法访问了。</p><p>所以问题找到了中国 GFW 会通过 URL 里面的敏感字进行封锁网站，<a href="http://fanqianghuayuan.blogspot.com/2013/05/ignore-gfw.html" target="_blank" rel="noopener">有篇具体分析的文章</a>。线上因为用的 HTTPS 协议所以内容加密了，没有被 block，解决方法:</p><ul><li>将测试服务器换成 HTTPS 然后就可以访问了</li><li>通过代理访问</li></ul><blockquote><p>2022Q3：网络知识问题，待继续学习。</p></blockquote><h3 id="NGINX-Log-出现大量（10K）HTTP-499-错误"><a href="#NGINX-Log-出现大量（10K）HTTP-499-错误" class="headerlink" title="NGINX Log 出现大量（10K）HTTP 499 错误"></a>NGINX Log 出现大量（10K）HTTP 499 错误</h3><p><a href="https://httpstatuses.com/499" target="_blank" rel="noopener">499 CLIENT CLOSED REQUEST</a></p><p>A non-standard status code introduced by nginx for the case when a client closes the connection while nginx is processing the request.</p><p>NGINX Log 出现大量（10K）HTTP 499 错误，几乎都是 AJAX POST 请求。经过日志排查，发现这些 499 请求都是来自于 Safari 浏览器，再通过日志查看，这些请求都是正常的用户行为。在本地使用 Safari 浏览器实测时也是会出现这样的问题。基本可以断定是 Safari 浏览器导致。</p><p>最终确定为在点击一个 button 时同发送了两请求，分别为 async: false，async: true。</p><p>在进行控制变量的测试中，基本确定与 AJAX 同异步请求有关。不建议修改 async 为 false。</p><p>在测试的过程中，也发现虽然使用 Safari 请求显示 NGINX 日志中会显示 499，但是数据的记录并没有受到影响。</p><blockquote><p>2022Q3：待再研究。</p></blockquote><h3 id="服务器器运维工具-atop"><a href="#服务器器运维工具-atop" class="headerlink" title="服务器器运维工具 atop"></a>服务器器运维工具 atop</h3><p>待整理。</p><h3 id="完全独立的分支"><a href="#完全独立的分支" class="headerlink" title="完全独立的分支"></a>完全独立的分支</h3><p>在使用 Git 进行版本控制的某些场景中我们可能需要在一个项目中建立完全独立的分支，此分支将作为一个独立的版本历史根节点，不与之前任何分支拥有相同的版本祖先。</p><p>比如当我们要在一个项目中使用一个分支进行项目文档的管理时，或者当我们想要发布一个软件的开源版本但又不希望将软件的版本历史暴露给外界时，都可以使用以下的方法建立一个独立分支。</p><p>通过带有 <code>--orphan</code> 参数的 <code>checkout</code> 命令即可从 <code>start_point</code> 或者 <code>HEAD</code> 创建一个独立分支：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout --orphan 新分支名 &lt;start_point&gt;</span><br></pre></td></tr></table></figure><p>如果希望创建全新的独立分支，例如用于文档管理，不想出现项目代码，则还需要进行如下删除操作。注意如果有不在索引中的文件，则需要手工删除（包括 .gitignore），删除此分支中的索引及索引中的所有文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rm -rf .</span><br></pre></td></tr></table></figure><p>– EOF –</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;生活或者工作中总有些值得记录下的小感想，没必单独写一篇独立文章那就写在 &lt;code&gt;随想录&lt;/code&gt; 里吧。&lt;code&gt;随想录&lt;/code&gt; 以季度为单位开设。&lt;/p&gt;&lt;p&gt;开 &lt;code&gt;随想录&lt;/code&gt; 专题的直接原因是：在翻看扔进 &lt;code&gt;_drafts&lt;
      
    
    </summary>
    
      <category term="thinking" scheme="https://zyf.im/categories/thinking/"/>
    
    
  </entry>
  
  <entry>
    <title>读《JavaScript 教程 | 网道》笔记</title>
    <link href="https://zyf.im/2022/06/09/javascript-wangdoc-reading-notes/"/>
    <id>https://zyf.im/2022/06/09/javascript-wangdoc-reading-notes/</id>
    <published>2022-06-09T06:59:09.000Z</published>
    <updated>2022-06-09T06:59:09.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://wangdoc.com/javascript/index.html" target="_blank" rel="noopener">JavaScript 教程 | 网道（WangDoc.com）</a></p></blockquote><a id="more"></a><h2 id="JavaScript-语言的历史"><a href="#JavaScript-语言的历史" class="headerlink" title="JavaScript 语言的历史"></a>JavaScript 语言的历史</h2><p>ECMAScript 只用来标准化 JavaScript 这种语言的基本语法结构，与部署环境相关的标准都由其他标准规定，比如 DOM 的标准就是由 W3C 组织（World Wide Web Consortium）制定的。</p><p>2011 年 6 月，ECMAScript 5.1 版发布，并且成为 ISO 国际标准（ISO/IEC 16262:2011）。到了 2012 年底，所有主要浏览器都支持 ECMAScript 5.1 版的全部功能。</p><p>2015 年 6 月，ECMAScript 6 正式发布，并且更名为“ECMAScript 2015”。这是因为 TC39 委员会计划，以后每年发布一个 ECMAScript 的版本，下一个版本在 2016 年发布，称为“ECMAScript 2016”，2017 年发布“ECMAScript 2017”，以此类推。</p><h2 id="JavaScript-的基本语法"><a href="#JavaScript-的基本语法" class="headerlink" title="JavaScript 的基本语法"></a>JavaScript 的基本语法</h2><p>如果只是声明变量而没有赋值，则该变量的值是 undefined。undefined 是一个特殊的值，表示“无定义”。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line">a; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>JavaScript 是一种动态类型语言，也就是说，变量的类型没有限制，变量可以随时更改类型。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">a = <span class="string">"hello"</span>;</span><br></pre></td></tr></table></figure><p>如果使用 var 重新声明一个已经存在的变量，是无效的。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> x;</span><br><span class="line">x; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>JavaScript 引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做变量提升（hoisting）。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在控制台（console）显示变量a的值。这时变量a还没有声明和赋值，所以这是一种错误的做法，但是实际上不会报错。因为存在变量提升，真正运行的是下面的代码。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line">a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>标识符命名规则如下：</p><ul><li>第一个字符，可以是任意 Unicode 字母（包括英文字母和其他语言的字母），以及美元符号（$）和下划线（_）。</li><li>第二个字符及后面的字符，除了 Unicode 字母、美元符号和下划线，还可以用数字 0-9。</li></ul><p>对于 var 命令来说，JavaScript 的区块不构成单独的作用域（scope）。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>else 代码块总是与离自己最近的那个 if 语句配对。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> n = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (m !== <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">2</span>) <span class="built_in">console</span>.log(<span class="string">"hello"</span>);</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">console</span>.log(<span class="string">"world"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (m !== <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"hello"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"world"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>switch 语句后面的表达式，与 case 语句后面的表示式比较运行结果时，采用的是严格相等运算符（===），而不是相等运算符（==），这意味着比较时不会发生类型转换。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (x) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="literal">true</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"x 发生类型转换"</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"x 没有发生类型转换"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// x 没有发生类型转换</span></span><br></pre></td></tr></table></figure><p>for 语句的三个部分（initialize、test、increment），可以省略任何一个，也可以全部省略。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Hello World"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码省略了 for 语句表达式的三个部分，结果就导致了一个无限循环。</p><p>JavaScript 语言允许，语句的前面有标签（label），相当于定位符，用于跳转到程序的任意位置，标签的格式如下。</p><p>标签通常与 break 语句和 continue 语句配合使用，跳出特定的循环。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">top: <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i === <span class="number">1</span> &amp;&amp; j === <span class="number">1</span>) <span class="keyword">break</span> top;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"i="</span> + i + <span class="string">", j="</span> + j);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// i=0, j=0</span></span><br><span class="line"><span class="comment">// i=0, j=1</span></span><br><span class="line"><span class="comment">// i=0, j=2</span></span><br><span class="line"><span class="comment">// i=1, j=0</span></span><br><span class="line"></span><br><span class="line">top: <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i === <span class="number">1</span> &amp;&amp; j === <span class="number">1</span>) <span class="keyword">continue</span> top;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"i="</span> + i + <span class="string">", j="</span> + j);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// i=0, j=0</span></span><br><span class="line"><span class="comment">// i=0, j=1</span></span><br><span class="line"><span class="comment">// i=0, j=2</span></span><br><span class="line"><span class="comment">// i=1, j=0</span></span><br><span class="line"><span class="comment">// i=2, j=0</span></span><br><span class="line"><span class="comment">// i=2, j=1</span></span><br><span class="line"><span class="comment">// i=2, j=2</span></span><br></pre></td></tr></table></figure><h2 id="数据类型概述"><a href="#数据类型概述" class="headerlink" title="数据类型概述"></a>数据类型概述</h2><p>JavaScript 语言的每一个值，都属于某一种数据类型。JavaScript 的数据类型，共有六种。（ES6 又新增了第七种 Symbol 类型的值，本教程不涉及。）</p><ul><li>数值（number）：整数和小数（比如 1 和 3.14）。</li><li>字符串（string）：文本（比如 Hello World）。</li><li>布尔值（boolean）：表示真伪的两个特殊值，即 true（真）和 false（假）。</li><li>undefined：表示“未定义”或不存在，即由于目前没有定义，所以此处暂时没有任何值。</li><li>null：表示空值，即此处的值为空。</li><li>对象（object）：各种值组成的集合。</li></ul><p>通常，数值、字符串、布尔值这三种类型，合称为原始类型（primitive type）的值，即它们是最基本的数据类型，不能再细分了。</p><p>对象则称为合成类型（complex type）的值，因为一个对象往往是多个原始类型的值的合成，可以看作是一个存放各种值的容器。</p><p>至于 undefined 和 null，一般将它们看成两个特殊值。</p><p>对象是最复杂的数据类型，又可以分成三个子类型。</p><ul><li>狭义的对象（object）</li><li>数组（array）</li><li>函数（function）</li></ul><p>函数其实是处理数据的方法，JavaScript 把它当成一种数据类型，可以赋值给变量，这为编程带来了很大的灵活性，也为 JavaScript 的“函数式编程”奠定了基础。</p><p>JavaScript 有三种方法，可以确定一个值到底是什么类型。</p><ul><li>typeof 运算符</li><li>instanceof 运算符</li><li>Object.prototype.toString 方法</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">123</span>; <span class="comment">// "number"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">"123"</span>; <span class="comment">// "string"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">false</span>; <span class="comment">// "boolean"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">typeof</span> f;</span><br><span class="line"><span class="comment">// "function"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>;</span><br><span class="line"><span class="comment">// "undefined"</span></span><br></pre></td></tr></table></figure><p>利用这一点，typeof 可以用来检查一个没有声明的变量，而不报错。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">v;</span><br><span class="line"><span class="comment">// ReferenceError: v is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> v;</span><br><span class="line"><span class="comment">// "undefined"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误的写法</span></span><br><span class="line"><span class="keyword">if</span> (v) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ReferenceError: v is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确的写法</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> v === <span class="string">"undefined"</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="built_in">window</span>; <span class="comment">// "object"</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125;; <span class="comment">// "object"</span></span><br><span class="line"><span class="keyword">typeof</span> []; <span class="comment">// "object"</span></span><br></pre></td></tr></table></figure><p>上面代码中，空数组（[]）的类型也是 object，这表示在 JavaScript 内部，数组本质上只是一种特殊的对象。instanceof 运算符可以区分数组和对象。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"></span><br><span class="line">o <span class="keyword">instanceof</span> <span class="built_in">Array</span>; <span class="comment">// false</span></span><br><span class="line">o <span class="keyword">instanceof</span> <span class="built_in">Object</span>; <span class="comment">// true</span></span><br><span class="line">a <span class="keyword">instanceof</span> <span class="built_in">Array</span>; <span class="comment">// true</span></span><br><span class="line">a <span class="keyword">instanceof</span> <span class="built_in">Object</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>null 的类型是 object，这是由于历史原因造成的。1995 年的 JavaScript 语言第一版，只设计了五种数据类型（对象、整数、浮点数、字符串和布尔值），没考虑 null，只把它当作 object 的一种特殊值。后来 null 独立出来，作为一种单独的数据类型，为了兼容以前的代码，typeof null 返回 object 就没法改变了。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>; <span class="comment">// "object"</span></span><br></pre></td></tr></table></figure><h2 id="null-undefined-和布尔值"><a href="#null-undefined-和布尔值" class="headerlink" title="null, undefined 和布尔值"></a>null, undefined 和布尔值</h2><p>null 与 undefined 都可以表示“没有”，含义非常相似。将一个变量赋值为 undefined 或 null，语法效果几乎没区别。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="literal">undefined</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"undefined is false"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// undefined is false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"null is false"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// null is false</span></span><br><span class="line"></span><br><span class="line"><span class="literal">undefined</span> == <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>1995 年 JavaScript 诞生时，最初像 Java 一样，只设置了 null 表示”无”。根据 C 语言的传统，null 可以自动转为 0。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="literal">null</span>); <span class="comment">// 0</span></span><br><span class="line"><span class="number">5</span> + <span class="literal">null</span>; <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>但是，JavaScript 的设计者 Brendan Eich，觉得这样做还不够。首先，第一版的 JavaScript 里面，null 就像在 Java 里一样，被当成一个对象，Brendan Eich 觉得表示“无”的值最好不是对象。其次，那时的 JavaScript 不包括错误处理机制，Brendan Eich 觉得，如果 null 自动转为 0，很不容易发现错误。</p><p>因此，他又设计了一个 undefined。区别是这样的：null 是一个表示“空”的对象，转为数值时为 0；undefined 是一个表示”此处无定义”的原始值，转为数值时为 NaN。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="literal">undefined</span>); <span class="comment">// NaN</span></span><br><span class="line"><span class="number">5</span> + <span class="literal">undefined</span>; <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><ul><li>null 表示空值，即该处的值现在为空。调用函数时，某个参数未设置任何值，这时就可以传入 null，表示该参数为空。比如，某个函数接受引擎抛出的错误作为参数，如果运行过程中未出错，那么这个参数就会传入 null，表示未发生错误。</li><li>undefined 表示“未定义”，下面是返回 undefined 的典型场景。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 变量声明了，但没有赋值</span></span><br><span class="line"><span class="keyword">var</span> i;</span><br><span class="line">i; <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用函数时，应该提供的参数没有提供，该参数等于 undefined</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line">f(); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象没有赋值的属性</span></span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">o.p; <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数没有返回值时，默认返回 undefined</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">f(); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>如果 JavaScript 预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值。转换规则是除了下面六个值被转为 false，其他值都视为 true。</p><ul><li>undefined</li><li>null</li><li>false</li><li>0</li><li>NaN</li><li>“”或’’（空字符串）</li></ul><p>注意，空数组（[]）和空对象（{}）对应的布尔值，都是 true。</p><h2 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h2><p>JavaScript 内部，所有数字都是以 64 位浮点数形式储存，即使整数也是如此。所以，1 与 1.0 是相同的，是同一个数。</p><p>这就是说，JavaScript 语言的底层根本没有整数，所有数字都是小数（64 位浮点数）。</p><blockquote><p>容易造成混淆的是，某些运算只有整数才能完成，此时 JavaScript 会自动把 64 位浮点数，转成 32 位整数，然后再进行运算。</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> === <span class="number">1.0</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>由于浮点数不是精确的值，所以涉及小数的比较和运算要特别小心。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> === <span class="number">0.3</span>;</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="number">0.3</span> /</span><br><span class="line">  <span class="number">0.1</span>(</span><br><span class="line">    <span class="comment">// 2.9999999999999996</span></span><br><span class="line"></span><br><span class="line">    <span class="number">0.3</span> - <span class="number">0.2</span></span><br><span class="line">  ) ===</span><br><span class="line">  <span class="number">0.2</span> - <span class="number">0.1</span>;</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>根据国际标准 IEEE 754，JavaScript 浮点数的 64 个二进制位，从最左边开始，是这样组成的。</p><ul><li>第 1 位：符号位，0 表示正数，1 表示负数</li><li>第 2 位到第 12 位（共 11 位）：指数部分</li><li>第 13 位到第 64 位（共 52 位）：小数部分（即有效数字）</li></ul><p>符号位决定了一个数的正负，指数部分决定了数值的大小，小数部分决定了数值的精度。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>);</span><br><span class="line"><span class="comment">// 9007199254740992</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多出的三个有效数字，将无法保存</span></span><br><span class="line"><span class="number">9007199254740992111</span>;</span><br><span class="line"><span class="comment">// 9007199254740992000</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">1024</span>); <span class="comment">// Infinity “正向溢出”</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">-1075</span>); <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>.MAX_VALUE; <span class="comment">// 1.7976931348623157e+308</span></span><br><span class="line"><span class="built_in">Number</span>.MIN_VALUE; <span class="comment">// 5e-324</span></span><br><span class="line"></span><br><span class="line"><span class="number">123e3</span>; <span class="comment">// 123000</span></span><br><span class="line"><span class="number">123e-3</span>; <span class="comment">// 0.123</span></span><br><span class="line"><span class="number">-3.1e12</span>;</span><br><span class="line"><span class="number">0.1e-23</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 小数点前的数字多于21位。</span></span><br><span class="line"><span class="number">1234567890123456789012</span>;</span><br><span class="line"><span class="comment">// 1.2345678901234568e+21</span></span><br><span class="line"></span><br><span class="line"><span class="number">123456789012345678901</span>;</span><br><span class="line"><span class="comment">// 123456789012345680000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 小数点后的零多于5个。</span></span><br><span class="line"><span class="comment">// 小数点后紧跟5个以上的零，就自动转为科学计数法</span></span><br><span class="line"><span class="number">0.0000003</span>; <span class="comment">// 3e-7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 否则，就保持原来的字面形式</span></span><br><span class="line"><span class="number">0.000003</span>; <span class="comment">// 0.000003</span></span><br></pre></td></tr></table></figure><ul><li>十进制：没有前导 0 的数值。</li><li>八进制：有前缀 0o 或 0O 的数值，或者有前导 0、且只用到 0-7 的八个阿拉伯数字的数值。</li><li>十六进制：有前缀 0x 或 0X 的数值。</li><li>二进制：有前缀 0b 或 0B 的数值。</li></ul><p>有前导 0 的数值会被视为八进制，但是如果前导 0 后面有数字 8 和 9，则该数值被视为十进制。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">0888</span>; <span class="comment">// 888</span></span><br><span class="line"><span class="number">0777</span>; <span class="comment">// 511</span></span><br></pre></td></tr></table></figure><p>JavaScript 的 64 位浮点数之中，有一个二进制位是符号位。这意味着，任何一个数都有一个对应的负值，就连 0 也不例外。</p><p>JavaScript 内部实际上存在 2 个 0：一个是 +0，一个是 -0，区别就是 64 位浮点数表示法的符号位不同。它们是等价的。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">-0</span> === +<span class="number">0</span>; <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> === <span class="number">-0</span>; <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> === +<span class="number">0</span>; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">+<span class="number">0</span>; <span class="comment">// 0</span></span><br><span class="line"><span class="number">-0</span>; <span class="comment">// 0</span></span><br><span class="line">(<span class="number">-0</span>).toString(); <span class="comment">// '0'</span></span><br><span class="line">(+<span class="number">0</span>).toString(); <span class="comment">// '0'</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> / +<span class="number">0</span> === <span class="number">1</span> / <span class="number">-0</span>; <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// +Infinity !== -Infinity</span></span><br></pre></td></tr></table></figure><p>NaN 是 JavaScript 的特殊值，表示“非数字” Not a Number，主要出现在将字符串解析成数字出错的场合。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span> - <span class="string">"x"</span>; <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.acos(<span class="number">2</span>); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.log(<span class="number">-1</span>); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.sqrt(<span class="number">-1</span>); <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span> / <span class="number">0</span>; <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><p>NaN 不是独立的数据类型，而是一个特殊数值，它的数据类型依然属于 Number。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">NaN</span>; <span class="comment">// 'number'</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span>; <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">[<span class="literal">NaN</span>].indexOf(<span class="literal">NaN</span>); <span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="literal">NaN</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="literal">NaN</span> + <span class="number">32</span>; <span class="comment">// NaN</span></span><br><span class="line"><span class="literal">NaN</span> - <span class="number">32</span>; <span class="comment">// NaN</span></span><br><span class="line"><span class="literal">NaN</span> * <span class="number">32</span>; <span class="comment">// NaN</span></span><br><span class="line"><span class="literal">NaN</span> / <span class="number">32</span>; <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 场景一</span></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">1024</span>);</span><br><span class="line"><span class="comment">// Infinity</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 场景二</span></span><br><span class="line"><span class="number">0</span> / <span class="number">0</span>; <span class="comment">// NaN</span></span><br><span class="line"><span class="number">1</span> / <span class="number">0</span>; <span class="comment">// Infinity</span></span><br><span class="line"></span><br><span class="line"><span class="literal">Infinity</span> === -<span class="literal">Infinity</span>; <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span> / <span class="number">-0</span>; <span class="comment">// -Infinity</span></span><br><span class="line"><span class="number">1</span> / <span class="number">-0</span>; <span class="comment">// Infinity</span></span><br><span class="line"></span><br><span class="line"><span class="literal">Infinity</span> &gt; <span class="number">1000</span>; <span class="comment">// true</span></span><br><span class="line">-<span class="literal">Infinity</span> &lt; <span class="number">-1000</span>; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="literal">Infinity</span> &gt; <span class="literal">NaN</span>; <span class="comment">// false</span></span><br><span class="line">-<span class="literal">Infinity</span> &gt; <span class="literal">NaN</span>; <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="literal">Infinity</span> &lt; <span class="literal">NaN</span>; <span class="comment">// false</span></span><br><span class="line">-<span class="literal">Infinity</span> &lt; <span class="literal">NaN</span>; <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span> * <span class="literal">Infinity</span>; <span class="comment">// Infinity</span></span><br><span class="line"><span class="number">5</span> - <span class="literal">Infinity</span>; <span class="comment">// -Infinity</span></span><br><span class="line"><span class="literal">Infinity</span> / <span class="number">5</span>; <span class="comment">// Infinity</span></span><br><span class="line"><span class="number">5</span> / <span class="literal">Infinity</span>; <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span> * <span class="literal">Infinity</span>; <span class="comment">// NaN</span></span><br><span class="line"><span class="number">0</span> / <span class="literal">Infinity</span>; <span class="comment">// 0</span></span><br><span class="line"><span class="literal">Infinity</span> / <span class="number">0</span>; <span class="comment">// Infinity</span></span><br><span class="line"></span><br><span class="line"><span class="literal">Infinity</span> + <span class="literal">Infinity</span>; <span class="comment">// Infinity</span></span><br><span class="line"><span class="literal">Infinity</span> * <span class="literal">Infinity</span>; <span class="comment">// Infinity</span></span><br><span class="line"></span><br><span class="line"><span class="literal">Infinity</span> - <span class="literal">Infinity</span>; <span class="comment">// NaN</span></span><br><span class="line"><span class="literal">Infinity</span> / <span class="literal">Infinity</span>; <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="literal">null</span> * <span class="literal">Infinity</span>; <span class="comment">// NaN</span></span><br><span class="line"><span class="literal">null</span> / <span class="literal">Infinity</span>; <span class="comment">// 0</span></span><br><span class="line"><span class="literal">Infinity</span> / <span class="literal">null</span>; <span class="comment">// Infinity</span></span><br><span class="line"></span><br><span class="line"><span class="literal">undefined</span> + <span class="literal">Infinity</span>; <span class="comment">// NaN</span></span><br><span class="line"><span class="literal">undefined</span> - <span class="literal">Infinity</span>; <span class="comment">// NaN</span></span><br><span class="line"><span class="literal">undefined</span> * <span class="literal">Infinity</span>; <span class="comment">// NaN</span></span><br><span class="line"><span class="literal">undefined</span> / <span class="literal">Infinity</span>; <span class="comment">// NaN</span></span><br><span class="line"><span class="literal">Infinity</span> / <span class="literal">undefined</span>; <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><h3 id="与数值相关的全局方法"><a href="#与数值相关的全局方法" class="headerlink" title="与数值相关的全局方法"></a>与数值相关的全局方法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">"123"</span>); <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果字符串头部有空格，空格会被自动去除。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">"   81"</span>); <span class="comment">// 81</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果parseInt的参数不是字符串，则会先转为字符串再转换。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">1.23</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">"1.23"</span>); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串转为整数的时候，是一个个字符依次转换，如果遇到不能转为数字的字符，就不再进行下去，返回已经转好的部分。</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">"8a"</span>); <span class="comment">// 8</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">"12**"</span>); <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">"12.34"</span>); <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">"15e2"</span>); <span class="comment">// 15</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">"15px"</span>); <span class="comment">// 15</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果字符串的第一个字符不能转化为数字（后面跟着数字的正负号除外），返回NaN。</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">"abc"</span>); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">".3"</span>); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">""</span>); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">"+"</span>); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">"+1"</span>); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// parseInt的返回值只有两种可能，要么是一个十进制整数，要么是NaN。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">"0x10"</span>); <span class="comment">// 16</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">"011"</span>); <span class="comment">// 11</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对于那些会自动转为科学计数法的数字，parseInt会将科学计数法的表示方法视为字符串，因此导致一些奇怪的结果。</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">1000000000000000000000.5</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">"1e+21"</span>); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">0.0000008</span>); <span class="comment">// 8</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">"8e-7"</span>); <span class="comment">// 8</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">"1000"</span>, <span class="number">2</span>); <span class="comment">// 8</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">"1000"</span>, <span class="number">6</span>); <span class="comment">// 216</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">"1000"</span>, <span class="number">8</span>); <span class="comment">// 512</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二个参数是0、undefined和null，则直接忽略。</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">"10"</span>, <span class="number">37</span>); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">"10"</span>, <span class="number">1</span>); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">"10"</span>, <span class="number">0</span>); <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">"10"</span>, <span class="literal">null</span>); <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">"10"</span>, <span class="literal">undefined</span>); <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">"1546"</span>, <span class="number">2</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">"546"</span>, <span class="number">2</span>); <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果parseInt的第一个参数不是字符串，会被先转为字符串。这会导致一些令人意外的结果。</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">0x11</span>, <span class="number">36</span>); <span class="comment">// 43</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">0x11</span>, <span class="number">2</span>); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="built_in">String</span>(<span class="number">0x11</span>), <span class="number">36</span>); <span class="comment">// 43</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="built_in">String</span>(<span class="number">0x11</span>), <span class="number">2</span>); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">"17"</span>, <span class="number">36</span>); <span class="comment">// 43</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">"17"</span>, <span class="number">2</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 上面代码中，十六进制的0x11会被先转为十进制的17，再转为字符串。然后，再用36进制或二进制解读字符串17，最后返回结果43和1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">011</span>, <span class="number">2</span>); <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="built_in">String</span>(<span class="number">011</span>), <span class="number">2</span>); <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="built_in">String</span>(<span class="number">9</span>), <span class="number">2</span>); <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://wangdoc.com/javascript/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JavaScript 教程 | 网道（WangDoc.com）&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="https://zyf.im/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>GROUP_CONCAT 截断</title>
    <link href="https://zyf.im/2022/01/10/group-concat-max-len/"/>
    <id>https://zyf.im/2022/01/10/group-concat-max-len/</id>
    <published>2022-01-10T07:53:16.000Z</published>
    <updated>2022-07-28T06:38:45.612Z</updated>
    
    <content type="html"><![CDATA[<p>今日在生产环境发生了：因为 <code>GROUP_CONCAT</code> 聚合的数据列发生截断导致异常，原来 <code>GROUP_CONCAT</code> 是有大小限制的。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> @@GROUP_CONCAT_MAX_LEN;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 1024 bytes</span></span><br></pre></td></tr></table></figure><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><blockquote><p><a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_group_concat_max_len" target="_blank" rel="noopener">group_concat_max_len | mysql</a></p></blockquote><p>– EOF –</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今日在生产环境发生了：因为 &lt;code&gt;GROUP_CONCAT&lt;/code&gt; 聚合的数据列发生截断导致异常，原来 &lt;code&gt;GROUP_CONCAT&lt;/code&gt; 是有大小限制的。&lt;/p&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;
      
    
    </summary>
    
    
      <category term="mysql" scheme="https://zyf.im/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>回顾 2021</title>
    <link href="https://zyf.im/2021/12/31/review-2021/"/>
    <id>https://zyf.im/2021/12/31/review-2021/</id>
    <published>2021-12-31T12:16:41.000Z</published>
    <updated>2022-07-28T07:17:05.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://music.163.com/#/song?id=25638375" target="_blank" rel="noopener">直到对的人来 · 追星族乐队</a></p><blockquote><p>我想跟他说：那家餐厅太美了，我一定要和你去一次。但是那个菜其实很一般的，那个老板娘戴的耳环特别漂亮。</p></blockquote><p>– EOF –</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://music.163.com/#/song?id=25638375&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;直到对的人来 · 追星族乐队&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;我想跟他说：那家餐厅太美了，我一定要
      
    
    </summary>
    
      <category term="review" scheme="https://zyf.im/categories/review/"/>
    
    
  </entry>
  
  <entry>
    <title>PHP 安装 gRPC</title>
    <link href="https://zyf.im/2021/10/13/php-install-grpc/"/>
    <id>https://zyf.im/2021/10/13/php-install-grpc/</id>
    <published>2021-10-13T07:48:41.000Z</published>
    <updated>2021-10-13T08:49:58.181Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat /etc/redhat-release</span><br><span class="line"></span><br><span class="line">CentOS Linux release 7.2 (Final)</span><br><span class="line"></span><br><span class="line">uname -a</span><br><span class="line">Linux xxx-xxx 3.10.107-1-tlinux2_kvm_guest-0052 <span class="comment">#1 SMP Wed Jan 15 18:42:19 CST 2020 x86_64 x86_64 x86_64 GNU/Linux</span></span><br></pre></td></tr></table></figure><h2 id="PECL"><a href="#PECL" class="headerlink" title="PECL"></a>PECL</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pecl install grpc</span><br></pre></td></tr></table></figure><p>如果遇到：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Connection to `ssl://pecl.php.net:443′ failed:</span><br></pre></td></tr></table></figure><p>参考：</p><p><a href="/2020/08/07/deploy-swoft-framework/">PHP Swoft 框架环境配置 | ZYF.IM</a></p><h2 id="Build"><a href="#Build" class="headerlink" title="Build"></a>Build</h2><h3 id="通用手动安装-PECL-扩展"><a href="#通用手动安装-PECL-扩展" class="headerlink" title="通用手动安装 PECL 扩展"></a>通用手动安装 PECL 扩展</h3><p>For this to work, you’ll need to have root access to your server, and you’ll most probably need developer tools installed as well.</p><blockquote><p><a href="https://pecl.php.net/" target="_blank" rel="noopener">https://pecl.php.net/</a></p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建临时目录</span></span><br><span class="line">mkdir /tmp/download/ &amp;&amp; <span class="built_in">cd</span> /tmp/download/</span><br><span class="line"><span class="comment"># 下载</span></span><br><span class="line">wget http://pecl.php.net/get/[extension].tgz</span><br><span class="line"><span class="comment"># 解压</span></span><br><span class="line">tar -xvf [extension].tgz</span><br><span class="line"><span class="built_in">cd</span> [extension]</span><br><span class="line"><span class="comment"># 配置</span></span><br><span class="line">phpize</span><br><span class="line"><span class="comment"># 查看参数</span></span><br><span class="line">./configure --<span class="built_in">help</span></span><br><span class="line"><span class="comment"># 设置参考 以实际情况为准</span></span><br><span class="line">./configure --<span class="built_in">enable</span>-[extension]</span><br><span class="line"><span class="comment"># 编译</span></span><br><span class="line">make &amp;&amp; make <span class="built_in">test</span></span><br><span class="line"><span class="comment"># 安装</span></span><br><span class="line">make install</span><br><span class="line"><span class="comment"># 查看 ini 路径</span></span><br><span class="line">php --ini</span><br><span class="line"><span class="comment"># 开启</span></span><br><span class="line">vi [php-ini].ini</span><br><span class="line">extension=[extension].so</span><br></pre></td></tr></table></figure><h3 id="gcc-is-currently-not-installed"><a href="#gcc-is-currently-not-installed" class="headerlink" title="gcc is currently not installed"></a>gcc is currently not installed</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install gcc</span><br><span class="line"></span><br><span class="line">...already installed and latest version...</span><br><span class="line"></span><br><span class="line">gcc</span><br><span class="line"></span><br><span class="line">...gcc is currently not installed.</span><br><span class="line"></span><br><span class="line">yum reinstall gcc</span><br><span class="line"><span class="comment"># 重新安装后解决</span></span><br></pre></td></tr></table></figure><h3 id="GrpcLb-TokenAndClientStatsAttribute-ToString-const"><a href="#GrpcLb-TokenAndClientStatsAttribute-ToString-const" class="headerlink" title="GrpcLb::TokenAndClientStatsAttribute::ToString() const"></a>GrpcLb::TokenAndClientStatsAttribute::ToString() const</h3><p>原因：gcc 版本过低。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install centos-release-scl</span><br><span class="line"></span><br><span class="line">yum install devtoolset-8-gcc*</span><br><span class="line"></span><br><span class="line">scl <span class="built_in">enable</span> devtoolset-8 bash</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> /opt/rh/devtoolset-8/<span class="built_in">enable</span></span><br></pre></td></tr></table></figure><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://cloud.google.com/php/grpc" target="_blank" rel="noopener">安装适用于 PHP 的 gRPC | cloud.google</a></li><li><a href="https://www.jianshu.com/p/387b7a46d9fd" target="_blank" rel="noopener">PHP 安装 grpc 扩展报错 | jianshu</a></li></ul><p>– EOF –</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ENV&quot;&gt;&lt;a href=&quot;#ENV&quot; class=&quot;headerlink&quot; title=&quot;ENV&quot;&gt;&lt;/a&gt;ENV&lt;/h2&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span
      
    
    </summary>
    
    
      <category term="php" scheme="https://zyf.im/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>分组聚合 OVER PARTITION BY</title>
    <link href="https://zyf.im/2021/09/14/sql-over-partition-by/"/>
    <id>https://zyf.im/2021/09/14/sql-over-partition-by/</id>
    <published>2021-09-14T03:58:42.000Z</published>
    <updated>2022-07-28T06:40:49.628Z</updated>
    
    <content type="html"><![CDATA[<h2 id="在-HIVE-中"><a href="#在-HIVE-中" class="headerlink" title="在 HIVE 中"></a>在 HIVE 中</h2><p>最近在使用 HIVE，需要统计 <code>当年累计和</code> 这样的指标，请教同事后发现了 <code>OVER(PARTITION BY)</code> 开窗函数。</p><p>分析函数用于计算基于组的某种聚合值，它和聚合函数的不同之处是：对于每个组返回多行，而聚合函数对于每个组只返回一行。</p><p>开窗函数指定了分析函数工作的数据窗口大小，这个数据窗口大小可能会随着行的变化而变化。</p><p>测试语句：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> default.test_over_partition (</span><br><span class="line">  <span class="string">`fdate`</span> <span class="built_in">Date</span>,</span><br><span class="line">  <span class="string">`year`</span> <span class="built_in">Int</span>,</span><br><span class="line">  <span class="string">`month`</span> <span class="built_in">Int</span>,</span><br><span class="line">  <span class="string">`category1`</span> <span class="keyword">String</span>,</span><br><span class="line">  <span class="string">`category2`</span> <span class="keyword">String</span>,</span><br><span class="line">  <span class="string">`income`</span> <span class="keyword">Double</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> hdp_fin_dash_ods.test_over_partition (<span class="string">`fdate`</span>,<span class="string">`year`</span>,<span class="string">`month`</span>,<span class="string">`category1`</span>,<span class="string">`category2`</span>,<span class="string">`income`</span>) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="string">'2020-01-01'</span>,<span class="number">2020</span>,<span class="number">1</span>,<span class="string">'3C'</span>,<span class="string">'电脑'</span>,<span class="string">'1010'</span>),</span><br><span class="line">(<span class="string">'2020-01-01'</span>,<span class="number">2020</span>,<span class="number">1</span>,<span class="string">'3C'</span>,<span class="string">'手机'</span>,<span class="string">'1011'</span>),</span><br><span class="line">(<span class="string">'2020-02-01'</span>,<span class="number">2020</span>,<span class="number">2</span>,<span class="string">'3C'</span>,<span class="string">'电脑'</span>,<span class="string">'1012'</span>),</span><br><span class="line">(<span class="string">'2020-02-01'</span>,<span class="number">2020</span>,<span class="number">2</span>,<span class="string">'3C'</span>,<span class="string">'手机'</span>,<span class="string">'1013'</span>),</span><br><span class="line">(<span class="string">'2020-03-01'</span>,<span class="number">2020</span>,<span class="number">3</span>,<span class="string">'3C'</span>,<span class="string">'电脑'</span>,<span class="string">'1014'</span>),</span><br><span class="line">(<span class="string">'2020-03-01'</span>,<span class="number">2020</span>,<span class="number">3</span>,<span class="string">'3C'</span>,<span class="string">'手机'</span>,<span class="string">'1015'</span>),</span><br><span class="line">(<span class="string">'2021-04-01'</span>,<span class="number">2021</span>,<span class="number">4</span>,<span class="string">'3C'</span>,<span class="string">'电脑'</span>,<span class="string">'1016'</span>),</span><br><span class="line">(<span class="string">'2021-04-01'</span>,<span class="number">2021</span>,<span class="number">4</span>,<span class="string">'3C'</span>,<span class="string">'手机'</span>,<span class="string">'1017'</span>),</span><br><span class="line">(<span class="string">'2021-05-01'</span>,<span class="number">2021</span>,<span class="number">5</span>,<span class="string">'3C'</span>,<span class="string">'电脑'</span>,<span class="string">'1018'</span>),</span><br><span class="line">(<span class="string">'2021-05-01'</span>,<span class="number">2021</span>,<span class="number">5</span>,<span class="string">'3C'</span>,<span class="string">'手机'</span>,<span class="string">'1019'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询每年每 category2 日累计 income</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">`fdate`</span>,<span class="string">`year`</span>,<span class="string">`month`</span>,<span class="string">`category1`</span>,<span class="string">`category2`</span>,<span class="string">`income`</span></span><br><span class="line">,<span class="keyword">SUM</span>(income) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="string">`year`</span>,<span class="string">`category1`</span>,<span class="string">`category2`</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> fdate) <span class="keyword">AS</span> ttl_year_income</span><br><span class="line"><span class="keyword">FROM</span> hdp_fin_dash_ods.test_over_partition;</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/9289792/133225004-be0d2c88-e713-407b-b41d-da44e16ac960.png"></p><h2 id="在-MySQL-中"><a href="#在-MySQL-中" class="headerlink" title="在 MySQL 中"></a>在 MySQL 中</h2><blockquote><p>Before MySQL 8.0 you can’t use window functions like ROW_NUMBER.</p></blockquote><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://www.cnblogs.com/zhwbqd/p/4205821.html" target="_blank" rel="noopener">Mysql 分组聚合实现 over partition by 功能 | cnblogs</a></li><li><a href="https://stackoverflow.com/questions/58645949/emulating-partition-over-with-mysql-5-7" target="_blank" rel="noopener">Emulating PARTITION OVER with MySQL 5.7 | stackoverflow</a></li></ul><p>– EOF –</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;在-HIVE-中&quot;&gt;&lt;a href=&quot;#在-HIVE-中&quot; class=&quot;headerlink&quot; title=&quot;在 HIVE 中&quot;&gt;&lt;/a&gt;在 HIVE 中&lt;/h2&gt;&lt;p&gt;最近在使用 HIVE，需要统计 &lt;code&gt;当年累计和&lt;/code&gt; 这样的指标，请教同事后
      
    
    </summary>
    
    
      <category term="sql" scheme="https://zyf.im/tags/sql/"/>
    
      <category term="hive" scheme="https://zyf.im/tags/hive/"/>
    
  </entry>
  
  <entry>
    <title>PHP __invoke 使用</title>
    <link href="https://zyf.im/2021/07/20/php-invoke-is-anybody-using-it/"/>
    <id>https://zyf.im/2021/07/20/php-invoke-is-anybody-using-it/</id>
    <published>2021-07-20T06:58:33.000Z</published>
    <updated>2021-10-13T08:45:42.571Z</updated>
    
    <content type="html"><![CDATA[<p>why they are magic? Because they are magically called by PHP when specific actions happen.</p><p>The <code>__invoke()</code> method is called when a script tries to call an object as a function.</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CallableClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__invoke</span><span class="params">($x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        var_dump($x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$obj = <span class="keyword">new</span> CallableClass;</span><br><span class="line">$obj(<span class="number">5</span>);</span><br><span class="line">var_dump(is_callable($obj));</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int(5)</span><br><span class="line">bool(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure><h2 id="使用明显的操作方法初始化"><a href="#使用明显的操作方法初始化" class="headerlink" title="使用明显的操作方法初始化"></a>使用明显的操作方法初始化</h2><p>例如，当我们有一个提供者时，就会发生这种情况。</p><p><a href="https://github.com/aws/aws-sdk-php/blob/master/src/Endpoint/PatternEndpointProvider.php" target="_blank" rel="noopener">aws-sdk-php/src/Endpoint/PatternEndpointProvider.php</a></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__invoke</span><span class="params">(array $args = [])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $service = <span class="keyword">isset</span>($args[<span class="string">'service'</span>]) ? $args[<span class="string">'service'</span>] : <span class="string">''</span>;</span><br><span class="line">    $region = <span class="keyword">isset</span>($args[<span class="string">'region'</span>]) ? $args[<span class="string">'region'</span>] : <span class="string">''</span>;</span><br><span class="line">    $keys = [<span class="string">"&#123;$region&#125;/&#123;$service&#125;"</span>, <span class="string">"&#123;$region&#125;/*"</span>, <span class="string">"*/&#123;$service&#125;"</span>, <span class="string">"*/*"</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> ($keys <span class="keyword">as</span> $key) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;patterns[$key])) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;expand(</span><br><span class="line">                <span class="keyword">$this</span>-&gt;patterns[$key],</span><br><span class="line">                <span class="keyword">isset</span>($args[<span class="string">'scheme'</span>]) ? $args[<span class="string">'scheme'</span>] : <span class="string">'https'</span>,</span><br><span class="line">                $service,</span><br><span class="line">                $region</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它使用 invoke 使用一些参数提供端点。我们如何使用这个类？</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testReturnsNullWhenUnresolved</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $e = <span class="keyword">new</span> PatternEndpointProvider([<span class="string">'foo'</span> =&gt; [<span class="string">'rules'</span> =&gt; []]]);</span><br><span class="line">    <span class="keyword">$this</span>-&gt;assertNull($e([<span class="string">'service'</span> =&gt; <span class="string">'foo'</span>, <span class="string">'region'</span> =&gt; <span class="string">'bar'</span>]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="尝试使用单动作控制器？"><a href="#尝试使用单动作控制器？" class="headerlink" title="尝试使用单动作控制器？"></a>尝试使用单动作控制器？</h2><p>控制器应该大而广泛？他们不应该。我们应该有瘦控制器和胖服务。</p><p>在这里，invoke 可以帮助我们，因为我们可以定义一个只处理单个动作的控制器，并在其上放置单个 invoke 方法。</p><p>这也有助于我们实现单一职责原则，即 SOLID 中的 S，这是前五个面向对象设计 (OOD) 原则的首字母缩写词。</p><blockquote><p>A class should have one and only one reason to change, meaning that a class should have only one job.</p></blockquote><p>在 Laravel 中的例子：<a href="https://laravel.com/docs/5.7/controllers#single-action-controllers" target="_blank" rel="noopener">Single Action Controllers | laravel</a>：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">App</span>\<span class="title">Http</span>\<span class="title">Controllers</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">App</span>\<span class="title">User</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">App</span>\<span class="title">Http</span>\<span class="title">Controllers</span>\<span class="title">Controller</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShowProfile</span> <span class="keyword">extends</span> <span class="title">Controller</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Show the profile for the given user.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  int  $id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> View</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__invoke</span><span class="params">($id)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> view(<span class="string">'user.profile'</span>, [<span class="string">'user'</span> =&gt; User::findOrFail($id)]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，在注册路由时，我们不需要指定方法名称。只有类名。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">Route::get(<span class="string">'user/&#123;id&#125;'</span>, <span class="string">'ShowProfile'</span>);</span><br></pre></td></tr></table></figure><p>This way we can have Single Action Controllers.</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://luis-barros-nobrega.medium.com/php-invoke-is-anybody-using-it-1933c64d17f1" target="_blank" rel="noopener">PHP invoke: is anybody using it? | medium</a></li><li><a href="https://www.php.net/manual/en/language.oop5.magic.php#object.invoke" target="_blank" rel="noopener">__invoke() | php</a></li></ul><p>– EOF –</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;why they are magic? Because they are magically called by PHP when specific actions happen.&lt;/p&gt;&lt;p&gt;The &lt;code&gt;__invoke()&lt;/code&gt; method is ca
      
    
    </summary>
    
    
      <category term="php" scheme="https://zyf.im/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>PHP strict_types 严格模式</title>
    <link href="https://zyf.im/2021/07/19/php-strict-types/"/>
    <id>https://zyf.im/2021/07/19/php-strict-types/</id>
    <published>2021-07-19T11:58:26.000Z</published>
    <updated>2021-10-13T08:46:06.340Z</updated>
    
    <content type="html"><![CDATA[<ul><li>严格模式的声明 _必须_ 放在文件的顶部。</li><li>严格模式不仅作用于函数参数的类型声明，也作用于函数的返回值类型。</li></ul><p>声明 PHP 文件作为严格模式的一个好事是，实际上只适用于当前文件。这确保了这个文件是严格类型，但是他没有影响到整个项目中的其他文件。这允许你一步一步的迁移非严格模式的代码。</p><p>使用提示类型没有 strict_types 可能导致微妙的错误。</p><p>严格类型之前，<code>int $x</code> 意味着 <code>$x must have a value coercible to an int</code>。</p><ul><li>a float (example: 13.1459 -&gt; 13)</li><li>a bool (example: true -&gt; 1)</li><li>a null (example: null -&gt; 0)</li><li>a string with leading digits (example: “15 Trees” -&gt; 15)</li></ul><p>设置严格模式后，you tell the engine that <code>int $x</code> means <code>$x must only be an int proper, no type coercion allowed</code>。</p><p>谁给更关心 <code>strict_type</code> 这行？is more for the reader than for the writer. Why? Bacause it will explicitly tell the reader:</p><p>The types in this current scope are treated strictly.</p><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">(int $a, int $b)</span>: <span class="title">int</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> $a + $b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var_dump(add(<span class="number">1.0</span>, <span class="number">2.0</span>));</span><br></pre></td></tr></table></figure><p>运行输出 <code>int(3)</code>。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">declare</span>(strict_types=<span class="number">1</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">(int $a, int $b)</span>: <span class="title">int</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> $a + $b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var_dump(add(<span class="number">1.0</span>, <span class="number">2.0</span>));</span><br></pre></td></tr></table></figure><p>运行输出：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PHP Fatal error:  Uncaught TypeError: Argument 1 passed to add() must be of the <span class="built_in">type</span> int, <span class="built_in">float</span> given, ...</span><br></pre></td></tr></table></figure><h2 id="声明位置"><a href="#声明位置" class="headerlink" title="声明位置"></a>声明位置</h2><p>必须在脚本最前。不能写在脚本的中间，如下写法是错误的：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">(int $a, int $b)</span>: <span class="title">int</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> $a + $b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">declare</span>(strict_types=<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">var_dump(add(<span class="number">1.0</span>, <span class="number">2.0</span>));</span><br></pre></td></tr></table></figure><p>运行后报错：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PHP Fatal error:  strict_types declaration must be the very first statement <span class="keyword">in</span> the script <span class="keyword">in</span> ...</span><br></pre></td></tr></table></figure><p>不得使用 block mode 进行声明：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">declare</span>(strict_types=<span class="number">1</span>) &#123;</span><br><span class="line">  var_dump(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后报错：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PHP Fatal error:  strict_types declaration must not use block mode <span class="keyword">in</span> ...</span><br></pre></td></tr></table></figure><h2 id="多文件场景"><a href="#多文件场景" class="headerlink" title="多文件场景"></a>多文件场景</h2><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子 1"></a>例子 1</h3><p><code>A.php</code></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// 严格模式</span></span><br><span class="line"><span class="keyword">declare</span>(strict_types=<span class="number">1</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">(int $a, int $b)</span>: <span class="title">int</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> $a + $b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>B.php</code></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// 非严格模式</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">'A.php'</span>;</span><br><span class="line"><span class="comment">// 违反了 A 的定义</span></span><br><span class="line">var_dump(add(<span class="number">1.0</span>, <span class="number">2.0</span>));</span><br></pre></td></tr></table></figure><p>运行</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">php B.php</span><br><span class="line"></span><br><span class="line">int(3)</span><br></pre></td></tr></table></figure><h3 id="例子-2"><a href="#例子-2" class="headerlink" title="例子 2"></a>例子 2</h3><p><code>A.php</code></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// 非严格模式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">(int $a, int $b)</span>: <span class="title">int</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> $a + $b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>B.php</code></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// 严格模式</span></span><br><span class="line"><span class="keyword">declare</span>(strict_types=<span class="number">1</span>);</span><br><span class="line"><span class="keyword">require</span> <span class="string">'A.php'</span>;</span><br><span class="line"><span class="comment">// 违反了 A 的定义</span></span><br><span class="line">var_dump(add(<span class="number">1.0</span>, <span class="number">2.0</span>));</span><br></pre></td></tr></table></figure><p>运行</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">php B.php</span><br><span class="line"></span><br><span class="line">PHP Fatal error:  Uncaught TypeError: Argument 1 passed to add() must be of the <span class="built_in">type</span> int, <span class="built_in">float</span> given, called <span class="keyword">in</span> ...</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>函数定义时的严格模式，行为并不会出现什么不同。</li><li>函数执行时的，严格模式会出现差异。</li><li><code>declare(strict_types=1);</code> 的声明本身在 A.php 文件中完成。被 B.php 文件 require，而 B.php 并没有定义严格模式，那么执行 require 的 B.php 文件不会变成严格模式。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>只有在写 declare 的文件的执行部分才会执行严格模式，该文件中调用的其它函数（其它文件中的函数）也会被影响。</p><p>若果想完全使用严格模式，比较简单的方法是在所有 php 文件都写上 <code>declare(strict_types=1);</code>。</p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>推荐自动格式化工具：<a href="https://github.com/symplify/easy-coding-standard" target="_blank" rel="noopener">symplify/easy-coding-standard</a>。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://segmentfault.com/a/1190000018389227" target="_blank" rel="noopener">关于 declare(strict_types=1) 的有效范围 | segmentfault</a></li><li><a href="https://chemaclass.medium.com/strict-types-in-php-d4166bd25394" target="_blank" rel="noopener">Strict Types in PHP | medium</a></li><li><a href="https://www.php.net/manual/en/migration70.new-features.php#migration70.new-features.scalar-type-declarations" target="_blank" rel="noopener">Scalar type declarations | php</a></li><li><a href="https://www.php.net/manual/en/language.types.declarations.php#language.types.declarations.strict" target="_blank" rel="noopener">Strict typing | php</a></li></ul><p>– EOF –</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;&lt;li&gt;严格模式的声明 _必须_ 放在文件的顶部。&lt;/li&gt;&lt;li&gt;严格模式不仅作用于函数参数的类型声明，也作用于函数的返回值类型。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;声明 PHP 文件作为严格模式的一个好事是，实际上只适用于当前文件。这确保了这个文件是严格类型，但是他没有影响到整
      
    
    </summary>
    
    
      <category term="php" scheme="https://zyf.im/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>Git and GitHub Secrets</title>
    <link href="https://zyf.im/2021/07/12/git-and-github-secrets/"/>
    <id>https://zyf.im/2021/07/12/git-and-github-secrets/</id>
    <published>2021-07-12T02:40:15.000Z</published>
    <updated>2021-07-19T10:05:21.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="记住密码"><a href="#记住密码" class="headerlink" title="记住密码"></a>记住密码</h2><p>Git 记住密码配置后，不用每次 pull、push 都需要输入密码：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global credential.helper store</span><br></pre></td></tr></table></figure><p>会在 <code>cat ~/.gitconfig</code> 看到：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[credential]</span><br><span class="line">    helper = store</span><br></pre></td></tr></table></figure><h2 id="快速检出上一个分支"><a href="#快速检出上一个分支" class="headerlink" title="快速检出上一个分支"></a>快速检出上一个分支</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -</span><br></pre></td></tr></table></figure><h2 id="提交空改动"><a href="#提交空改动" class="headerlink" title="提交空改动"></a>提交空改动</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit -m <span class="string">"empty commit"</span> --allow-empty</span><br></pre></td></tr></table></figure><p>在如下几种情况下是有意义：</p><ul><li>标记一批工作或一个新功能的开始。</li><li>记录你对项目进行了跟代码无关的改动。</li><li>跟使用你仓库的其他人交流。</li><li>作为仓库的第一次提交，因为第一次提交日后是不能被 rebase 的：<code>git commit -m &quot;init repo&quot; --allow-empty</code>。</li></ul><h2 id="更直观的-status"><a href="#更直观的-status" class="headerlink" title="更直观的 status"></a>更直观的 status</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git status -sb</span><br></pre></td></tr></table></figure><h2 id="更直观的-log"><a href="#更直观的-log" class="headerlink" title="更直观的 log"></a>更直观的 log</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --all --graph --pretty=format:<span class="string">'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an %ae&gt;%Creset'</span> --abbrev-commit --date=relative</span><br></pre></td></tr></table></figure><h2 id="提交信息查询"><a href="#提交信息查询" class="headerlink" title="提交信息查询"></a>提交信息查询</h2><p>找到其中和搜索条件相匹配的最近的一条。query （区别大小写）是你想要搜索的词语。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git show :/query</span><br></pre></td></tr></table></figure><h2 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h2><p>显示所有已经合并到你当前分支的分支列表：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch --merged</span><br></pre></td></tr></table></figure><p>相反地：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch --no-merged</span><br></pre></td></tr></table></figure><h2 id="gitconfig"><a href="#gitconfig" class="headerlink" title=".gitconfig"></a>.gitconfig</h2><p>打开编辑：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim ~/.gitconfig</span><br></pre></td></tr></table></figure><p>命令修改：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global alias.co <span class="string">'checkout'</span></span><br><span class="line">git config --global alias.ac <span class="string">'add -A . &amp;&amp; commit'</span></span><br><span class="line">git config --global alias.lg <span class="string">"log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an %ae&gt;%Creset' --abbrev-commit"</span></span><br></pre></td></tr></table></figure><h2 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h2><h3 id="整行高亮"><a href="#整行高亮" class="headerlink" title="整行高亮"></a>整行高亮</h3><p>多行高亮也可以，比如用 #L53-L60 选择范围，或者按住 shift 键，然后再点击选择的两行。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">https://github.com/rails/rails/blob/master/activemodel/lib/active_model.rb<span class="comment">#L53-L60</span></span><br></pre></td></tr></table></figure><h3 id="用-commit-信息关闭-issue"><a href="#用-commit-信息关闭-issue" class="headerlink" title="用 commit 信息关闭 issue"></a>用 commit 信息关闭 issue</h3><p>如果某个提交修复了一个 Issue，当提交到 master 分支时，提交信息里可以使用 fix/fixes/fixed , close/closes/closed 或者 resolve/resolves/resolved 等关键词，后面再跟上 Issue 号，这样就会关闭这个 Issue。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit -m <span class="string">"Fix screwup, fixes #12"</span></span><br></pre></td></tr></table></figure><h3 id="链接其他仓库的-Issue"><a href="#链接其他仓库的-Issue" class="headerlink" title="链接其他仓库的 Issue"></a>链接其他仓库的 Issue</h3><p>如果你想引用到同一个仓库中的一个 Issue，只需使用井号 # 加上 Issue 号，这样就会自动创建到此 Issue 的链接。</p><p>要链接到其他仓库的 Issue，就使用 <code>user_name/repo_name#ISSUE_NUMBER</code> 的方式，例如 <code>tiimgreen/toc#12</code>。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://speakerdeck.com/holman/git-and-github-secrets" target="_blank" rel="noopener">Git and GitHub Secrets | speakerdeck</a></li><li><a href="https://speakerdeck.com/holman/more-git-and-github-secrets" target="_blank" rel="noopener">More Git and GitHub Secrets | speakerdeck</a></li></ul><p>– EOF –</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;记住密码&quot;&gt;&lt;a href=&quot;#记住密码&quot; class=&quot;headerlink&quot; title=&quot;记住密码&quot;&gt;&lt;/a&gt;记住密码&lt;/h2&gt;&lt;p&gt;Git 记住密码配置后，不用每次 pull、push 都需要输入密码：&lt;/p&gt;&lt;figure class=&quot;highligh
      
    
    </summary>
    
    
      <category term="git" scheme="https://zyf.im/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>如何做好技术协同及管理</title>
    <link href="https://zyf.im/2021/07/08/how-to-do-technical-management/"/>
    <id>https://zyf.im/2021/07/08/how-to-do-technical-management/</id>
    <published>2021-07-08T13:08:08.000Z</published>
    <updated>2022-09-15T06:31:56.840Z</updated>
    
    <content type="html"><![CDATA[<p>《如何做好技术协同及管理 —— 合作伙伴篇》一次沙龙后的笔记。</p><h2 id="招人"><a href="#招人" class="headerlink" title="招人"></a>招人</h2><ul><li>注重招人环节；在这一步要卡严，因为入职后再折腾就更费时费力了。</li><li>要关注的点：基础水平（工程能力）、离职原因（是否能长久）、个人性格（气场是否相合）。</li></ul><h2 id="入职"><a href="#入职" class="headerlink" title="入职"></a>入职</h2><ul><li>主动沟通是重要的特质。还有责任心、可塑性、执行力。</li><li>前紧后松；前期要做 code review，养成好习惯。</li><li>关注测试同学以及其他同学对其的反馈。了解工作状态、质量。</li><li>在突破底线后应该当机立断，无需心存幻想。</li></ul><h2 id="心态"><a href="#心态" class="headerlink" title="心态"></a>心态</h2><ul><li>没有归宿感；owner 意识。</li><li>每一位都是组内的一员。</li></ul><h2 id="管理"><a href="#管理" class="headerlink" title="管理"></a>管理</h2><ul><li>早会；任务安排，跟踪进度。不能不闻不问，最后容易抓瞎。</li><li>超过 30min 解决不了的问题，直接沟通，避免团队时间的浪费。</li><li>读书会，组内分享；打造一个好的技术氛围，这里不只是工作，还能成长。</li><li>要对任务的工作量有判断；并且明确开发规模，并且进行核对，防止 “大事小做，小题大做”。</li><li>通过先编写好单元测试、框架结构、interface，控制需求实现、代码质量。</li><li>在无法进行横向对比的情况下，可以对比加入前后是否释放自身生产力来进行判断。</li><li>三个卡点：需求评审、技术实现评审、测试用例评审，把关质量。</li></ul><p>– EOF –</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;《如何做好技术协同及管理 —— 合作伙伴篇》一次沙龙后的笔记。&lt;/p&gt;&lt;h2 id=&quot;招人&quot;&gt;&lt;a href=&quot;#招人&quot; class=&quot;headerlink&quot; title=&quot;招人&quot;&gt;&lt;/a&gt;招人&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;注重招人环节；在这一步要卡严，因为入职后再折腾就更费时
      
    
    </summary>
    
    
      <category term="report" scheme="https://zyf.im/tags/report/"/>
    
  </entry>
  
  <entry>
    <title>【设计模式之美】笔记 Part 2</title>
    <link href="https://zyf.im/2021/02/06/the-beauty-of-design-patterns-reading-notes-part2/"/>
    <id>https://zyf.im/2021/02/06/the-beauty-of-design-patterns-reading-notes-part2/</id>
    <published>2021-02-06T03:00:41.000Z</published>
    <updated>2021-07-22T06:49:38.772Z</updated>
    
    <content type="html"><![CDATA[<h2 id="11"><a href="#11" class="headerlink" title="11"></a>11</h2><p>领域驱动设计（Domain Driven Design，简称 DDD）。</p><h3 id="什么是基于贫血模型的传统开发模式？"><a href="#什么是基于贫血模型的传统开发模式？" class="headerlink" title="什么是基于贫血模型的传统开发模式？"></a>什么是基于贫血模型的传统开发模式？</h3><p>UserEntity 和 UserRepository 组成了数据访问层，UserBo 和 UserService 组成了业务逻辑层，UserVo 和 UserController 在这里属于接口层。</p><p>Service 层的数据和业务逻辑，被分割为 BO 和 Service 两个类中。像 UserBo 这样，只包含数据，不包含业务逻辑的类，就叫作贫血模型（Anemic Domain Model）。</p><p>这种贫血模型将数据与操作分离，破坏了面向对象的封装特性，是一种典型的面向过程的编程风格。</p><h3 id="什么是基于充血模型的-DDD-开发模式？"><a href="#什么是基于充血模型的-DDD-开发模式？" class="headerlink" title="什么是基于充血模型的 DDD 开发模式？"></a>什么是基于充血模型的 DDD 开发模式？</h3><p>领域驱动设计，即 DDD，主要是用来指导如何解耦业务系统，划分业务模块，定义业务领域模型及其交互。</p><p>基于贫血模型的传统的开发模式，重 Service 轻 BO；基于充血模型的 DDD 开发模式，轻 Service 重 Domain。</p><h3 id="为什么基于贫血模型的传统开发模式如此受欢迎？"><a href="#为什么基于贫血模型的传统开发模式如此受欢迎？" class="headerlink" title="为什么基于贫血模型的传统开发模式如此受欢迎？"></a>为什么基于贫血模型的传统开发模式如此受欢迎？</h3><ul><li>系统业务可能都比较简单，简单到就是基于 SQL 的 CRUD 操作</li><li>充血模型的设计要比贫血模型更加有难度。我们从一开始就要设计好针对数据要暴露哪些操作，定义哪些业务逻辑。而不是像贫血模型那样，我们只需要定义数据，之后有什么功能开发需求，我们就在 Service 层定义什么操作，不需要事先做太多设计。</li><li>思维已固化，转型有成本。</li></ul><h3 id="什么项目应该考虑使用基于充血模型的-DDD-开发模式？"><a href="#什么项目应该考虑使用基于充血模型的-DDD-开发模式？" class="headerlink" title="什么项目应该考虑使用基于充血模型的 DDD 开发模式？"></a>什么项目应该考虑使用基于充血模型的 DDD 开发模式？</h3><p>适合业务复杂的系统开发。比如，包含各种利息计算模型、还款模型等复杂业务的金融系统。</p><p>两种不同的开发模式会导致不同的开发流程。基于充血模型的 DDD 开发模式的开发流程，在应对复杂业务系统的开发的时候更加有优势。</p><p>DDD 这种开发模式下，我们需要事先理清楚所有的业务，定义领域模型所包含的属性和方法。领域模型相当于可复用的业务中间层。新功能需求的开发，都基于之前定义好的这些领域模型来完成。</p><h2 id="12"><a href="#12" class="headerlink" title="12"></a>12</h2><h3 id="一个虚拟钱包系统"><a href="#一个虚拟钱包系统" class="headerlink" title="一个虚拟钱包系统"></a>一个虚拟钱包系统</h3><p>充值、提现、支付、查询余额、查询交易流水。甚至还有冻结、透支、转赠等。</p><p>整个钱包系统一部分单纯跟应用内的虚拟钱包账户打交道，另一部分单纯跟银行账户打交道。我们基于这样一个业务划分，给系统解耦，将整个钱包系统拆分为两个子系统：虚拟钱包系统和三方支付系统。</p><p><img src="https://user-images.githubusercontent.com/9289792/107135323-ba50b780-6934-11eb-8b85-1738440f42bc.png" alt="image"></p><p>不保证数据的强一致性，只实现数据的最终一致性。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VirtualWalletService</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 通过构造函数或者 IOC 框架注入</span></span><br><span class="line">  <span class="keyword">private</span> VirtualWalletRepository walletRepo;</span><br><span class="line">  <span class="keyword">private</span> VirtualWalletTransactionRepository transactionRepo;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> VirtualWallet <span class="title">getVirtualWallet</span><span class="params">(Long walletId )</span> </span>&#123;</span><br><span class="line">    VirtualWalletEntity walletEntity = walletRepo.getWalletEntity(walletId);</span><br><span class="line">    VirtualWallet wallet = convert(walletEntity);</span><br><span class="line">    <span class="keyword">return</span> wallet;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> BigDecimal <span class="title">getBalance</span><span class="params">(Long walletId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> virtualWalletRepo.getBalance(walletId);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">debit</span><span class="params">(Long walletId, BigDecimal amount)</span> </span>&#123;</span><br><span class="line">    VirtualWalletEntity walletEntity = walletRepo.getWalletEntity(walletId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 贫血型</span></span><br><span class="line">    <span class="comment">// BigDecimal balance = walletEntity.getBalance();</span></span><br><span class="line">    <span class="comment">// if (balance.compareTo(amount) &lt; 0) &#123;</span></span><br><span class="line">    <span class="comment">//   throw new NoSufficientBalanceException(...);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// walletRepo.updateBalance(walletId, balance.subtract(amount));</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// DDD</span></span><br><span class="line">    VirtualWallet wallet = convert(walletEntity);</span><br><span class="line">    wallet.debit(amount);</span><br><span class="line">    walletRepo.updateBalance(walletId, wallet.balance());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">credit</span><span class="params">(Long walletId, BigDecimal amount)</span> </span>&#123;</span><br><span class="line">    VirtualWalletEntity walletEntity = walletRepo.getWalletEntity(walletId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 贫血型</span></span><br><span class="line">    <span class="comment">// BigDecimal balance = walletEntity.getBalance();</span></span><br><span class="line">    <span class="comment">// walletRepo.updateBalance(walletId, balance.add(amount));</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// DDD</span></span><br><span class="line">    VirtualWallet wallet = convert(walletEntity);</span><br><span class="line">    wallet.credit(amount);</span><br><span class="line">    walletRepo.updateBalance(walletId, wallet.balance());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Long fromWalletId, Long toWalletId, BigDecimal amount)</span> </span>&#123;</span><br><span class="line">    VirtualWalletTransactionEntity transactionEntity = <span class="keyword">new</span> VirtualWalletTransactionEntity();</span><br><span class="line">    transactionEntity.setAmount(amount);</span><br><span class="line">    transactionEntity.setCreateTime(System.currentTimeMillis());</span><br><span class="line">    transactionEntity.setFromWalletId(fromWalletId);</span><br><span class="line">    transactionEntity.setToWalletId(toWalletId);</span><br><span class="line">    transactionEntity.setStatus(Status.TO_BE_EXECUTED);</span><br><span class="line">    Long transactionId = transactionRepo.saveTransaction(transactionEntity);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      debit(fromWalletId, amount);</span><br><span class="line">      credit(toWalletId, amount);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InsufficientBalanceException e) &#123;</span><br><span class="line">      transactionRepo.updateStatus(transactionId, Status.CLOSED);</span><br><span class="line">      <span class="comment">// ...rethrow exception e...</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      transactionRepo.updateStatus(transactionId, Status.FAILED);</span><br><span class="line">      <span class="comment">// ...rethrow exception e...</span></span><br><span class="line">    &#125;</span><br><span class="line">    transactionRepo.updateStatus(transactionId, Status.EXECUTED);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>领域模型 VirtualWallet 类很单薄，包含的业务逻辑很简单。相对于原来的贫血模型的设计思路，这种充血模型的设计思路，貌似并没有太大优势。这也是大部分业务系统都使用基于贫血模型开发的原因。不过，如果虚拟钱包系统需要支持更复杂的业务逻辑，那充血模型的优势就显现出来了。比如，我们要支持透支一定额度和冻结部分余额的功能。这个时候，我们重新来看一下 VirtualWallet 类的实现代码。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VirtualWallet</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Long id;</span><br><span class="line">  <span class="keyword">private</span> Long createTime = System.currentTimeMillis();</span><br><span class="line">  <span class="keyword">private</span> BigDecimal balance = BigDecimal.ZERO;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> isAllowedOverdraft = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">private</span> BigDecimal overdraftAmount = BigDecimal.ZERO;</span><br><span class="line">  <span class="keyword">private</span> BigDecimal frozenAmount = BigDecimal.ZERO;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">VirtualWallet</span><span class="params">(Long preAllocatedId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.id = preAllocatedId;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> BigDecimal <span class="title">balance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.balance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> BigDecimal <span class="title">getAvaliableBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BigDecimal totalAvaliableBalance = <span class="keyword">this</span>.balance.subtract(<span class="keyword">this</span>.frozenAmount);</span><br><span class="line">    <span class="keyword">if</span> (isAllowedOverdraft) &#123;</span><br><span class="line">      totalAvaliableBalance += <span class="keyword">this</span>.overdraftAmount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> totalAvaliableBalance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">debit</span><span class="params">(BigDecimal amount)</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">credit</span><span class="params">(BigDecimal amount)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">freeze</span><span class="params">(BigDecimal amount)</span> </span>&#123; ... &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unfreeze</span><span class="params">(BigDecimal amount)</span> </span>&#123; ...&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increaseOverdraftAmount</span><span class="params">(BigDecimal amount)</span> </span>&#123; ... &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decreaseOverdraftAmount</span><span class="params">(BigDecimal amount)</span> </span>&#123; ... &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">closeOverdraft</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openOverdraft</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果功能继续演进，我们可以增加更加细化的冻结策略、透支策略、支持钱包账号（VirtualWallet id 字段）自动生成的逻辑（不是通过构造函数经外部传入 ID，而是通过分布式 ID 生成算法来自动生成 ID）等等。</p><h3 id="辩证思考与灵活应用"><a href="#辩证思考与灵活应用" class="headerlink" title="辩证思考与灵活应用"></a>辩证思考与灵活应用</h3><p>两种代码设计与实现中，并没有完全将 Service 类去掉，这是为什么？或者说，Service 类在这种情况下担当的职责是什么？哪些功能逻辑会放到 Service 类中？</p><ol><li>Service 类负责与 Repository 交流。获取数据库中的数据，转化成领域模型 VirtualWallet，然后由领域模型 VirtualWallet 来完成业务逻辑，最后调用 Repository 类的方法，将数据存回数据库。之所以让 VirtualWalletService 类与 Repository 打交道，而不是让领域模型 VirtualWallet 与 Repository 打交道，那是因为我们想保持领域模型的独立性，不与任何其他层的代码（Repository 层的代码）或开发框架（比如 Spring、MyBatis）耦合在一起，将流程性的代码逻辑（比如从 DB 中取数据、映射数据）与领域模型的业务逻辑解耦，让领域模型更加可复用。</li><li>Service 类负责跨领域模型的业务聚合功能。VirtualWalletService 类中的 transfer() 转账函数会涉及两个钱包的操作，因此这部分业务逻辑无法放到 VirtualWallet 类中，所以，我们暂且把转账业务放到 VirtualWalletService 类中了。当然，虽然功能演进，使得转账业务变得复杂起来之后，我们也可以将转账业务抽取出来，设计成一个独立的领域模型。</li><li>Service 类负责一些非功能性及与三方系统交互的工作。比如幂等、事务、发邮件、发消息、记录日志、调用其他系统的 RPC 接口等，都可以放到 Service 类中。</li></ol><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>基于充血模型的 DDD 开发模式跟基于贫血模型的传统开发模式相比，主要区别在 Service 层。在基于充血模型的开发模式下，我们将部分原来在 Service 类中的业务逻辑移动到了一个充血的 Domain 领域模型中，让 Service 类的实现依赖这个 Domain 类。</p><p>在基于充血模型的 DDD 开发模式下，Service 类并不会完全移除，而是负责一些不适合放在 Domain 类中的功能。比如，负责与 Repository 层打交道、跨领域模型的业务聚合功能、幂等事务等非功能性的工作。</p><p>基于充血模型的 DDD 开发模式跟基于贫血模型的传统开发模式相比，Controller 层和 Repository 层的代码基本上相同。这是因为，Repository 层的 Entity 生命周期有限，Controller 层的 VO 只是单纯作为一种 DTO。两部分的业务逻辑都不会太复杂。业务逻辑主要集中在 Service 层。所以，Repository 层和 Controller 层继续沿用贫血模型的设计思路是没有问题的。</p><p>遗留问题：Entity 与 Domain 的转换应该放在哪里？</p><h2 id="13-如何对接口鉴权这样一个功能开发做面向对象分析？"><a href="#13-如何对接口鉴权这样一个功能开发做面向对象分析？" class="headerlink" title="13 如何对接口鉴权这样一个功能开发做面向对象分析？"></a>13 如何对接口鉴权这样一个功能开发做面向对象分析？</h2><p>面向对象分析（OOA）、面向对象设计（OOD）、面向对象编程（OOP），是面向对象开发的三个主要环节。</p><p>我们需要通过沟通、挖掘、分析、假设、梳理，搞清楚具体的需求有哪些，哪些是现在要做的，哪些是未来可能要做的，哪些是不用考虑做的。</p><blockquote><p>加密之后的密码及 AppID，可能被 <strong>重放攻击</strong>。</p></blockquote><p>调用方将请求接口的 URL 跟 AppID、密码拼接在一起，然后进行加密，生成一个 token。</p><p><img src="https://user-images.githubusercontent.com/9289792/107141538-3ca4a000-6964-11eb-903f-404295e31ebf.png" alt="image"></p><p>这样的设计仍然存在重放攻击的风险。</p><p>为了解决这个问题，我们可以进一步优化 token 生成算法，引入一个随机变量，让每次接口请求生成的 token 都不一样。</p><p>微服务端在收到这些数据之后，会验证当前时间戳跟传递过来的时间戳，是否在一定的时间窗口内（比如一分钟）。</p><p><img src="https://user-images.githubusercontent.com/9289792/107141588-ba68ab80-6964-11eb-8cc4-c84ddf91a6d4.png" alt="image"></p><h2 id="14"><a href="#14" class="headerlink" title="14"></a>14</h2><ol><li>把 URL、AppID、密码、时间戳拼接为一个字符串；</li><li>对字符串通过加密算法加密生成 token；</li><li>将 token、AppID、时间戳拼接到 URL 中，形成新的 URL；</li><li>解析 URL，得到 token、AppID、时间戳等信息；</li><li>从存储中取出 AppID 和对应的密码；</li><li>根据时间戳判断 token 是否过期失效；</li><li>验证两个 token 是否匹配；</li></ol><p>1、2、6、7 都是跟 token 有关，负责 token 的生成、验证；3、4 都是在处理 URL，负责 URL 的拼接、解析；5 是操作 AppID 和密码，负责从存储中读取 AppID 和密码。AuthToken、Url、CredentialStorage。</p><h2 id="15"><a href="#15" class="headerlink" title="15"></a>15</h2><p>– EOF –</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;11&quot;&gt;&lt;a href=&quot;#11&quot; class=&quot;headerlink&quot; title=&quot;11&quot;&gt;&lt;/a&gt;11&lt;/h2&gt;&lt;p&gt;领域驱动设计（Domain Driven Design，简称 DDD）。&lt;/p&gt;&lt;h3 id=&quot;什么是基于贫血模型的传统开发模式？&quot;&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="design-patterns" scheme="https://zyf.im/tags/design-patterns/"/>
    
  </entry>
  
  <entry>
    <title>【设计模式之美】笔记 Part 1</title>
    <link href="https://zyf.im/2021/02/05/the-beauty-of-design-patterns-reading-notes-part1/"/>
    <id>https://zyf.im/2021/02/05/the-beauty-of-design-patterns-reading-notes-part1/</id>
    <published>2021-02-05T03:00:41.000Z</published>
    <updated>2021-07-22T06:49:00.213Z</updated>
    
    <content type="html"><![CDATA[<h2 id="00"><a href="#00" class="headerlink" title="00"></a>00</h2><p>KISS 原则（Keep It Simple and Stupid），这个原则理解起来很简单，一看貌似就懂了，那我问你，怎样的代码才算是足够简单呢？怎样才算不够简单需要优化呢？</p><p>“Talk is cheap, show me the code.”</p><h2 id="01"><a href="#01" class="headerlink" title="01"></a>01</h2><p>为什么要学习设计模式：应对面试中的设计模式相关问题；告别写被人吐槽的烂代码；提高复杂代码的设计和开发能力；让读源码、学框架事半功倍；为你的职场发展做铺垫。</p><h2 id="02"><a href="#02" class="headerlink" title="02"></a>02</h2><p>灵活性（flexibility）、可扩展性（extensibility）、可维护性（maintainability）、可读性（readability）、可理解性（understandability）、易修改性（changeability）、可复用（reusability）、可测试性（testability）、模块化（modularity）、高内聚低耦合（high cohesion loose coupling）、高效（high effciency）、高性能（highperformance）、安全性（security）、兼容性（compatibility）、易用性（usability）、整洁（clean）、清晰（clarity）、简单（simple）、直接（straightforward）、少即是多（less code is more）、文档详尽（well-documented）、分层清晰（well-layered）、正确性（correctness、bug free）、健壮性（robustness）、鲁棒性（robustness）、可用性（reliability）、可伸缩性（scalability）、稳定性（stability）、优雅（elegant）、好（good）、坏（bad）</p><p>我们并不能通过单一的维度去评价一段代码写的好坏。比如，即使一段代码的可扩展性很好，但可读性很差，那我们也不能说这段代码质量高。</p><p>如果用数字来量化代码的可读性的话，它应该是一个连续的区间值，而非 0、1 这样的离散值。</p><p>代码质量的评价有很强的主观性。</p><p>有些词语过于笼统、抽象，比较偏向对于整体的描述，比如优雅、好、坏、整洁、清晰等；有些过于细节、偏重方法论，比如模块化、高内聚低耦合、文档详尽、分层清晰等；有些可能并不仅仅局限于编码，跟架构设计等也有关系，比如可伸缩性、可用性、稳定性等。</p><h3 id="可维护性（maintainability）"><a href="#可维护性（maintainability）" class="headerlink" title="可维护性（maintainability）"></a>可维护性（maintainability）</h3><p>破坏原有代码设计、不引入新的 bug 的情况下，能够快速地修改或者添加代码。与之相反，修改或者添加代码需要冒着极大的引入新 bug 的风险，并且需要花费很长的时间才能完成。</p><p>码分层清晰、模块化好、高内聚低耦合、遵从基于接口而非实现编程的设计原则等等，那就可能意味着代码易维护。</p><h3 id="可读性（readability）"><a href="#可读性（readability）" class="headerlink" title="可读性（readability）"></a>可读性（readability）</h3><p>“任何傻瓜都会编写计算机能理解的代码。好的程序员能够编写人能够理解的代码。”</p><p>是否符合编码规范、命名是否达意、注释是否详尽、函数是否长短合适、模块划分是否清晰、是否符合高内聚低耦合等等。</p><p>code review 是一个很好的测验代码可读性的手段。如果你的同事可以轻松地读懂你写的代码，那说明你的代码可读性很好；如果同事在读你的代码时，有很多疑问，那就说明你的代码可读性有待提高了。</p><h3 id="可扩展性（extensibility）"><a href="#可扩展性（extensibility）" class="headerlink" title="可扩展性（extensibility）"></a>可扩展性（extensibility）</h3><p>我们在不修改或少量修改原有代码的情况下，通过扩展的方式添加新的功能代码。说直白点就是，代码预留了一些功能扩展点，你可以把新功能代码，直接插到扩展点上，而不需要因为要添加一个功能而大动干戈，改动大量的原始代码。</p><p>“对修改关闭，对扩展开放”。</p><h3 id="灵活性（flexibility）"><a href="#灵活性（flexibility）" class="headerlink" title="灵活性（flexibility）"></a>灵活性（flexibility）</h3><p>如果一段代码易扩展、易复用或者易用，我们都可以称这段代码写得比较灵活。</p><ul><li>当我们添加一个新的功能代码的时候，原有的代码已经预留好了扩展点，我们不需要修改原有的代码，只要在扩展点上添加新的代码即可。这个时候，我们除了可以说代码易扩展，还可以说代码写得好灵活。</li><li>当我们要实现一个功能的时候，发现原有代码中，已经抽象出了很多底层可以复用的模块、类等代码，我们可以拿来直接使用。这个时候，我们除了可以说代码易复用之外，还可以说代码写得好灵活。</li><li>当我们使用某组接口的时候，如果这组接口可以应对各种使用场景，满足各种不同的需求，我们除了可以说接口易用之外，还可以说这个接口设计得好灵活或者代码写得好灵活。</li></ul><h3 id="简洁性（simplicity）"><a href="#简洁性（simplicity）" class="headerlink" title="简洁性（simplicity）"></a>简洁性（simplicity）</h3><p>尽量保持代码简单。代码简单、逻辑清晰，也就意味着易读、易维护。我们在编写代码的时候，往往也会把简单、清晰放到首位。</p><p>KISS 原则，思从深而行从简，真正的高手能云淡风轻地用最简单的方法解决最复杂的问题。这也是一个编程老手跟编程新手的本质区别之一。</p><h3 id="可复用性（reusability）"><a href="#可复用性（reusability）" class="headerlink" title="可复用性（reusability）"></a>可复用性（reusability）</h3><p>尽量减少重复代码的编写，复用已有的代码。</p><p>当讲到面向对象特性的时候，我们会讲到继承、多态存在的目的之一，就是为了提高代码的可复用性；当讲到设计原则的时候，我们会讲到单一职责原则也跟代码的可复用性相关；当讲到重构技巧的时候，我们会讲到解耦、高内聚、模块化等都能提高代码的可复用性。可见，可复用性也是一个非常重要的代码评价标准，是很多设计原则、思想、模式等所要达到的最终效果。</p><p>DRY（Don’t Repeat Yourself）设计原则。</p><h3 id="可测试性（testability）"><a href="#可测试性（testability）" class="headerlink" title="可测试性（testability）"></a>可测试性（testability）</h3><p>代码可测试性的好坏，能从侧面上非常准确地反应代码质量的好坏。代码的可测试性差，比较难写单元测试，那基本上就能说明代码设计得有问题。</p><h2 id="03"><a href="#03" class="headerlink" title="03"></a>03</h2><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><ul><li>面向对象的四大特性：封装、抽象、继承、多态面</li><li>向对象编程与面向过程编程的区别和联系</li><li>面向对象分析、面向对象设计、面向对象编程</li><li>接口和抽象类的区别以及各自的应用场景</li><li>基于接口而非实现编程的设计思想</li><li>多用组合少用继承的设计思想</li><li>面向过程的贫血模型和面向对象的充血模型</li></ul><h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><p>指导我们代码设计的一些经验总结。</p><ul><li>SOLID 原则 SRP 单一职责原则</li><li>SOLID 原则 OCP 开闭原则</li><li>SOLID 原则 SP 里式替换原则</li><li>SOLID 原则 ISP 接口隔离原则</li><li>SOLID 原则 DIP 依赖倒置原则</li><li>DRY 原则、KISS 原则、YAGNI 原则、LOD 法则</li></ul><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p>针对软件开发中经常遇到的一些设计问题，总结出来的一套解决方案或者设计思路。</p><p>大部分设计模式要解决的都是代码的可扩展性问题。</p><ol><li>创建型 常用的有：单例模式、工厂模式（工厂方法和抽象工厂）、建造者模式。不常用的有：原型模式。</li><li>结构型 常用的有：代理模式、桥接模式、装饰者模式、适配器模式。不常用的有：门面模式、组合模式、享元模式。</li><li>行为型 常用的有：观察者模式、模板模式、策略模式、职责链模式、迭代器模式、状态模式。不常用的有：访问者模式、备忘录模式、命令模式、解释器模式、中介模式。</li></ol><h3 id="编程规范"><a href="#编程规范" class="headerlink" title="编程规范"></a>编程规范</h3><p>主要解决的是代码的可读性问题。</p><h3 id="代码重构"><a href="#代码重构" class="headerlink" title="代码重构"></a>代码重构</h3><p>在软件开发中，只要软件在不停地迭代，就没有一劳永逸的设计。</p><p>在开发初期，除非特别必须，我们一定不要过度设计，应用复杂的设计模式。而是当代码出现问题的时候，我们再针对问题，应用原则和模式进行重构。这样就能有效避免前期的过度设计。</p><ul><li>重构的目的（why）、对象（what）、时机（when）、方法（how）；</li><li>保证重构不出错的技术手段：单元测试和代码的可测试性；</li><li>两种不同规模的重构：大重构（大规模高层次）和小重构（小规模低层次）。</li></ul><h3 id="五者联系"><a href="#五者联系" class="headerlink" title="五者联系"></a>五者联系</h3><p>面向对象编程因为其具有丰富的特性（封装、抽象、继承、多态），可以实现很多复杂的设计思路，是很多设计原则、设计模式等编码实现的基础。</p><p>设计原则是指导我们代码设计的一些经验总结，对于某些场景下，是否应该应用某种设计模式，具有指导意义。比如，“开闭原则”是很多设计模式（策略、模板等）的指导原则。</p><p>设计模式是针对软件开发中经常遇到的一些设计问题，总结出来的一套解决方案或者设计思路。应用设计模式的主要目的是提高代码的可扩展性。从抽象程度上来讲，设计原则比设计模式更抽象。设计模式更加具体、更加可执行。</p><p>编程规范主要解决的是代码的可读性问题。编码规范相对于设计原则、设计模式，更加具体、更加偏重代码细节、更加能落地。持续的小重构依赖的理论基础主要就是编程规范。</p><p>重构作为保持代码质量不下降的有效手段，利用的就是面向对象、设计原则、设计模式、编码规范这些理论。</p><p><img src="https://user-images.githubusercontent.com/9289792/106997160-59eb3a00-67bd-11eb-8f71-db5336d3e77f.png" alt="image"></p><h2 id="04"><a href="#04" class="headerlink" title="04"></a>04</h2><p>面向对象编程是一种编程范式或编程风格。它以类或对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性，作为代码设计和实现的基石。</p><h2 id="05"><a href="#05" class="headerlink" title="05"></a>05</h2><h3 id="封装（Encapsulation）"><a href="#封装（Encapsulation）" class="headerlink" title="封装（Encapsulation）"></a>封装（Encapsulation）</h3><p>封装也叫作信息隐藏或者数据访问保护。类通过暴露有限的访问接口，授权外部仅能通过类提供的方式来访问内部信息或者数据。</p><p>封装特性存在的意义，一方面是保护数据不被随意修改，提高代码的可维护性；另一方面是仅暴露有限的必要接口，提高类的易用性。</p><h3 id="抽象（Abstraction）"><a href="#抽象（Abstraction）" class="headerlink" title="抽象（Abstraction）"></a>抽象（Abstraction）</h3><p>抽象可以通过接口类或者抽象类来实现，但也并不需要特殊的语法机制来支持。</p><p>抽象存在的意义，一方面是提高代码的可扩展性、维护性，修改实现不需要改变定义，减少代码的改动范围；另一方面，它也是处理复杂系统的有效手段，能有效地过滤掉不必要关注的信息。</p><p>提供“函数”这一非常基础的语法机制，就可以实现抽象特性、所以，它没有很强的“特异性”，有时候并不被看作面向对象编程的特性之一。</p><p>在定义（或者叫命名）类的方法的时候，也要有抽象思维，不要在方法定义中，暴露太多的实现细节，以保证在某个时间点需要改变方法的实现逻辑的时候，不用去修改其定义。getPictureUrl 好于 getAliyunPictureUrl。</p><h3 id="继承（Inheritance）"><a href="#继承（Inheritance）" class="headerlink" title="继承（Inheritance）"></a>继承（Inheritance）</h3><p>继承是用来表示类之间的 is-a 关系。继承主要是用来解决代码复用的问题。</p><p>多用组合少用继承。</p><h3 id="多态（Polymorphism）"><a href="#多态（Polymorphism）" class="headerlink" title="多态（Polymorphism）"></a>多态（Polymorphism）</h3><p>多态是指子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现。</p><p>多态这种特性也需要编程语言提供特殊的语法机制来实现，比如继承、接口类、duck-typing。多态可以提高代码的扩展性和复用性，是很多设计模式、设计原则、编程技巧的代码实现基础。</p><p>只要两个类具有相同的方法，就可以实现多态，并不要求两个类之间有任何关系，这就是所谓的 duck-typing，是一些动态语言所特有的语法机制。</p><h2 id="06"><a href="#06" class="headerlink" title="06"></a>06</h2><p>相较于面向对象编程以类为组织代码的基本单元，面向过程编程则是以过程（或方法）作为组织代码的基本单元。它最主要的特点就是数据和方法相分离。相较于面向对象编程语言，面向过程编程语言最大的特点就是不支持丰富的面向对象编程特性，比如继承、多态、封装。</p><p>面向对象编程相比面向过程编程有哪些优势？</p><ul><li>对于大规模复杂程序的开发，程序的处理流程并非单一的一条主线，而是错综复杂的网状结构。</li><li>面向对象编程比起面向过程编程，更能应对这种复杂类型的程序开发。面向对象编程相比面向过程编程，具有更加丰富的特性（封装、抽象、继承、多态）。利用这些特性编写出来的代码，更加易扩展、易复用、易维护。</li><li>从编程语言跟机器打交道的方式的演进规律中，我们可以总结出：面向对象编程语言比起面向过程编程语言，更加人性化、更加高级、更加智能。</li></ul><h2 id="07"><a href="#07" class="headerlink" title="07"></a>07</h2><h3 id="滥用-getter、setter-方法"><a href="#滥用-getter、setter-方法" class="headerlink" title="滥用 getter、setter 方法"></a>滥用 getter、setter 方法</h3><p>尽管 getter 方法相对 setter 方法要安全些，但是如果返回的是集合容器（比如例子中的 List 容器），也要防范集合内部数据被修改的危险。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShoppingCart</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ... 省略其他代码...</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;ShoppingCartItem&gt; <span class="title">getItems</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.unmodifiableList(<span class="keyword">this</span>.items);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnmodifiableList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">UnmodifiableCollection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... 省略其他代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="滥用全局变量和全局方法"><a href="#滥用全局变量和全局方法" class="headerlink" title="滥用全局变量和全局方法"></a>滥用全局变量和全局方法</h3><p>Constants 类、Utils 类的设计尽量能做到职责单一，定义一些细化的小类。</p><p>静态成员变量归属于类上的数据，被所有的实例化对象所共享，也相当于一定程度上的全局变量。</p><p>静态方法将方法与数据分离，破坏了封装特性，是典型的面向过程风格。</p><p>只包含静态方法不包含任何属性的 Utils 类，是彻彻底底的面向过程的编程风格。要尽量避免滥用，不要不加思考地随意去定义 Utils 类。</p><h3 id="定义数据和方法分离的类"><a href="#定义数据和方法分离的类" class="headerlink" title="定义数据和方法分离的类"></a>定义数据和方法分离的类</h3><p>Controller 层负责暴露接口给前端调用，Service 层负责核心业务逻辑，Repository 层负责数据读写。</p><p>而在每一层中，我们又会定义相应的 VO（View Object）、BO（Business Object）、Entity。一般情况下，VO、BO、Entity 中只会定义数据，不会定义方法，所有操作这些数据的业务逻辑都定义在对应的 Controller 类、Service 类、Repository 类中。这就是典型的面向过程的编程风格。</p><blockquote><p>实际上，这种开发模式叫作基于 <code>贫血模型的开发模式</code>，也是我们现在非常常用的一种 Web 项目的开发模式。看到这里，你内心里应该有很多疑惑吧？既然这种开发模式明显违背面向对象的编程风格，为什么大部分 Web 项目都是基于这种开发模式来开发呢？</p></blockquote><h3 id="在面向对象编程中，为什么容易写出面向过程风格的代码？"><a href="#在面向对象编程中，为什么容易写出面向过程风格的代码？" class="headerlink" title="在面向对象编程中，为什么容易写出面向过程风格的代码？"></a>在面向对象编程中，为什么容易写出面向过程风格的代码？</h3><p>面向过程编程风格恰恰符合人的这种流程化思维方式。而面向对象编程风格正好相反。它是一种自底向上的思考方式。</p><p>它不是先去按照执行流程来分解任务，而是将任务翻译成一个一个的小的模块（也就是类），设计类之间的交互，最后按照流程将类组装起来，完成整个任务。</p><p>在面向对象编程中，类的设计还是挺需要技巧，挺需要一定设计经验的。你要去思考如何封装合适的数据和方法到一个类里，如何设计类之间的关系，如何设计类之间的交互等等诸多设计问题。</p><h3 id="面向过程编程及面向过程编程语言就真的无用武之地了吗？"><a href="#面向过程编程及面向过程编程语言就真的无用武之地了吗？" class="headerlink" title="面向过程编程及面向过程编程语言就真的无用武之地了吗？"></a>面向过程编程及面向过程编程语言就真的无用武之地了吗？</h3><p>如果我们开发的是微小程序，或者是一个数据处理相关的代码，以算法为主，数据为辅，那脚本式的面向过程的编程风格就更适合一些。</p><h2 id="08"><a href="#08" class="headerlink" title="08"></a>08</h2><h3 id="抽象类和接口的语法特性"><a href="#抽象类和接口的语法特性" class="headerlink" title="抽象类和接口的语法特性"></a>抽象类和接口的语法特性</h3><p>抽象类不允许被实例化，只能被继承。它可以包含属性和方法。方法既可以包含代码实现，也可以不包含代码实现。不包含代码实现的方法叫作抽象方法。子类继承抽象类，必须实现抽象类中的所有抽象方法。接口不能包含属性，只能声明方法，方法不能包含代码实现。类实现接口的时候，必须实现接口中声明的所有方法。</p><h3 id="抽象类和接口存在的意义"><a href="#抽象类和接口存在的意义" class="headerlink" title="抽象类和接口存在的意义"></a>抽象类和接口存在的意义</h3><p>抽象类是对成员变量和方法的抽象，是一种 is-a 关系，是为了解决代码复用问题。接口仅仅是对方法的抽象，是一种 has-a 关系，表示具有某一组行为特性，是为了解决解耦问题，隔离接口和具体的实现，提高代码的扩展性。</p><p>从类的继承层次上来看，抽象类是一种自下而上的设计思路，先有子类的代码重复，然后再抽象成上层的父类（也就是抽象类）。而接口正好相反，它是一种自上而下的设计思路。</p><h2 id="09"><a href="#09" class="headerlink" title="09"></a>09</h2><p>“Program to an interface, not animplementation”。“基于抽象而非实现编程”。</p><p>越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性，越能应对未来的需求变化。好的代码设计，不仅能应对当下的需求，而且在将来需求发生变化的时候，仍然能够在不破坏原有代码设计的情况下灵活应对。</p><p>“细节是魔鬼”。</p><ol><li>函数的命名不能暴露任何实现细节。</li><li>封装具体的实现细节。</li><li>为实现类定义抽象的接口。</li></ol><p>抽象意识、封装意识、接口意识。</p><h2 id="10"><a href="#10" class="headerlink" title="10"></a>10</h2><p>继承层次过深、过复杂，也会影响到代码的可维护性。</p><p>鸟 -&gt; 会飞、不会飞、会叫、不会叫、会下蛋、不会下蛋。</p><p>利用组合（composition）、接口、委托（delegation 解决。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Flyable</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提高复用性</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyAbility</span> <span class="keyword">implements</span> <span class="title">Flyable</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sparrow</span> <span class="keyword">implements</span> <span class="title">Flyable</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 组合</span></span><br><span class="line">  <span class="keyword">private</span> FlyAbility flyAbility = <span class="keyword">new</span> FlyAbility();</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 委托</span></span><br><span class="line">    flyAbility.fly();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继承改写成组合意味着要做更细粒度的类的拆分。这也就意味着，我们要定义更多的类和接口。类和接口的增多也就或多或少地增加代码的复杂程度和维护成本。</p><p>组合并不完美，继承也不是一无是处。</p><p>如果类之间的继承结构稳定，层次比较浅，关系不复杂，我们就可以大胆地使用继承。反之，我们就尽量使用组合来替代继承。除此之外，还有一些设计模式、特殊的应用场景，会固定使用继承（模板模式（template pattern））或者组合（装饰者模式（decoratorpattern）、策略模式（strategy pattern）、组合模式（composite pattern））。</p><p>– EOF –</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;00&quot;&gt;&lt;a href=&quot;#00&quot; class=&quot;headerlink&quot; title=&quot;00&quot;&gt;&lt;/a&gt;00&lt;/h2&gt;&lt;p&gt;KISS 原则（Keep It Simple and Stupid），这个原则理解起来很简单，一看貌似就懂了，那我问你，怎样的代码才算是足够
      
    
    </summary>
    
    
      <category term="design-patterns" scheme="https://zyf.im/tags/design-patterns/"/>
    
  </entry>
  
  <entry>
    <title>MySQL Code Snippet</title>
    <link href="https://zyf.im/2021/01/29/mysql-code-snippet/"/>
    <id>https://zyf.im/2021/01/29/mysql-code-snippet/</id>
    <published>2021-01-29T10:08:00.000Z</published>
    <updated>2021-07-19T11:32:53.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Tips-SQL"><a href="#Tips-SQL" class="headerlink" title="Tips SQL"></a>Tips SQL</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看优化后的 SQL</span></span><br><span class="line"><span class="comment">-- 在联表查询时比较有效果</span></span><br><span class="line"><span class="keyword">EXPLAIN</span> &lt;你的 <span class="keyword">SQL</span>&gt;;</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">WARNINGS</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看处理</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">PROCESSLIST</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看表结构</span></span><br><span class="line">DESC user;</span><br></pre></td></tr></table></figure><h2 id="ON-vs-USING"><a href="#ON-vs-USING" class="headerlink" title="ON vs USING"></a>ON vs USING</h2><p><a href="https://stackoverflow.com/questions/11366006/mysql-on-vs-using" target="_blank" rel="noopener">MySQL ON vs USING? | stackoverflow</a></p><h2 id="删除重复数据"><a href="#删除重复数据" class="headerlink" title="删除重复数据"></a>删除重复数据</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  student</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">  <span class="keyword">id</span> <span class="keyword">NOT</span> <span class="keyword">IN</span> (</span><br><span class="line">  <span class="keyword">SELECT</span></span><br><span class="line">    <span class="keyword">id</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  ( <span class="keyword">SELECT</span> <span class="keyword">MIN</span>( <span class="keyword">id</span> ) <span class="keyword">AS</span> <span class="keyword">id</span> <span class="keyword">FROM</span> student <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="string">`name`</span> ) tmp)</span><br></pre></td></tr></table></figure><p>要多加一层 tmp 包装，否则会遇到：<code>1093 - You can&#39;t specify target table &#39;student&#39; for update in FROM clause</code></p><h2 id="备份表"><a href="#备份表" class="headerlink" title="备份表"></a>备份表</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建同结构备份表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> zzz_my_table_220727 <span class="keyword">like</span> my_table;</span><br><span class="line"><span class="comment">-- 将需要数据写入备份表</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> zzz_my_table_220727 <span class="keyword">select</span> * <span class="keyword">from</span> my_table <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">id</span> <span class="keyword">desc</span> <span class="keyword">LIMIT</span> <span class="number">1000</span>;</span><br><span class="line"><span class="comment">-- 情况原表</span></span><br><span class="line"><span class="keyword">truncate</span> <span class="keyword">table</span> my_table;</span><br></pre></td></tr></table></figure><h2 id="SQL-AND-OR-执行优先级"><a href="#SQL-AND-OR-执行优先级" class="headerlink" title="SQL AND OR 执行优先级"></a>SQL AND OR 执行优先级</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> table01 <span class="keyword">where</span> condition1 <span class="keyword">or</span> condition2 <span class="keyword">and</span> condition3;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 等价于：</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> table01 <span class="keyword">where</span> condition1 <span class="keyword">or</span> (condition2 <span class="keyword">and</span> condition3);</span><br><span class="line"><span class="comment">-- 而非：</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> table01 <span class="keyword">where</span> (condition1 <span class="keyword">or</span> condition2) <span class="keyword">and</span> condition3;</span><br></pre></td></tr></table></figure><p><code>and</code> 级别高于 <code>or</code>。相当于可以把 <code>and</code> 看成 <code>乘号 *</code>，把 <code>or</code> 看成 <code>加号 +</code>。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://www.standbyside.com/2019/06/19/tips-of-coding-3/" target="_blank" rel="noopener">编程小技巧（3）：查看优化后的 SQL</a></li></ul><p>– EOF –</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Tips-SQL&quot;&gt;&lt;a href=&quot;#Tips-SQL&quot; class=&quot;headerlink&quot; title=&quot;Tips SQL&quot;&gt;&lt;/a&gt;Tips SQL&lt;/h2&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td clas
      
    
    </summary>
    
      <category term="code-snippet" scheme="https://zyf.im/categories/code-snippet/"/>
    
    
      <category term="mysql" scheme="https://zyf.im/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>PHP 月份加减问题</title>
    <link href="https://zyf.im/2021/01/27/php-strtotime-month/"/>
    <id>https://zyf.im/2021/01/27/php-strtotime-month/</id>
    <published>2021-01-27T10:18:24.000Z</published>
    <updated>2021-02-04T09:50:14.162Z</updated>
    
    <content type="html"><![CDATA[<h2 id="看现象"><a href="#看现象" class="headerlink" title="看现象"></a>看现象</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">var_dump(date(<span class="string">"Y-m-d"</span>, strtotime(<span class="string">"+1 month"</span>, strtotime(<span class="string">"2020-07-31"</span>))));</span><br><span class="line"><span class="comment">// string(10) "2020-08-31" 符合预期</span></span><br><span class="line"></span><br><span class="line">var_dump(date(<span class="string">"Y-m-d"</span>, strtotime(<span class="string">"+1 month"</span>, strtotime(<span class="string">"2020-05-31"</span>))));</span><br><span class="line"><span class="comment">// string(10) "2020-07-01" 不符合预期，预期 2020-06-30</span></span><br><span class="line"></span><br><span class="line">var_dump(date(<span class="string">"Y-m-d"</span>, strtotime(<span class="string">"-1 month"</span>, strtotime(<span class="string">"2020-02-29"</span>))));</span><br><span class="line"><span class="comment">// string(10) "2020-01-29" 符合预期</span></span><br><span class="line"></span><br><span class="line">var_dump(date(<span class="string">"Y-m-d"</span>, strtotime(<span class="string">"-1 month"</span>, strtotime(<span class="string">"2020-03-31"</span>))));</span><br><span class="line"><span class="comment">// string(10) "2020-03-02" 不符合预期，预期 2020-02-29</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Carbon\Carbon</span></span><br><span class="line">Carbon::parse(<span class="string">"2020-07-31"</span>)-&gt;addMonth()-&gt;toDateString();</span><br><span class="line"><span class="comment">// "2020-08-31"</span></span><br><span class="line">Carbon::parse(<span class="string">"2020-05-31"</span>)-&gt;addMonth()-&gt;toDateString();</span><br><span class="line"><span class="comment">// "2020-07-01"</span></span><br><span class="line">Carbon::parse(<span class="string">"2020-02-29"</span>)-&gt;subMonth()-&gt;toDateString();</span><br><span class="line"><span class="comment">// "2020-01-29"</span></span><br><span class="line">Carbon::parse(<span class="string">"2020-03-31"</span>)-&gt;subMonth()-&gt;toDateString();</span><br><span class="line"><span class="comment">// "2020-03-02"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果与 strtotime 一致。</span></span><br></pre></td></tr></table></figure><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">var_dump(date(<span class="string">"Y-m-d"</span>, strtotime(<span class="string">"+1 month"</span>, strtotime(<span class="string">"2020-05-31"</span>))));</span><br><span class="line"><span class="comment">// string(10) "2020-07-01"</span></span><br></pre></td></tr></table></figure><p>date 内部的处理逻辑：</p><ol><li><code>2020-05-31</code> 做 <code>+1 month</code> 也就是 <code>2020-06-31</code>。</li><li>再做日期规范化，因为没有 <code>06-31</code>，所以 <code>06-31</code> 就等于了 <code>07-01</code>。</li></ol><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">var_dump(date(<span class="string">"Y-m-d"</span>, strtotime(<span class="string">"2020-06-31"</span>)));</span><br><span class="line"><span class="comment">// string(10) "2017-07-01"</span></span><br><span class="line"></span><br><span class="line">var_dump(date(<span class="string">"Y-m-d"</span>, strtotime(<span class="string">"next month"</span>, strtotime(<span class="string">"2017-01-31"</span>))));</span><br><span class="line"><span class="comment">// string(10) "2017-03-03"</span></span><br><span class="line"></span><br><span class="line">var_dump(date(<span class="string">"Y-m-d"</span>, strtotime(<span class="string">"last month"</span>, strtotime(<span class="string">"2017-03-31"</span>))));</span><br><span class="line"><span class="comment">// string(10) "2017-03-03"</span></span><br></pre></td></tr></table></figure><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">var_dump(date(<span class="string">"Y-m-d"</span>, strtotime(<span class="string">"last day of -1 month"</span>, strtotime(<span class="string">"2017-03-31"</span>))));</span><br><span class="line"><span class="comment">// string(10) "2017-02-28"</span></span><br><span class="line"></span><br><span class="line">var_dump(date(<span class="string">"Y-m-d"</span>, strtotime(<span class="string">"first day of +1 month"</span>, strtotime(<span class="string">"2017-08-31"</span>))));</span><br><span class="line"><span class="comment">// string(10) "2017-09-01"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 但要注意短语的含义：</span></span><br><span class="line">var_dump(date(<span class="string">"Y-m-d"</span>, strtotime(<span class="string">"last day of -1 month"</span>, strtotime(<span class="string">"2017-03-01"</span>))));</span><br><span class="line"><span class="comment">// string(10) "2017-02-28"</span></span><br></pre></td></tr></table></figure><p>如果使用 <code>Carbon\Carbon</code> 可以用 <code>subMonthNoOverflow</code> 与 <code>addMonthNoOverflow</code> 防止进位：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">Carbon::parse(<span class="string">'2020-03-31'</span>)-&gt;subMonthNoOverflow()-&gt;toDateString();</span><br><span class="line"><span class="comment">// "2020-02-29"</span></span><br><span class="line"></span><br><span class="line">Carbon::parse(<span class="string">"2020-05-31"</span>)-&gt;addMonthNoOverflow()-&gt;toDateString();</span><br><span class="line"><span class="comment">// "2020-06-30"</span></span><br></pre></td></tr></table></figure><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://github.com/briannesbitt/Carbon/issues/428" target="_blank" rel="noopener">Why does subMonth not work correctly? | github</a></li><li><a href="https://www.laruence.com/2018/07/31/3207.html" target="_blank" rel="noopener">令人困惑的 strtotime | laruence</a></li></ul><p>– EOF –</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;看现象&quot;&gt;&lt;a href=&quot;#看现象&quot; class=&quot;headerlink&quot; title=&quot;看现象&quot;&gt;&lt;/a&gt;看现象&lt;/h2&gt;&lt;figure class=&quot;highlight php&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span 
      
    
    </summary>
    
    
      <category term="php" scheme="https://zyf.im/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>Yii2 Code Snippet</title>
    <link href="https://zyf.im/2021/01/19/yii2-code-snippet/"/>
    <id>https://zyf.im/2021/01/19/yii2-code-snippet/</id>
    <published>2021-01-19T04:08:13.000Z</published>
    <updated>2021-01-27T09:17:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="gii-CLI"><a href="#gii-CLI" class="headerlink" title="gii CLI"></a>gii CLI</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">php yii <span class="built_in">help</span> gii/mode</span><br><span class="line"></span><br><span class="line">php yii gii/model --generateLabelsFromComments=1 --overwrite=1 --standardizeCapitals=1 --ns=<span class="string">'app\models\gii'</span> --tableName=<span class="string">"*"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 多数据库</span></span><br><span class="line">php yii gii/model --generateLabelsFromComments=1 --overwrite=1 --standardizeCapitals=1 --db=<span class="string">"hub_db"</span> --ns=<span class="string">'app\models\hub\gii'</span> --tableName=<span class="string">"*"</span></span><br></pre></td></tr></table></figure><h2 id="连接数据库时设置时区"><a href="#连接数据库时设置时区" class="headerlink" title="连接数据库时设置时区"></a>连接数据库时设置时区</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="string">'class'</span> =&gt; <span class="string">'yii\db\Connection'</span>,</span><br><span class="line"><span class="string">'dsn'</span> =&gt; <span class="string">'mysql:host=mysql;port=3306;dbname=hub'</span>,</span><br><span class="line"><span class="string">'username'</span> =&gt; <span class="string">'root'</span>,</span><br><span class="line"><span class="string">'password'</span> =&gt; <span class="string">'root'</span>,</span><br><span class="line"><span class="string">'charset'</span> =&gt; <span class="string">'utf8'</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭日志记录，防止被 logs 平台拿走</span></span><br><span class="line"><span class="string">'enableLogging'</span> =&gt; YII_DEBUG ? <span class="keyword">true</span> : <span class="keyword">false</span>,</span><br><span class="line"><span class="string">'enableProfiling'</span> =&gt; YII_DEBUG ? <span class="keyword">true</span> : <span class="keyword">false</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置时区</span></span><br><span class="line"><span class="string">'on afterOpen'</span> =&gt; <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="params">($event)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// set 'Asia/Bangkok' timezone</span></span><br><span class="line">  $event-&gt;sender-&gt;createCommand(<span class="string">"SET time_zone='+08:00';"</span>)-&gt;execute();</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="ActiveRecord-one"><a href="#ActiveRecord-one" class="headerlink" title="ActiveRecord one"></a>ActiveRecord one</h2><blockquote><p><code>yii\db\ActiveRecord::findOne()</code> 和 <code>yii\db\ActiveQuery::one()</code> 都不会添加 LIMIT 1 到 生成的 SQL 语句中。如果你的查询会返回很多行的数据， 你明确的应该加上 <code>limit(1)</code> 来提高性能，比如 <code>Customer::find()-&gt;limit(1)-&gt;one()</code>。</p></blockquote><h2 id="DB-where"><a href="#DB-where" class="headerlink" title="DB where"></a>DB where</h2><ul><li>字符串格式，例如：<code>&#39;status=1&#39;</code></li><li>哈希格式，例如： <code>[&#39;status&#39; =&gt; 1, &#39;type&#39; =&gt; 2]</code></li><li>操作符格式，例如：<code>[&#39;like&#39;, &#39;name&#39;, &#39;test&#39;]</code></li><li>对象格式，例如：<code>new LikeCondition(&#39;name&#39;, &#39;LIKE&#39;, &#39;test&#39;)</code></li></ul><h3 id="简单条件"><a href="#简单条件" class="headerlink" title="简单条件"></a>简单条件</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SQL: (type = 1) AND (status = 2).</span></span><br><span class="line">$cond = [<span class="string">'type'</span> =&gt; <span class="number">1</span>, <span class="string">'status'</span> =&gt; <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// SQL: (id IN (1, 2, 3)) AND (status = 2)</span></span><br><span class="line">$cond = [<span class="string">'id'</span> =&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="string">'status'</span> =&gt; <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// SQL: status IS NULL</span></span><br><span class="line">$cond = [<span class="string">'status'</span> =&gt; <span class="keyword">null</span>]</span><br></pre></td></tr></table></figure><h3 id="AND-OR"><a href="#AND-OR" class="headerlink" title="AND OR"></a>AND OR</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SQL: `id=1 AND id=2`</span></span><br><span class="line">$cond = [<span class="string">'and'</span>, <span class="string">'id=1'</span>, <span class="string">'id=2'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// SQL: `type=1 AND (id=1 OR id=2)`</span></span><br><span class="line">$cond = [<span class="string">'and'</span>, <span class="string">'type=1'</span>, [<span class="string">'or'</span>, <span class="string">'id=1'</span>, <span class="string">'id=2'</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment">// SQL: `type=1 AND (id=1 OR id=2)`</span></span><br><span class="line"><span class="comment">// 此写法 '=' 可以换成其他操作符，例：in like != &gt;= 等</span></span><br><span class="line">$cond = [</span><br><span class="line">    <span class="string">'and'</span>,</span><br><span class="line">    [<span class="string">'='</span>, <span class="string">'type'</span>, <span class="number">1</span>],</span><br><span class="line">    [</span><br><span class="line">        <span class="string">'or'</span>,</span><br><span class="line">        [<span class="string">'='</span>, <span class="string">'id'</span>, <span class="string">'1'</span>],</span><br><span class="line">        [<span class="string">'='</span>, <span class="string">'id'</span>, <span class="string">'2'</span>],</span><br><span class="line">    ]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="NOT"><a href="#NOT" class="headerlink" title="NOT"></a>NOT</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SQL: `NOT (attribute IS NULL)`</span></span><br><span class="line">$cond = [<span class="string">'not'</span>, [<span class="string">'attribute'</span> =&gt; <span class="keyword">null</span>]]</span><br></pre></td></tr></table></figure><h3 id="BETWEEN"><a href="#BETWEEN" class="headerlink" title="BETWEEN"></a>BETWEEN</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// not between 用法相同</span></span><br><span class="line"><span class="comment">// SQL: `id BETWEEN 1 AND 10`</span></span><br><span class="line">$cond = [<span class="string">'between'</span>, <span class="string">'id'</span>, <span class="number">1</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure><h3 id="IN"><a href="#IN" class="headerlink" title="IN"></a>IN</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// not in 用法相同</span></span><br><span class="line"><span class="comment">// SQL: `id IN (1, 2, 3)`</span></span><br><span class="line">$cond = [<span class="string">'between'</span>, <span class="string">'id'</span>, <span class="number">1</span>, <span class="number">10</span>]</span><br><span class="line">$cond = [<span class="string">'id'</span> =&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment">// IN 条件也适用于多字段</span></span><br><span class="line"><span class="comment">// SQL: (`id`, `name`) IN ((1, 'foo'), (2, 'bar'))</span></span><br><span class="line">$cond = [<span class="string">'in'</span>, [<span class="string">'id'</span>, <span class="string">'name'</span>], [[<span class="string">'id'</span> =&gt; <span class="number">1</span>, <span class="string">'name'</span> =&gt; <span class="string">'foo'</span>], [<span class="string">'id'</span> =&gt; <span class="number">2</span>, <span class="string">'name'</span> =&gt; <span class="string">'bar'</span>]]]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也适用于内嵌 SQL 语句</span></span><br><span class="line">$cond = [<span class="string">'in'</span>, <span class="string">'user_id'</span>, (<span class="keyword">new</span> Query())-&gt;select(<span class="string">'id'</span>)-&gt;from(<span class="string">'users'</span>)-&gt;where([<span class="string">'active'</span> =&gt; <span class="number">1</span>])]</span><br></pre></td></tr></table></figure><h3 id="LIKE"><a href="#LIKE" class="headerlink" title="LIKE"></a>LIKE</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SQL: `name LIKE '%tester%'`</span></span><br><span class="line">$cond = [<span class="string">'like'</span>, <span class="string">'name'</span>, <span class="string">'tester'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// SQL: `name LIKE '%test%' AND name LIKE '%sample%'`</span></span><br><span class="line">$cond = [<span class="string">'like'</span>, <span class="string">'name'</span>, [<span class="string">'test'</span>, <span class="string">'sample'</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment">// SQL: `name LIKE '%tester'`</span></span><br><span class="line">$cond = [<span class="string">'like'</span>, <span class="string">'name'</span>, <span class="string">'%tester'</span>, <span class="keyword">false</span>]</span><br></pre></td></tr></table></figure><h3 id="EXIST"><a href="#EXIST" class="headerlink" title="EXIST"></a>EXIST</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// not exists用法类似</span></span><br><span class="line"><span class="comment">// SQL: EXISTS (SELECT "id" FROM "users" WHERE "active"=1)</span></span><br><span class="line">$cond = [<span class="string">'exists'</span>, (<span class="keyword">new</span> Query())-&gt;select(<span class="string">'id'</span>)-&gt;from(<span class="string">'users'</span>)-&gt;where([<span class="string">'active'</span> =&gt; <span class="number">1</span>])]</span><br></pre></td></tr></table></figure><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://www.yiiframework.com/doc/guide/2.0/zh-cn/db-query-builder" target="_blank" rel="noopener">查询构建器 | yiiframework</a></li><li><a href="https://blog.csdn.net/u013697959/article/details/79687746" target="_blank" rel="noopener">YII where 条件 | csdn</a></li></ul><p>– EOF –</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;gii-CLI&quot;&gt;&lt;a href=&quot;#gii-CLI&quot; class=&quot;headerlink&quot; title=&quot;gii CLI&quot;&gt;&lt;/a&gt;gii CLI&lt;/h2&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;
      
    
    </summary>
    
      <category term="code-snippet" scheme="https://zyf.im/categories/code-snippet/"/>
    
    
      <category term="php" scheme="https://zyf.im/tags/php/"/>
    
      <category term="yii2" scheme="https://zyf.im/tags/yii2/"/>
    
  </entry>
  
  <entry>
    <title>Yii2 Vue 跨域问题</title>
    <link href="https://zyf.im/2021/01/10/yii2-vue-cors/"/>
    <id>https://zyf.im/2021/01/10/yii2-vue-cors/</id>
    <published>2021-01-10T04:00:00.000Z</published>
    <updated>2022-07-29T09:06:04.730Z</updated>
    
    <content type="html"><![CDATA[<h2 id="旧的解决办法"><a href="#旧的解决办法" class="headerlink" title="旧的解决办法"></a>旧的解决办法</h2><p>在控制器的 behaviors 方法中增加下面的代码：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">behaviors</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $behaviors = <span class="keyword">parent</span>::behaviors();</span><br><span class="line">    <span class="keyword">if</span> (YII_ENV_DEV) &#123;</span><br><span class="line">        <span class="comment">// add CORS filter</span></span><br><span class="line">        $behaviors[<span class="string">'corsFilter'</span>] = [</span><br><span class="line">            <span class="string">'class'</span> =&gt; Cors::class,</span><br><span class="line">            <span class="string">'cors'</span> =&gt; [</span><br><span class="line">                <span class="string">'Origin'</span> =&gt; [<span class="string">'http://localhost:8080'</span>],</span><br><span class="line">                <span class="string">'Access-Control-Request-Method'</span> =&gt; [<span class="string">'GET'</span>, <span class="string">'POST'</span>, <span class="string">'PUT'</span>, <span class="string">'PATCH'</span>, <span class="string">'DELETE'</span>, <span class="string">'HEAD'</span>, <span class="string">'OPTIONS'</span>],</span><br><span class="line">                <span class="string">'Access-Control-Request-Headers'</span> =&gt; [<span class="string">'*'</span>],</span><br><span class="line">                <span class="string">'Access-Control-Allow-Credentials'</span> =&gt; <span class="keyword">true</span>,</span><br><span class="line">                <span class="string">'Access-Control-Max-Age'</span> =&gt; <span class="number">86400</span>,</span><br><span class="line">                <span class="string">'Access-Control-Expose-Headers'</span> =&gt; [],</span><br><span class="line">            ],</span><br><span class="line">        ];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> $behaviors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上边配置的解释：</p><ul><li><code>Origin</code> 即 <code>Access-Control-Allow-Origin</code> 表示：响应头指定了该响应的资源是否被允许与给定的 origin 共享。</li><li><code>Access-Control-Request-Method</code> 用于通知服务器在真正的请求中会采用哪种 HTTP 方法。因为预检请求所使用的方法总是 <code>OPTIONS</code> ，与实际请求所使用的方法不一样，所以这个请求头是必要的。</li><li><code>Access-Control-Request-Headers</code> 用于通知服务器在真正的请求中会采用哪些请求头。</li><li><code>Access-Control-Allow-Credentials</code> 表示是否可以将对请求的响应暴露给页面。返回 true 则可以，其他值均不可以。</li><li><code>Access-Control-Max-Age</code> 表示返回结果（即 <code>Access-Control-Allow-Methods</code> 和 <code>Access-Control-Allow-Headers</code> 提供的信息） 可以被缓存多久。</li><li><code>Access-Control-Expose-Headers</code> 列出了哪些首部可以作为响应的一部分暴露给外部。</li></ul><p>注意：</p><p>如果设置 <code>Origin</code> 为 <code>[&#39;*&#39;]</code>，即所有的前端跨域请求可以接受，同时把 <code>Access-Control-Allow-Credentials</code> 设置为 <code>true</code>，Yii 会直接报错：<strong>Allowing credentials for wildcard origins is insecure. Please specify more restrictive origins or set ‘credentials’ to false in your CORS configuration.</strong>。</p><p>告诉你使用通配符的凭证是不安全的，让你设置更严格的 <code>Origin</code> 或者把 <code>Access-Control-Allow-Credentials</code> 设置为 <code>false</code>。</p><p>也就是说不能 <code>Access-Control-Allow-Credentials</code> 为 <code>true</code> 并且 <code>Access-Control-Allow-Origin</code> 为 <code>*</code>。</p><p>因为 <code>Access-Control-Allow-Credentials</code> 的意思就是允许跨域请求在请求头中携带凭证，比如 <code>cookie</code>，做身份识别，但是你又把 <code>Access-Control-Allow-Origin</code> 设置为 <code>*</code>，这是说不通的，是相悖的。</p><p>具体可参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS/Errors/CORSNotSupportingCredentials" target="_blank" rel="noopener">Reason: Credential is not supported if the CORS header ‘Access-Control-Allow-Origin’ is ‘*‘ | mozilla</a></p><h2 id="新的问题"><a href="#新的问题" class="headerlink" title="新的问题"></a>新的问题</h2><p>上面的理论上解决了跨域问题，但是新版 Chrome 根据 Cookie 的 SameSite 属性，仍然会阻止 Cookie 的发送 <code>network</code> <code>show filtered out request cookies</code>。</p><p>参考：</p><ul><li><a href="https://medium.com/faun/whats-new-in-devtools-chrome-79-1b2df6cdd759" target="_blank" rel="noopener">What’s New In DevTools (Chrome 79) | medium</a></li><li><a href="https://www.ruanyifeng.com/blog/2019/09/cookie-samesite.html" target="_blank" rel="noopener">Cookie 的 SameSite 属性 | ruanyifeng</a></li></ul><p>在开发环境根治跨域问题，使用 <code>webpack-dev-server</code> 代理。</p><p>前端：abc.test<br>后端：abc-api.test<br>代理：<code>abc.test/web-api</code> -&gt; <code>abc-api.test</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">proxy: &#123;</span><br><span class="line">  <span class="string">'/web-api/'</span>: &#123;</span><br><span class="line">    target: <span class="string">'http://abc-api.test/'</span>,</span><br><span class="line">    pathRewrite: &#123; <span class="string">'^/web-api'</span>: <span class="string">''</span> &#125;,</span><br><span class="line">    changeOrigin: <span class="literal">true</span>, <span class="comment">// 默认情况下，代理时会保留主机头的来源，您可以将 changeOrigin 设置为true 来覆盖此行为。</span></span><br><span class="line">    secure: <span class="literal">false</span>, <span class="comment">// 接受在 HTTPS 上运行带有无效证书的后端服务器。</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：<a href="https://webpack.js.org/configuration/dev-server/#devserverproxy" target="_blank" rel="noopener">dev-server devserverproxy | webpack</a></p><blockquote><p>是否可以 jwt 来解决待研究。</p></blockquote><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://www.shiqidu.com/d/846" target="_blank" rel="noopener">解决 Yii2 + Vue 前后台分离时跨域的问题 | shiqidu</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="noopener">跨源资源共享（CORS） | mozilla</a></li></ul><p>– EOF –</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;旧的解决办法&quot;&gt;&lt;a href=&quot;#旧的解决办法&quot; class=&quot;headerlink&quot; title=&quot;旧的解决办法&quot;&gt;&lt;/a&gt;旧的解决办法&lt;/h2&gt;&lt;p&gt;在控制器的 behaviors 方法中增加下面的代码：&lt;/p&gt;&lt;figure class=&quot;highligh
      
    
    </summary>
    
    
      <category term="php" scheme="https://zyf.im/tags/php/"/>
    
      <category term="yii2" scheme="https://zyf.im/tags/yii2/"/>
    
      <category term="vue" scheme="https://zyf.im/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>回顾 2020</title>
    <link href="https://zyf.im/2020/12/31/review-2020/"/>
    <id>https://zyf.im/2020/12/31/review-2020/</id>
    <published>2020-12-31T12:00:00.000Z</published>
    <updated>2022-09-15T06:30:24.365Z</updated>
    
    <content type="html"><![CDATA[<h2 id="过年就在石家庄"><a href="#过年就在石家庄" class="headerlink" title="过年就在石家庄"></a>过年就在石家庄</h2><h2 id="lwl-走学"><a href="#lwl-走学" class="headerlink" title="lwl 走学"></a>lwl 走学</h2><h2 id="肺炎在家办公"><a href="#肺炎在家办公" class="headerlink" title="肺炎在家办公"></a>肺炎在家办公</h2><h2 id="PR-剪辑"><a href="#PR-剪辑" class="headerlink" title="PR 剪辑"></a>PR 剪辑</h2><h2 id="表情包制作"><a href="#表情包制作" class="headerlink" title="表情包制作"></a>表情包制作</h2><h2 id="自己染发剪发"><a href="#自己染发剪发" class="headerlink" title="自己染发剪发"></a>自己染发剪发</h2><p>– EOF –</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;过年就在石家庄&quot;&gt;&lt;a href=&quot;#过年就在石家庄&quot; class=&quot;headerlink&quot; title=&quot;过年就在石家庄&quot;&gt;&lt;/a&gt;过年就在石家庄&lt;/h2&gt;&lt;h2 id=&quot;lwl-走学&quot;&gt;&lt;a href=&quot;#lwl-走学&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="review" scheme="https://zyf.im/categories/review/"/>
    
    
  </entry>
  
</feed>
