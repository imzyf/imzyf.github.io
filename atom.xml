<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yifans_Z Blog</title>
  
  <subtitle>Love Front-end</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zyf.im/"/>
  <updated>2019-05-25T03:05:50.000Z</updated>
  <id>https://zyf.im/</id>
  
  <author>
    <name>Yifans_Z</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>最左前缀原理与相关优化</title>
    <link href="https://zyf.im/2019/05/25/the-left-prefix-index-rule/"/>
    <id>https://zyf.im/2019/05/25/the-left-prefix-index-rule/</id>
    <published>2019-05-25T03:05:46.000Z</published>
    <updated>2019-05-25T03:05:50.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn-qn.yifans.com/imzyf/fernando-venzano-1591464-unsplash.jpg" alt="the-left-prefix-index-rule"></p><p>MySQL 中的索引可以以一定顺序引用多个列，这种索引叫做联合索引，一般的，一个联合索引是一个有序元组 <code>&lt;a1, a2, …, an&gt;</code>，其中各个元素均为数据表的一列。另外，单列索引可以看成联合索引元素数为 1 的特例。</p><p>我们在 <a href="https://dev.mysql.com/doc/employee/en/employees-installation.html" target="_blank" rel="noopener">Employees Sample Database</a> 中实验，MySQL 版本 5.7。</p><a id="more"></a><p>以 employees.titles 为例，查看其索引：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">INDEX</span> <span class="keyword">FROM</span> employees.titles;</span><br><span class="line"></span><br><span class="line">+<span class="comment">--------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span></span><br><span class="line">| Table  | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | <span class="keyword">Comment</span> | Index_comment |</span><br><span class="line">+<span class="comment">--------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span></span><br><span class="line">| titles |          <span class="number">0</span> | PRIMARY  |            <span class="number">1</span> | emp_no      | A         |      <span class="number">301292</span> |     <span class="literal">NULL</span> | <span class="literal">NULL</span>   |      | BTREE      |         |               |</span><br><span class="line">| titles |          <span class="number">0</span> | PRIMARY  |            <span class="number">2</span> | title       | A         |      <span class="number">442605</span> |     <span class="literal">NULL</span> | <span class="literal">NULL</span>   |      | BTREE      |         |               |</span><br><span class="line">| titles |          <span class="number">0</span> | PRIMARY  |            <span class="number">3</span> | from_date   | A         |      <span class="number">442605</span> |     <span class="literal">NULL</span> | <span class="literal">NULL</span>   |      | BTREE      |         |               |</span><br><span class="line">+<span class="comment">--------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span></span><br></pre></td></tr></table></figure><h2 id="全列匹配"><a href="#全列匹配" class="headerlink" title="全列匹配"></a>全列匹配</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees.titles</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">emp_no = <span class="string">'10009'</span></span><br><span class="line"><span class="keyword">AND</span> title = <span class="string">'Senior Engineer'</span></span><br><span class="line"><span class="keyword">AND</span> from_date = <span class="string">'1995-02-18'</span>;</span><br><span class="line"></span><br><span class="line">+<span class="comment">----+-------------+--------+------------+-------+---------------+---------+---------+-------------------+------+----------+-------+</span></span><br><span class="line">| id | select_type | table  | partitions | type  | possible_keys | key     | key_len | ref               | rows | filtered | Extra |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+-------+---------------+---------+---------+-------------------+------+----------+-------+</span></span><br><span class="line">|  1 | SIMPLE      | titles | NULL       | const | PRIMARY       | PRIMARY | 159     | const,const,const |    1 |   100.00 | NULL  |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+-------+---------------+---------+---------+-------------------+------+----------+-------+</span></span><br></pre></td></tr></table></figure><p>当按照索引中所有列进行精确匹配（这里精确匹配指 <code>=</code> 或 <code>IN</code> 匹配）时，索引可以被用到。</p><p>这里有一点需要注意，理论上索引对顺序是敏感的，但是由于 MySQL 的 <strong>查询优化器会自动调整 where 子句的条件顺序</strong> 以使用适合的索引，例如我们将 <code>where</code> 中的条件顺序颠倒：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees.titles</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">from_date = <span class="string">'1995-02-18'</span></span><br><span class="line"><span class="keyword">AND</span> emp_no <span class="keyword">IN</span> ( <span class="string">'10009'</span> )</span><br><span class="line"><span class="keyword">AND</span> title = <span class="string">'Senior Engineer'</span>;</span><br><span class="line"></span><br><span class="line">+<span class="comment">----+-------------+--------+------------+-------+---------------+---------+---------+-------------------+------+----------+-------+</span></span><br><span class="line">| id | select_type | table  | partitions | type  | possible_keys | key     | key_len | ref               | rows | filtered | Extra |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+-------+---------------+---------+---------+-------------------+------+----------+-------+</span></span><br><span class="line">|  1 | SIMPLE      | titles | NULL       | const | PRIMARY       | PRIMARY | 159     | const,const,const |    1 |   100.00 | NULL  |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+-------+---------------+---------+---------+-------------------+------+----------+-------+</span></span><br></pre></td></tr></table></figure><p>和上面是一样的。</p><h2 id="最左前缀匹配"><a href="#最左前缀匹配" class="headerlink" title="最左前缀匹配"></a>最左前缀匹配</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM employees.titles</span><br><span class="line">WHERE</span><br><span class="line">emp_no = &apos;10009&apos;;</span><br><span class="line"></span><br><span class="line">+----+-------------+--------+------------+------+---------------+---------+---------+-------+------+----------+-------+</span><br><span class="line">| id | select_type | table  | partitions | type | possible_keys | key     | key_len | ref   | rows | filtered | Extra |</span><br><span class="line">+----+-------------+--------+------------+------+---------------+---------+---------+-------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | titles | NULL       | ref  | PRIMARY       | PRIMARY | 4       | const |    3 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+--------+------------+------+---------------+---------+---------+-------+------+----------+-------+</span><br></pre></td></tr></table></figure><p>当查询条件精确匹配索引的 <strong>左边连续一个或几个列</strong> 时，如 <code>&lt;emp_no&gt;</code> 或 <code>&lt;emp_no, title&gt;</code>，所以可以被用到，但是只能用到一部分，即条件所组成的最左前缀。</p><p>上面的查询从分析结果看用到了 <code>PRIMARY</code> 索引，但是 <code>key_len</code> 为 4，说明只用到了索引的第一列前缀。</p><h2 id="中间某个条件未提供"><a href="#中间某个条件未提供" class="headerlink" title="中间某个条件未提供"></a>中间某个条件未提供</h2><p>查询条件用到了索引中列的精确匹配，但是中间某个条件未提供。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees.titles <span class="keyword">WHERE</span> emp_no=<span class="string">'10009'</span> <span class="keyword">AND</span> from_date=<span class="string">'1995-02-18'</span>;</span><br><span class="line"></span><br><span class="line">+<span class="comment">----+-------------+--------+------------+------+---------------+---------+---------+-------+------+----------+-------------+</span></span><br><span class="line">| id | select_type | table  | partitions | type | possible_keys | key     | key_len | ref   | rows | filtered | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+------+---------------+---------+---------+-------+------+----------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | titles | NULL       | ref  | PRIMARY       | PRIMARY | 4       | const |    1 |    10.00 | Using where |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+------+---------------+---------+---------+-------+------+----------+-------------+</span></span><br></pre></td></tr></table></figure><p>此时索引使用情况和情况二相同，因为 <code>title</code> 未提供，所以查询只用到了索引的第一列，而后面的 <code>from_date</code> 虽然也在索引中，但是由于 <code>title</code> 不存在而无法和左前缀连接，因此需要对结果进行扫描过滤 <code>from_date</code>（这里由于 <code>emp_no</code> 唯一，所以不存在扫描）。</p><p>如果想让 <code>from_date</code> 也使用索引而不是 <code>where</code> 过滤，可以增加一个 <em>辅助索引</em> <code>&lt;emp_no, from_date&gt;</code>，此时上面的查询会使用这个索引。</p><p>除此之外，还可以使用一种称之为 <strong>隔离列</strong> 的优化方法，将 <code>emp_no</code> 与 <code>from_date</code> 之间的 _坑_ 填上。</p><p>首先我们看下 <code>title</code> 有几种不同的值：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT DISTINCT(title) FROM employees.titles;</span><br></pre></td></tr></table></figure><p>只有 7 种。在这种成为 _坑_ 的列值比较少的情况下，可以考虑用 <code>IN</code> 来填补这个 _坑_ 从而形成最左前缀：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees.titles</span><br><span class="line"><span class="keyword">WHERE</span> emp_no=<span class="string">'10009'</span></span><br><span class="line"><span class="keyword">AND</span> title <span class="keyword">IN</span> (<span class="string">'Senior Engineer'</span>, <span class="string">'Staff'</span>, <span class="string">'Engineer'</span>, <span class="string">'Senior Staff'</span>, <span class="string">'Assistant Engineer'</span>, <span class="string">'Technique Leader'</span>, <span class="string">'Manager'</span>)</span><br><span class="line"><span class="keyword">AND</span> from_date=<span class="string">'1995-02-18'</span>;</span><br><span class="line"></span><br><span class="line">+<span class="comment">----+-------------+--------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span></span><br><span class="line">| id | select_type | table  | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | titles | NULL       | range | PRIMARY       | PRIMARY | 159     | NULL |    7 |   100.00 | Using where |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span></span><br></pre></td></tr></table></figure><p>这次 <code>key_len</code> 为 <code>159</code>，说明索引被用全了，但是从 <code>type</code> 和 <code>rows</code> 看出 <code>IN</code> 实际上执行了一个 <code>range</code> 查询，这里检查了 7 个 key。看下两种查询的性能比较：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> profiling = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * FROM...  <span class="comment">-- 1</span></span><br><span class="line"><span class="keyword">SELECT</span> * FROM... <span class="comment">-- 2</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">PROFILES</span>;</span><br><span class="line"></span><br><span class="line">| Query_ID | Duration   | Query   |</span><br><span class="line">+<span class="comment">----------+------------+---------+</span></span><br><span class="line">|        1 | 0.00083950 | <span class="keyword">SELECT</span> * ..|</span><br><span class="line">|        <span class="number">2</span> | <span class="number">0.00063700</span> | <span class="keyword">SELECT</span> * ..|</span><br></pre></td></tr></table></figure><p>“填坑” 后性能提升了一点。如果经过 <code>emp_no</code> 筛选后余下很多数据，则后者性能优势会更加明显。当然，如果 <code>title</code> 的值很多，用填坑就不合适了，必须建立辅助索引。（笔者：多次测试后发现是有快有慢，可能是数据的原因，效果并不明显）</p><h2 id="查询条件没有指定索引第一列"><a href="#查询条件没有指定索引第一列" class="headerlink" title="查询条件没有指定索引第一列"></a>查询条件没有指定索引第一列</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees.titles <span class="keyword">WHERE</span> from_date=<span class="string">'1995-02-18'</span>;</span><br><span class="line"></span><br><span class="line">+<span class="comment">----+-------------+--------+------------+------+---------------+------+---------+------+--------+----------+-------------+</span></span><br><span class="line">| id | select_type | table  | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+------+---------------+------+---------+------+--------+----------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | titles | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 442605 |    10.00 | Using where |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+------+---------------+------+---------+------+--------+----------+-------------+</span></span><br></pre></td></tr></table></figure><p>由于不是最左前缀，索引这样的查询显然用不到索引。</p><h2 id="匹配某列的前缀字符串"><a href="#匹配某列的前缀字符串" class="headerlink" title="匹配某列的前缀字符串"></a>匹配某列的前缀字符串</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees.titles <span class="keyword">WHERE</span> emp_no=<span class="number">10009</span> <span class="keyword">AND</span> title <span class="keyword">LIKE</span> <span class="string">'Senior%'</span>;</span><br><span class="line"></span><br><span class="line">+<span class="comment">----+-------------+--------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span></span><br><span class="line">| id | select_type | table  | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | titles | NULL       | range | PRIMARY       | PRIMARY | 156     | NULL |    1 |   100.00 | Using where |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span></span><br></pre></td></tr></table></figure><p>此时可以用到索引，如果通配符 <code>%</code> 不出现在开头，则可以用到索引，但根据具体情况不同可能只会用其中一个前缀。</p><h2 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees.titles <span class="keyword">WHERE</span> emp_no &lt; <span class="string">'10010'</span> <span class="keyword">and</span> title = <span class="string">'Senior Engineer'</span>;</span><br><span class="line"></span><br><span class="line">+<span class="comment">----+-------------+--------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span></span><br><span class="line">| id | select_type | table  | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | titles | NULL       | range | PRIMARY       | PRIMARY | 4       | NULL |   14 |    10.00 | Using where |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span></span><br></pre></td></tr></table></figure><p>范围列可以用到索引（必须是最左前缀），但是范围列后面的列无法用到索引。同时，索引最多用于一个范围列，因此如果查询条件中有两个范围列则无法全用到索引。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees.titles</span><br><span class="line"><span class="keyword">WHERE</span> emp_no &lt; <span class="string">'10010'</span></span><br><span class="line"><span class="keyword">AND</span> title = <span class="string">'Senior Engineer'</span></span><br><span class="line"><span class="keyword">AND</span> from_date <span class="keyword">BETWEEN</span> <span class="string">'1986-01-01'</span> <span class="keyword">AND</span> <span class="string">'1986-12-31'</span>;</span><br><span class="line"></span><br><span class="line">+<span class="comment">----+-------------+--------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span></span><br><span class="line">| id | select_type | table  | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | titles | NULL       | range | PRIMARY       | PRIMARY | 4       | NULL |   14 |     1.11 | Using where |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span></span><br></pre></td></tr></table></figure><p>可以看到索引对第二个范围索引无能为力。这里特别要说明 MySQL 一个有意思的地方，那就是仅用 explain 可能无法区分 范围索引 和 多值匹配，因为在 <code>type</code> 中这两者都显示为 <code>range</code>。</p><p>同时，用了 <code>between</code> 并不意味着就是范围查询，例如下面的查询：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees.titles</span><br><span class="line"><span class="keyword">WHERE</span> emp_no <span class="keyword">BETWEEN</span> <span class="string">'10001'</span> <span class="keyword">AND</span> <span class="string">'10010'</span></span><br><span class="line"><span class="keyword">AND</span> title=<span class="string">'Senior Engineer'</span></span><br><span class="line"><span class="keyword">AND</span> from_date <span class="keyword">BETWEEN</span> <span class="string">'1986-01-01'</span> <span class="keyword">AND</span> <span class="string">'1986-12-31'</span>;</span><br><span class="line"></span><br><span class="line">+<span class="comment">----+-------------+--------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span></span><br><span class="line">| id | select_type | table  | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | titles | NULL       | range | PRIMARY       | PRIMARY | 159     | NULL |   15 |     1.11 | Using where |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span></span><br></pre></td></tr></table></figure><p>看起来是用了两个范围查询，但作用于 <code>emp_no</code> 上的 <code>BETWEEN</code> 实际上相当于 <code>IN</code>，也就是说 <code>emp_no</code> 实际是多值精确匹配。可以看到这个查询用到了索引全部三个列。因此在 MySQL 中要谨慎地区分多值匹配和范围匹配，否则会对 MySQL 的行为产生困惑。</p><p>还有个值得注意的事情：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees.titles <span class="keyword">where</span> emp_no &gt; <span class="number">10000</span> <span class="keyword">AND</span> emp_no &lt; <span class="number">10011</span> <span class="keyword">AND</span> title=<span class="string">'Senior Engineer'</span> <span class="keyword">AND</span> from_date <span class="keyword">BETWEEN</span> <span class="string">'1986-01-01'</span> <span class="keyword">AND</span> <span class="string">'1986-12-31'</span>;</span><br><span class="line"></span><br><span class="line">+<span class="comment">----+-------------+--------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span></span><br><span class="line">| id | select_type | table  | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | titles | NULL       | range | PRIMARY       | PRIMARY | 4       | NULL |   15 |     1.11 | Using where |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees.titles <span class="keyword">where</span> emp_no &gt;= <span class="number">10001</span> <span class="keyword">and</span> emp_no &lt;= <span class="number">10010</span> <span class="keyword">AND</span> title=<span class="string">'Senior Engineer'</span> <span class="keyword">AND</span> from_date <span class="keyword">BETWEEN</span> <span class="string">'1986-01-01'</span> <span class="keyword">AND</span> <span class="string">'1986-12-31'</span>;</span><br><span class="line"></span><br><span class="line">+<span class="comment">----+-------------+--------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span></span><br><span class="line">| id | select_type | table  | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | titles | NULL       | range | PRIMARY       | PRIMARY | 159     | NULL |   15 |     1.11 | Using where |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span></span><br></pre></td></tr></table></figure><blockquote><p>疑问：<code>=</code> 影响 范围索引 还是 多值匹配？</p></blockquote><h2 id="查询条件中含有函数或表达式"><a href="#查询条件中含有函数或表达式" class="headerlink" title="查询条件中含有函数或表达式"></a>查询条件中含有函数或表达式</h2><p>很不幸，如果查询条件中含有函数或表达式，则 MySQL 不会为这列使用索引（虽然某些在数学意义上可以使用）。例如：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees.titles <span class="keyword">WHERE</span> emp_no=<span class="string">'10009'</span> <span class="keyword">AND</span> <span class="keyword">left</span>(title, <span class="number">6</span>)=<span class="string">'Senior'</span>;</span><br><span class="line"></span><br><span class="line">+<span class="comment">----+-------------+--------+------------+------+---------------+---------+---------+-------+------+----------+-------------+</span></span><br><span class="line">| id | select_type | table  | partitions | type | possible_keys | key     | key_len | ref   | rows | filtered | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+------+---------------+---------+---------+-------+------+----------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | titles | NULL       | ref  | PRIMARY       | PRIMARY | 4       | const |    3 |   100.00 | Using where |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+------+---------------+---------+---------+-------+------+----------+-------------+</span></span><br></pre></td></tr></table></figure><p>虽然这个查询和情况五中功能相同，但是由于使用了函数 left，则无法为 title 列应用索引，而情况五中用 LIKE 则可以。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees.titles <span class="keyword">WHERE</span> emp_no - <span class="number">1</span>=<span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line">+<span class="comment">----+-------------+--------+------------+------+---------------+------+---------+------+--------+----------+-------------+</span></span><br><span class="line">| id | select_type | table  | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+------+---------------+------+---------+------+--------+----------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | titles | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 442605 |   100.00 | Using where |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+------+---------------+------+---------+------+--------+----------+-------------+</span></span><br></pre></td></tr></table></figure><p>显然这个查询等价于查询 <code>emp_no</code> 为 <code>10001</code> 的函数，但是由于查询条件是一个表达式，MySQL 无法为其使用索引。看来 MySQL 还没有智能到自动优化常量表达式的程度，因此在写查询语句时尽量避免表达式出现在查询中，而是先手工私下代数运算，转换为无表达式的查询语句。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><blockquote><ul><li><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">MySQL 索引背后的数据结构及算法原理</a></li><li><a href="https://dev.mysql.com/doc/refman/5.7/en/show-profile.html" target="_blank" rel="noopener">13.7.5.30 SHOW PROFILE Syntax</a></li></ul></blockquote><p>– EOF –</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn-qn.yifans.com/imzyf/fernando-venzano-1591464-unsplash.jpg&quot; alt=&quot;the-left-prefix-index-rule&quot;&gt;&lt;/p&gt;
&lt;p&gt;MySQL 中的索引可以以一定顺序引用多个列，这种索引叫做联合索引，一般的，一个联合索引是一个有序元组 &lt;code&gt;&amp;lt;a1, a2, …, an&amp;gt;&lt;/code&gt;，其中各个元素均为数据表的一列。另外，单列索引可以看成联合索引元素数为 1 的特例。&lt;/p&gt;
&lt;p&gt;我们在 &lt;a href=&quot;https://dev.mysql.com/doc/employee/en/employees-installation.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Employees Sample Database&lt;/a&gt; 中实验，MySQL 版本 5.7。&lt;/p&gt;
    
    </summary>
    
    
      <category term="mysql" scheme="https://zyf.im/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>归并排序</title>
    <link href="https://zyf.im/2019/05/23/merge-sort/"/>
    <id>https://zyf.im/2019/05/23/merge-sort/</id>
    <published>2019-05-23T06:44:40.000Z</published>
    <updated>2019-05-23T06:44:44.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn-qn.yifans.com/imzyf/markus-spiske-1191178-unsplash.jpg" alt="merge-sort"></p><p>归并排序（英语：Merge sort，或 mergesort），是创建在归并操作上的一种有效的排序算法，效率为 <code>O(nlogn)</code>。1945 年由约翰·冯·诺伊曼首次提出。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。</p><a id="more"></a><p><img src="https://user-images.githubusercontent.com/9289792/58546744-9751a300-8238-11e9-84d1-0d33d5eaacee.gif" alt="merge-sort"></p><p>采用分治法：</p><ul><li>分割：递归地把当前序列平均分割成两半。</li><li>集成：在保持元素顺序的同时将上一步得到的子序列集成到一起（归并）。</li></ul><p>归并操作（merge），也叫归并算法，指的是将两个已经排序的序列合并成一个序列的操作。归并排序算法依赖归并操作。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span><span class="params">($arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $len = count($arr);</span><br><span class="line">    <span class="keyword">if</span> ($len &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> $arr;</span><br><span class="line">    &#125; <span class="comment">// 递归结束条件, 到达这步的时候, 数组就只剩下一个元素了, 也就是分离了数组</span></span><br><span class="line"></span><br><span class="line">    $mid = $len / <span class="number">2</span>;</span><br><span class="line">    $left = array_slice($arr, <span class="number">0</span>, $mid); <span class="comment">// 拆分数组0-mid这部分给左边left</span></span><br><span class="line">    $right = array_slice($arr, $mid); <span class="comment">// 拆分数组mid-末尾这部分给右边right</span></span><br><span class="line">    $left = mergeSort($left); <span class="comment">// 左边拆分完后开始递归合并往上走</span></span><br><span class="line">    $right = mergeSort($right); <span class="comment">// 右边拆分完毕开始递归往上走</span></span><br><span class="line"></span><br><span class="line">    $arr = merge($left, $right); <span class="comment">// 合并两个数组,继续递归</span></span><br><span class="line">    <span class="keyword">return</span> $arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// merge函数将指定的两个有序数组(arrA, arr)合并并且排序</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span><span class="params">($arrA, $arrB)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $arrC = <span class="keyword">array</span>();</span><br><span class="line">    <span class="keyword">while</span> (count($arrA) &amp;&amp; count($arrB)) &#123;</span><br><span class="line">        <span class="comment">// 这里不断的判断哪个值小, 就将小的值给到arrC, 但是到最后肯定要剩下几个值,</span></span><br><span class="line">        <span class="comment">// 不是剩下arrA里面的就是剩下arrB里面的而且这几个有序的值, 肯定比arrC里面所有的值都大所以使用</span></span><br><span class="line">        $arrC[] = $arrA[<span class="number">0</span>] &lt; $arrB[<span class="number">0</span>] ? array_shift($arrA) : array_shift($arrB);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> array_merge($arrC, $arrA, $arrB);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$startTime = microtime(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">$arr = range(<span class="number">1</span>, <span class="number">1000</span>);</span><br><span class="line">shuffle($arr);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'before sort: '</span>, implode(<span class="string">', '</span>, $arr), <span class="string">"\n"</span>;</span><br><span class="line">$sortArr = mergeSort($arr);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'after sort: '</span>, implode(<span class="string">', '</span>, $sortArr), <span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">'use time: '</span>, microtime(<span class="number">1</span>) - $startTime, <span class="string">"s\n"</span>;</span><br></pre></td></tr></table></figure><p>假设被排序的数列中有 N 个数。遍历一趟的时间复杂度是 <code>O(N)</code>，需要遍历多少次呢？</p><p>归并排序的形式就是一棵二叉树，它需要遍历的次数就是二叉树的深度，而根据 <strong>完全二叉树</strong> 的可以得出它的时间复杂度是 <code>O(N*lgN)</code>。</p><blockquote><p>References:</p><ul><li><a href="https://shockerli.net/post/merge-sort-implement-by-php/" target="_blank" rel="noopener">PHP 算法 —— 归并排序</a></li></ul></blockquote><p>– EOF –</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn-qn.yifans.com/imzyf/markus-spiske-1191178-unsplash.jpg&quot; alt=&quot;merge-sort&quot;&gt;&lt;/p&gt;
&lt;p&gt;归并排序（英语：Merge sort，或 mergesort），是创建在归并操作上的一种有效的排序算法，效率为 &lt;code&gt;O(nlogn)&lt;/code&gt;。1945 年由约翰·冯·诺伊曼首次提出。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。&lt;/p&gt;
    
    </summary>
    
    
      <category term="algorithm" scheme="https://zyf.im/tags/algorithm/"/>
    
      <category term="php" scheme="https://zyf.im/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>My MacBook</title>
    <link href="https://zyf.im/2019/05/20/my-macbook/"/>
    <id>https://zyf.im/2019/05/20/my-macbook/</id>
    <published>2019-05-20T09:14:59.000Z</published>
    <updated>2019-05-20T09:14:59.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn-qn.yifans.com/imzyf/robert-richarz-263241-unsplash.jpg" alt="my-macbook"></p><p>个人 MacBook 食用说明。</p><a id="more"></a><h2 id="Software"><a href="#Software" class="headerlink" title="Software"></a>Software</h2><h3 id="Web-开发"><a href="#Web-开发" class="headerlink" title="Web 开发"></a>Web 开发</h3><ul><li>Docker</li><li>Firefox</li><li>QQ 游览器 Lite</li><li>Google Chrome</li><li>Visual Studio Code</li><li>Sublime Text</li><li>ImageOptim</li><li>Paw - API 管理</li><li>Postman - API 管理</li><li>Navicat for MySQL</li><li>Dash</li></ul><h3 id="iOS-开发"><a href="#iOS-开发" class="headerlink" title="iOS 开发"></a>iOS 开发</h3><ul><li>Realm Studio</li><li>OpenSim - 快速打开模拟器应用文件夹</li><li>Reveal - UI 调试</li><li>Flipper</li><li>Charles</li><li>Wireshark</li></ul><h3 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h3><ul><li>iHosts - 管理 Host</li><li>CleanMyMac X</li><li>The Unarchiver</li><li>Mounty</li><li>ShadowsocksX-NG</li><li>Proxifier - 代理</li><li>iTerm</li><li>PopCilp</li><li>SecureCRT - SSH 管理</li><li>Launchpad Manager Yosemite - 清理 Launchpad 图标</li><li>Itsycal - 日历扩展</li><li>Pap.er - 桌面壁纸</li></ul><h3 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h3><ul><li>Alfred 3</li><li>RescueTime - 时间统计</li><li>IINA</li><li>Evernote - 印象笔记</li><li>MWeb</li><li>Logitech Options</li><li>微信</li><li>QQ</li><li>迅雷</li><li>FileZilla</li><li>网易云音乐</li><li>网易有道词典</li><li>SourceTree</li><li>百度云</li><li>TeamView</li><li>Kindle</li></ul><h3 id="产品"><a href="#产品" class="headerlink" title="产品"></a>产品</h3><ul><li>Axure RP 8</li><li>MindNode</li><li>StarUML</li><li>LICEcap - GIF 录屏</li></ul><h3 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h3><ul><li>Adobe Photoshop CC</li><li>Zeplin</li><li>Sip - 拾色</li></ul><h2 id="CLI"><a href="#CLI" class="headerlink" title="CLI"></a>CLI</h2><ul><li>brew</li><li>brew cask</li><li>dict</li><li>git</li><li>zsh</li><li>oh-my-zsh</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn-qn.yifans.com/imzyf/robert-richarz-263241-unsplash.jpg&quot; alt=&quot;my-macbook&quot;&gt;&lt;/p&gt;
&lt;p&gt;个人 MacBook 食用说明。&lt;/p&gt;
    
    </summary>
    
    
      <category term="mac" scheme="https://zyf.im/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>PHP composer 基本原理</title>
    <link href="https://zyf.im/2019/04/28/php-composer-basic/"/>
    <id>https://zyf.im/2019/04/28/php-composer-basic/</id>
    <published>2019-04-28T11:21:12.000Z</published>
    <updated>2019-04-28T11:21:12.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn-qn.yifans.com/imzyf/dayne-topkin-60559-unsplash.jpg" alt="php-composer-basic"></p><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p><code>public/index.php</code>：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Register The Auto Loader</span></span><br><span class="line"><span class="keyword">require</span> <span class="keyword">__DIR__</span>.<span class="string">'/../vendor/autoload.php'</span>;</span><br></pre></td></tr></table></figure><p><code>autoload.php</code> 不负责具体功能逻辑，只做了两件事：初始化自动加载类、注册自动加载类。</p><p><code>autoload_real.php</code> 中的类名为 <code>ComposerAutoloaderInit...</code> 这可能是为防止与用户自定义类名跟这个类重复冲突，加上了哈希值。</p><p>其实还有一个做法我们更加熟悉，是定义一个命名空间。这里为什么不定义一个命名空间呢？一种理解：命名空间一般都是为了复用，而这个类只需要运行一次即可，以后也不会用得到，用哈希值更加合适。</p><a id="more"></a><h2 id="autoload-real-php"><a href="#autoload-real-php" class="headerlink" title="autoload_real.php"></a>autoload_real.php</h2><p><code>autoload.php</code> 主要调用了 <code>getLoader()</code>：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">getLoader</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 单例模式，自动加载类只能有一个 1</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> !== <span class="keyword">self</span>::$loader) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>::$loader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得自动加载核心类对象 2</span></span><br><span class="line">    spl_autoload_register(<span class="keyword">array</span>(<span class="string">'ComposerAutoloaderInit76e88f0b305cd64c7c84b90b278c31db'</span>, <span class="string">'loadClassLoader'</span>), <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">self</span>::$loader = $loader = <span class="keyword">new</span> \Composer\Autoload\ClassLoader();</span><br><span class="line">    spl_autoload_unregister(<span class="keyword">array</span>(<span class="string">'ComposerAutoloaderInit76e88f0b305cd64c7c84b90b278c31db'</span>, <span class="string">'loadClassLoader'</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化自动加载核心类对象 3</span></span><br><span class="line">    $useStaticLoader = PHP_VERSION_ID &gt;= <span class="number">50600</span> &amp;&amp; !defined(<span class="string">'HHVM_VERSION'</span>) &amp;&amp; (!function_exists(<span class="string">'zend_loader_file_encoded'</span>) || !zend_loader_file_encoded());</span><br><span class="line">    <span class="keyword">if</span> ($useStaticLoader) &#123;</span><br><span class="line">        <span class="keyword">require_once</span> <span class="keyword">__DIR__</span> . <span class="string">'/autoload_static.php'</span>;</span><br><span class="line"></span><br><span class="line">        call_user_func(\Composer\Autoload\ComposerStaticInit76e88f0b305cd64c7c84b90b278c31db::getInitializer($loader));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        $map = <span class="keyword">require</span> <span class="keyword">__DIR__</span> . <span class="string">'/autoload_namespaces.php'</span>;</span><br><span class="line">        <span class="keyword">foreach</span> ($map <span class="keyword">as</span> $namespace =&gt; $path) &#123;</span><br><span class="line">            $loader-&gt;set($namespace, $path);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        $map = <span class="keyword">require</span> <span class="keyword">__DIR__</span> . <span class="string">'/autoload_psr4.php'</span>;</span><br><span class="line">        <span class="keyword">foreach</span> ($map <span class="keyword">as</span> $namespace =&gt; $path) &#123;</span><br><span class="line">            $loader-&gt;setPsr4($namespace, $path);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        $classMap = <span class="keyword">require</span> <span class="keyword">__DIR__</span> . <span class="string">'/autoload_classmap.php'</span>;</span><br><span class="line">        <span class="keyword">if</span> ($classMap) &#123;</span><br><span class="line">            $loader-&gt;addClassMap($classMap);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册自动加载核心类对象 4</span></span><br><span class="line">    $loader-&gt;register(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自动加载全局函数 5</span></span><br><span class="line">    <span class="keyword">if</span> ($useStaticLoader) &#123;</span><br><span class="line">        $includeFiles = Composer\Autoload\ComposerStaticInit76e88f0b305cd64c7c84b90b278c31db::$files;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        $includeFiles = <span class="keyword">require</span> <span class="keyword">__DIR__</span> . <span class="string">'/autoload_files.php'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">foreach</span> ($includeFiles <span class="keyword">as</span> $fileIdentifier =&gt; $file) &#123;</span><br><span class="line">        composerRequire76e88f0b305cd64c7c84b90b278c31db($fileIdentifier, $file);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> $loader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单例模式-1"><a href="#单例模式-1" class="headerlink" title="单例模式 1"></a>单例模式 1</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> !== <span class="keyword">self</span>::$loader) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>::$loader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造-ClassLoader-核心类-2"><a href="#构造-ClassLoader-核心类-2" class="headerlink" title="构造 ClassLoader 核心类 2"></a>构造 ClassLoader 核心类 2</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">spl_autoload_register(<span class="keyword">array</span>(<span class="string">'ComposerAutoloaderInit76e88f0b305cd64c7c84b90b278c31db'</span>, <span class="string">'loadClassLoader'</span>), <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">self</span>::$loader = $loader = <span class="keyword">new</span> \Composer\Autoload\ClassLoader();</span><br><span class="line">spl_autoload_unregister(<span class="keyword">array</span>(<span class="string">'ComposerAutoloaderInit76e88f0b305cd64c7c84b90b278c31db'</span>, <span class="string">'loadClassLoader'</span>));</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">loadClassLoader</span><span class="params">($class)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">'Composer\Autoload\ClassLoader'</span> === $class) &#123;</span><br><span class="line">        <span class="keyword">require</span> <span class="keyword">__DIR__</span> . <span class="string">'/ClassLoader.php'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>composer</code> 先向 <code>PHP</code> 自动加载机制注册了一个函数，这个函数 <code>require</code> 了 <code>ClassLoader</code> 文件。成功 <code>new</code> 出该文件中核心类 <code>ClassLoader()</code> 后，又销毁了该函数。</p><p>为什么不直接 <code>require</code>？原因是：怕有的用户也定义了个 <code>\Composer\Autoload\ClassLoader</code> 命名空间，导致自动加载错误文件。</p><p>那为什么不跟引导类一样用个哈希值呢？原因是：这个类是可以复用的，框架允许用户使用这个类。</p><h2 id="初始化核心类对象-3"><a href="#初始化核心类对象-3" class="headerlink" title="初始化核心类对象 3"></a>初始化核心类对象 3</h2><p>对自动加载类的初始化，主要是给自动加载核心类初始化顶级命名空间映射。初始化的方法有两种：</p><ol><li>使用 <code>autoload_static</code> 进行静态初始化</li><li>调用核心类接口初始化</li></ol><h3 id="autoload-static-静态初始化"><a href="#autoload-static-静态初始化" class="headerlink" title="autoload_static 静态初始化"></a>autoload_static 静态初始化</h3><p>静态初始化只支持 <code>PHP 5.6</code> 以上版本、不支持 <code>HHVM</code> 虚拟机、不存在 <code>Zend-encoded file</code>。</p><p><code>autoload_static.php</code></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// autoload_static.php @generated by Composer</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Composer</span>\<span class="title">Autoload</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hash 防止冲突</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ComposerStaticInit76e88f0b305cd64c7c84b90b278c31db</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> $files = <span class="keyword">array</span> (...);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> $prefixLengthsPsr4 = <span class="keyword">array</span> (...);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> $prefixDirsPsr4 = <span class="keyword">array</span> (...);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> $fallbackDirsPsr4 = <span class="keyword">array</span> (...);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> $prefixesPsr0 = <span class="keyword">array</span> (...);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> $classMap = <span class="keyword">array</span> <span class="keyword">array</span> (...);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">getInitializer</span><span class="params">(ClassLoader $loader)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> \Closure::bind(<span class="function"><span class="keyword">function</span> <span class="params">()</span> <span class="title">use</span> <span class="params">($loader)</span> </span>&#123;</span><br><span class="line">            $loader-&gt;prefixLengthsPsr4 = ComposerStaticInit76e88f0b305cd64c7c84b90b278c31db::$prefixLengthsPsr4;</span><br><span class="line">            $loader-&gt;prefixDirsPsr4 = ComposerStaticInit76e88f0b305cd64c7c84b90b278c31db::$prefixDirsPsr4;</span><br><span class="line">            $loader-&gt;fallbackDirsPsr4 = ComposerStaticInit76e88f0b305cd64c7c84b90b278c31db::$fallbackDirsPsr4;</span><br><span class="line">            $loader-&gt;prefixesPsr0 = ComposerStaticInit76e88f0b305cd64c7c84b90b278c31db::$prefixesPsr0;</span><br><span class="line">            $loader-&gt;classMap = ComposerStaticInit76e88f0b305cd64c7c84b90b278c31db::$classMap;</span><br><span class="line"></span><br><span class="line">        &#125;, <span class="keyword">null</span>, ClassLoader::class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个静态初始化类的核心就是 <code>getInitializer()</code> 函数，它将自己类中的顶级命名空间映射给了 ClassLoader 类。</p><p>值得注意的是这个函数返回的是一个匿名函数，为什么呢？原因就是 <code>ClassLoader</code> 中的 <code>prefixLengthsPsr4</code> 、<code>prefixDirsPsr4</code> 等等方法都是 <code>private</code> 的。普通的函数没办法给类的 <code>private</code> 成员变量赋值。利用匿名函数的绑定功能就可以将把匿名函数转为 <code>ClassLoader</code> 类的成员函数。</p><p>关于匿名函数的 <a href="http://www.cnblogs.com/yjf512/p/4421289.html" target="_blank" rel="noopener">绑定功能</a>。</p><p>接下来就是 顶级命名空间 初始化的关键了。</p><h4 id="classMap"><a href="#classMap" class="headerlink" title="classMap"></a>classMap</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> $classMap = <span class="keyword">array</span> (</span><br><span class="line">    <span class="string">'App\\Api\\Middleware\\DeviceRecord'</span> =&gt; <span class="keyword">__DIR__</span> . <span class="string">'/../..'</span> . <span class="string">'/app/Api/Middleware/DeviceRecord.php'</span>,</span><br><span class="line">    <span class="string">'App\\Api\\Middleware\\HeaderCheck'</span> =&gt; <span class="keyword">__DIR__</span> . <span class="string">'/../..'</span> . <span class="string">'/app/Api/Middleware/HeaderCheck.php'</span>,</span><br><span class="line">    ...</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>直接命名空间全名与目录的映射，没有顶级命名空间。简单粗暴，也导致这个数组相当的大。</p><h4 id="PSR0-顶级命名空间映射"><a href="#PSR0-顶级命名空间映射" class="headerlink" title="PSR0 顶级命名空间映射"></a>PSR0 顶级命名空间映射</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> $prefixesPsr0 = <span class="keyword">array</span> (</span><br><span class="line">    <span class="string">'P'</span> =&gt;</span><br><span class="line">    <span class="keyword">array</span> (</span><br><span class="line">        <span class="string">'Prophecy\\'</span> =&gt;</span><br><span class="line">        <span class="keyword">array</span> (</span><br><span class="line">            <span class="number">0</span> =&gt; <span class="keyword">__DIR__</span> . <span class="string">'/..'</span> . <span class="string">'/phpspec/prophecy/src'</span>,</span><br><span class="line">        ),</span><br><span class="line">        <span class="string">'Parsedown'</span> =&gt;</span><br><span class="line">        <span class="keyword">array</span> (</span><br><span class="line">            <span class="number">0</span> =&gt; <span class="keyword">__DIR__</span> . <span class="string">'/..'</span> . <span class="string">'/erusev/parsedown'</span>,</span><br><span class="line">        ),</span><br><span class="line">    ),</span><br><span class="line">    ...</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>为了快速找到顶级命名空间，这里使用命名空间第一个字母作为前缀索引。这个映射的用法比较明显，假如我们有 <code>Parsedown/example</code> 这样的命名空间，首先通过首字母 <code>P</code>，找到：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="string">'P'</span> =&gt; <span class="keyword">array</span> (...)</span><br></pre></td></tr></table></figure><p>这个数组，然后就会遍历这个数组来和 <code>Parsedown/example</code> 比较，发现第一个 <code>Prophecy</code> 不符合，第二个 <code>Parsedown</code> 符合，然后得到了映射目录（映射目录可能不止一个）：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> =&gt; <span class="keyword">__DIR__</span> . <span class="string">'/..'</span> . <span class="string">'/erusev/parsedown'</span>,</span><br></pre></td></tr></table></figure><p>接着遍历这个数组，尝试 <code>__DIR__ . &#39;/..&#39; . &#39;/erusev/parsedown/Parsedown/example.php&#39;</code> 是否存在，如果不存在接着遍历数组（这个例子数组只有一个元素），如果数组遍历完都没有，就会加载失败。</p><h4 id="PSR4-标准顶级命名空间映射"><a href="#PSR4-标准顶级命名空间映射" class="headerlink" title="PSR4 标准顶级命名空间映射"></a>PSR4 标准顶级命名空间映射</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> $prefixLengthsPsr4 = <span class="keyword">array</span> (</span><br><span class="line">    <span class="string">'p'</span> =&gt;</span><br><span class="line">    <span class="keyword">array</span> (</span><br><span class="line">        <span class="string">'phpDocumentor\\Reflection\\'</span> =&gt; <span class="number">25</span>,</span><br><span class="line">    ),</span><br><span class="line">    <span class="string">'Z'</span> =&gt;</span><br><span class="line">    <span class="keyword">array</span> (</span><br><span class="line">        <span class="string">'Zend\\Diactoros\\'</span> =&gt; <span class="number">15</span>,</span><br><span class="line">    ),</span><br><span class="line">    ...</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> $prefixDirsPsr4 = <span class="keyword">array</span> (</span><br><span class="line">    <span class="string">'phpDocumentor\\Reflection\\'</span> =&gt;</span><br><span class="line">    <span class="keyword">array</span> (</span><br><span class="line">        <span class="number">0</span> =&gt; <span class="keyword">__DIR__</span> . <span class="string">'/..'</span> . <span class="string">'/phpdocumentor/reflection-common/src'</span>,</span><br><span class="line">        <span class="number">1</span> =&gt; <span class="keyword">__DIR__</span> . <span class="string">'/..'</span> . <span class="string">'/phpdocumentor/reflection-docblock/src'</span>,</span><br><span class="line">        <span class="number">2</span> =&gt; <span class="keyword">__DIR__</span> . <span class="string">'/..'</span> . <span class="string">'/phpdocumentor/type-resolver/src'</span>,</span><br><span class="line">    ),</span><br><span class="line">    <span class="string">'Zend\\Diactoros\\'</span> =&gt;</span><br><span class="line">    <span class="keyword">array</span> (</span><br><span class="line">        <span class="number">0</span> =&gt; <span class="keyword">__DIR__</span> . <span class="string">'/..'</span> . <span class="string">'/zendframework/zend-diactoros/src'</span>,</span><br><span class="line">    ),</span><br><span class="line">    ...</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><code>PSR4</code> 标准 <code>顶级命名空间</code> 映射用了两个数组，第一个和 <code>PSR0</code> 一样用命名空间第一个字母作为前缀索引，然后是 <code>顶级命名空间</code>，但是最终并不是文件路径，而是 <code>顶级命名空间</code> 的长度。为什么呢？因为 <code>PSR4</code> 的文件目录更加灵活，更加简洁。</p><p><code>PSR0</code> 中 <code>顶级命名空间</code> 目录 <strong>直接加</strong> 到命名空间前面就可以得到路径：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                                        ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span><br><span class="line">Parsedown/example =&gt; __DIR__ . &apos;/..&apos; . &apos;/erusev/parsedown/Parsedown/example.php</span><br><span class="line">                                                         ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</span><br></pre></td></tr></table></figure><p>而 <code>PSR4</code> 却是用顶级命名空间目录 <strong>替换</strong> 顶级命名空间，所以获得顶级命名空间的 <strong>长度</strong> 很重要：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                                        ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span><br><span class="line">Parsedown/example =&gt; __DIR__ . &apos;/..&apos; . &apos;/erusev/parsedown/example.php</span><br><span class="line">                                                ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</span><br></pre></td></tr></table></figure><p>举例：假如我们找 <code>Symfony\\Polyfill\\Mbstring\\example</code> 这个类，和 <code>PSR0</code> 一样通过前缀索引和字符串匹配我们得到了:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&apos;Symfony\\Polyfill\\Mbstring\\&apos; =&gt; 26,</span><br></pre></td></tr></table></figure><p>这条记录，键是顶级命名空间，值是命名空间的长度。拿到顶级命名空间后去 <code>$prefixDirsPsr4</code> 获取它的映射目录数组（注意映射目录可能不止一条）：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="string">'Symfony\\Polyfill\\Mbstring\\'</span> =&gt;</span><br><span class="line"><span class="keyword">array</span> (</span><br><span class="line">    <span class="number">0</span> =&gt; <span class="keyword">__DIR__</span> . <span class="string">'/..'</span> . <span class="string">'/symfony/polyfill-mbstring'</span>,</span><br><span class="line">),</span><br></pre></td></tr></table></figure><p>将 <code>Symfony\\Polyfill\\Mbstring\\example</code> 前 26 个字母替换为 <code>__DIR__ . &#39;/..&#39; . &#39;/symfony/polyfill-mbstring</code> 也就是：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__DIR__ . &apos;/..&apos; . &apos;/symfony/polyfill-mbstring/example.php</span><br></pre></td></tr></table></figure><p>先验证磁盘上这个文件是否存在，如果不存在接着遍历。如果遍历后没有找到，则加载失败。</p><p>自动加载核心类 <code>ClassLoader</code> 的静态初始化完成！</p><blockquote><p>其实还有 <code>$fallbackDirsPsr4</code>，暂未研究</p></blockquote><h3 id="调用接口初始化"><a href="#调用接口初始化" class="headerlink" title="调用接口初始化"></a>调用接口初始化</h3><p>如果 <code>PHP</code> 版本低于 <code>5.6</code> 或者使用 <code>HHVM</code> 虚拟机环境或者存在 <code>zend_loader_file_encoded</code>，那么就要使用核心类的接口进行初始化。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">PSR0 取出命名空间的第一个字母作为索引，一个索引对应多个顶级命名空间，一个顶级命名空间对应多个目录路径，具体形式可以查看上面的 autoload_static 的 $prefixesPsr0。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">如果没有顶级命名空间，就只存储一个路径名，以便在后面尝试加载。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">$map = <span class="keyword">require</span> <span class="keyword">__DIR__</span> . <span class="string">'/autoload_namespaces.php'</span>;</span><br><span class="line"><span class="keyword">foreach</span> ($map <span class="keyword">as</span> $namespace =&gt; $path) &#123;</span><br><span class="line">    $loader-&gt;set($namespace, $path);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">PSR4 如果没有顶级命名空间，就直接保存目录。</span></span><br><span class="line"><span class="comment">如果有命名空间的话，要保证顶级命名空间最后是 \，然后分别保存</span></span><br><span class="line"><span class="comment">( 前缀 -&gt; 顶级命名空间，顶级命名空间 -&gt; 顶级命名空间长度 )</span></span><br><span class="line"><span class="comment">( 顶级命名空间 -&gt; 目录 )</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">这两个映射数组。具体形式可以查看上面我们讲的 autoload_static 的 prefixLengthsPsr4、$prefixDirsPsr4 。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">$map = <span class="keyword">require</span> <span class="keyword">__DIR__</span> . <span class="string">'/autoload_psr4.php'</span>;</span><br><span class="line"><span class="keyword">foreach</span> ($map <span class="keyword">as</span> $namespace =&gt; $path) &#123;</span><br><span class="line">    $loader-&gt;setPsr4($namespace, $path);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">整个命名空间与目录之间的映射</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">$classMap = <span class="keyword">require</span> <span class="keyword">__DIR__</span> . <span class="string">'/autoload_classmap.php'</span>;</span><br><span class="line"><span class="keyword">if</span> ($classMap) &#123;</span><br><span class="line">    $loader-&gt;addClassMap($classMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注册核心类对象-4"><a href="#注册核心类对象-4" class="headerlink" title="注册核心类对象 4"></a>注册核心类对象 4</h2><p>Composer 自动加载功能的启动与初始化，经过启动与初始化，自动加载核心类对象已经获得了顶级命名空间与相应目录的映射，换句话说，如果有命名空间 <code>App\Console\Kernel</code>，我们已经知道了 <code>App\</code> 对应的目录，接下来我们就要解决下面的就是 <code>\Console\Kernel</code> 这一段。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Registers this instance as an autoloader.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bool $prepend Whether to prepend the autoloader or not</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">register</span><span class="params">($prepend = false)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    spl_autoload_register(<span class="keyword">array</span>(<span class="keyword">$this</span>, <span class="string">'loadClass'</span>), <span class="keyword">true</span>, $prepend);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一行代码实现自动加载。核心在 <code>ClassLoader</code> 的 <code>loadClass()</code> 函数上，这个函数负责按照 <code>PSR</code> 标准将顶层命名空间以下的内容转为对应的目录，也就是上面所说的将 <code>App\Console\Kernel</code> 中 <code>Console\Kernel</code> 这一段转为目录。</p><h2 id="自动加载全局函数-5"><a href="#自动加载全局函数-5" class="headerlink" title="自动加载全局函数 5"></a>自动加载全局函数 5</h2><p><code>Composer</code> 不止可以自动加载命名空间，还可以加载全局函数。就是把全局函数写到特定的文件里面去，在程序运行前挨个 <code>require</code> 就行了。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ($useStaticLoader) &#123;</span><br><span class="line">    <span class="comment">// 静态初始化</span></span><br><span class="line">    $includeFiles = Composer\Autoload\ComposerStaticInit76e88f0b305cd64c7c84b90b278c31db::$files;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 普通初始化</span></span><br><span class="line">    $includeFiles = <span class="keyword">require</span> <span class="keyword">__DIR__</span> . <span class="string">'/autoload_files.php'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">foreach</span> ($includeFiles <span class="keyword">as</span> $fileIdentifier =&gt; $file) &#123;</span><br><span class="line">    composerRequire76e88f0b305cd64c7c84b90b278c31db($fileIdentifier, $file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">composerRequire76e88f0b305cd64c7c84b90b278c31db</span><span class="params">($fileIdentifier, $file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">empty</span>($GLOBALS[<span class="string">'__composer_autoload_files'</span>][$fileIdentifier])) &#123;</span><br><span class="line">        <span class="keyword">require</span> $file;</span><br><span class="line"></span><br><span class="line">        $GLOBALS[<span class="string">'__composer_autoload_files'</span>][$fileIdentifier] = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题 1"></a>问题 1</h3><p>为什么不直接 <code>require</code> <code>$includeFiles</code> 里面的每个文件名，而要用类外面的函数 <code>composerRequire...</code> ？</p><ul><li>避免和用户定义函数冲突</li><li>防止有人在全局函数所在的文件写 <code>$this</code> 或者 <code>self</code></li></ul><p>假如 <code>$includeFiles</code> 有个 <code>app/helper.php</code> 文件，这个 <code>helper.php</code> 文件的函数外有一行代码： <code>$this-&gt;foo()</code>，如果引导类在 <code>getLoader()</code> 函数直接 <code>require($file)</code>，那么引导类就会运行这句代码，调用自己的 <code>foo()</code> 函数，这显然是错的。</p><p>事实上 <code>helper.php</code> 就不应该出现 <code>$this</code> 或 <code>self</code> 这样的代码，这样写一般都是用户写错了的，一旦这样的事情发生：</p><ul><li>第一种情况：引导类恰好有 <code>foo()</code> 函数，那么就会莫名其妙执行了引导类的 <code>foo()</code>。</li><li>第二种情况：引导类没有 <code>foo()</code> 函数，但是却甩出来引导类没有 <code>foo()</code> 方法这样的错误提示，用户不知道自己哪里错了。把 <code>require</code> 语句放到 <strong>引导类的外面</strong>，遇到 <code>$this</code> 或者 <code>self</code> ，程序就会告诉用户根本没有类， <code>$this</code> 或 <code>self</code> 无效，错误信息更加明朗。</li></ul><h3 id="问题-2"><a href="#问题-2" class="headerlink" title="问题 2"></a>问题 2</h3><p>为什么要用 <code>hash</code> 作为 <code>$fileIdentifier</code>？</p><p>这个变量是用来控制全局函数只被 <code>require</code> 一次的，那为什么不用 <code>require_once</code> 呢？事实上 <code>require_once</code> 比 <code>require</code> 效率低很多，使用全局变量 <code>$GLOBALS</code> 这样控制加载会更快。猜测另一个原因应该是 <code>require_once</code> 对相对路径的支持并不理想，所以 <code>composer</code> 尽量少用 <code>require_once</code>。</p><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p><code>ClassLoader</code> 将 <code>loadClass()</code> 函数注册到 <code>PHP SPL</code> 中的 <code>spl_autoload_register()</code> 里面去。这样，每当 PHP 遇到一个不认识的命名空间的时候，PHP 会自动调用注册到 <code>spl_autoload_register()</code> 里面的函数堆栈，运行其中的每个函数，直到找到命名空间对应的文件。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Loads the given class or interface.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  string    $class The name of the class</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> bool|null True if loaded, null otherwise</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">loadClass</span><span class="params">($class)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ($file = <span class="keyword">$this</span>-&gt;findFile($class)) &#123;</span><br><span class="line">        includeFile($file); <span class="comment">// include $file; Prevents access to $this/self from included files.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Finds the path to the file where the class is defined.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string $class The name of the class</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> string|false The path if found, false otherwise</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">findFile</span><span class="params">($class)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// class map lookup</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;classMap[$class])) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;classMap[$class];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// classMapAuthoritative 关闭搜索未在类映射中注册的类的 prefix and fallback directories。- 不清楚干啥的 暂没研究</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;classMapAuthoritative || <span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;missingClasses[$class])) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果启用扩展名，则使用 APCu 前缀来缓存已找到/未找到的类。 - 不清楚干啥的 暂没研究</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> !== <span class="keyword">$this</span>-&gt;apcuPrefix) &#123;</span><br><span class="line">        $file = apcu_fetch(<span class="keyword">$this</span>-&gt;apcuPrefix.$class, $hit);</span><br><span class="line">        <span class="keyword">if</span> ($hit) &#123;</span><br><span class="line">            <span class="keyword">return</span> $file;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $file = <span class="keyword">$this</span>-&gt;findFileWithExtension($class, <span class="string">'.php'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Search for Hack files if we are running on HHVM</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">false</span> === $file &amp;&amp; defined(<span class="string">'HHVM_VERSION'</span>)) &#123;</span><br><span class="line">        $file = <span class="keyword">$this</span>-&gt;findFileWithExtension($class, <span class="string">'.hh'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> !== <span class="keyword">$this</span>-&gt;apcuPrefix) &#123;</span><br><span class="line">        apcu_add(<span class="keyword">$this</span>-&gt;apcuPrefix.$class, $file);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">false</span> === $file) &#123;</span><br><span class="line">        <span class="comment">// Remember that this class does not exist.</span></span><br><span class="line">        <span class="keyword">$this</span>-&gt;missingClasses[$class] = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> $file;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>loadClass()</code> 主要调用 <code>findFile()</code> 函数。<code>findFile()</code> 在解析命名空间的时候主要分为两部分：</p><ul><li><code>classMap</code> 直接看命名空间是否在映射数组</li><li><code>findFileWithExtension()</code> 包含了 <code>PSR0</code>、<code>PSR4</code></li></ul><p>如果我们在代码中写 <code>&#39;phpDocumentor\Reflection\example</code>，PHP 会通过 SPL 调用 <code>loadClass</code> -&gt; <code>findFile</code> -&gt; <code>findFileWithExtension</code>。</p><ul><li>首先默认用 <code>.php</code> 后缀名调用 <code>findFileWithExtension</code> 函数里，利用 <code>PSR4</code> 标准尝试解析目录文件，如果文件不存在则继续用 <code>PSR0</code> 标准解析</li><li>如果解析出来的目录文件仍然不存在，但是环境是 <code>HHVM</code> 虚拟机，继续用后缀名 <code>.hh</code> 再次调用 <code>findFileWithExtension</code> 函数，如果不存在，说明此命名空间无法加载，放到 <code>classMap</code> 中设为 <code>false</code>，以便以后更快地加载</li></ul><h3 id="PSR4"><a href="#PSR4" class="headerlink" title="PSR4"></a>PSR4</h3><p>对于 <code>phpDocumentor\Reflection\example</code>，当尝试利用 <code>PSR4</code> 标准映射目录时，步骤如下：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// $class: phpDocumentor\Reflection\example</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// PSR-4 lookup</span></span><br><span class="line">$logicalPathPsr4 = strtr($class, <span class="string">'\\'</span>, DIRECTORY_SEPARATOR) . $ext;</span><br><span class="line"><span class="comment">// $logicalPathPsr4: phpDocumentor/Reflection/example.php(hh)`</span></span><br><span class="line"></span><br><span class="line">$first = $class[<span class="number">0</span>];</span><br><span class="line"><span class="comment">// $first: p</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;prefixLengthsPsr4[$first])) &#123;</span><br><span class="line">    <span class="comment">/* 'p' =&gt;</span></span><br><span class="line"><span class="comment">    array (</span></span><br><span class="line"><span class="comment">        'phpDocumentor\\Reflection\\' =&gt; 25,</span></span><br><span class="line"><span class="comment">    ),</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    $subPath = $class;</span><br><span class="line">    <span class="comment">// $subPath: phpDocumentor\Reflection\example</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">false</span> !== $lastPos = strrpos($subPath, <span class="string">'\\'</span>)) &#123;</span><br><span class="line">        <span class="comment">// $lastPos 13</span></span><br><span class="line">        $subPath = substr($subPath, <span class="number">0</span>, $lastPos);</span><br><span class="line">        $search = $subPath.<span class="string">'\\'</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;prefixDirsPsr4[$search])) &#123;</span><br><span class="line">            <span class="comment">// search phpDocumentor\\Reflection\\</span></span><br><span class="line">            <span class="comment">// $lastPos 25</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 'phpDocumentor\\Reflection\\' =&gt;</span></span><br><span class="line"><span class="comment">                array (</span></span><br><span class="line"><span class="comment">                    0 =&gt; __DIR__ . '/..' . '/phpdocumentor/reflection-common/src',</span></span><br><span class="line"><span class="comment">                    1 =&gt; __DIR__ . '/..' . '/phpdocumentor/reflection-docblock/src',</span></span><br><span class="line"><span class="comment">                    2 =&gt; __DIR__ . '/..' . '/phpdocumentor/type-resolver/src',</span></span><br><span class="line"><span class="comment">                ),</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            $pathEnd = DIRECTORY_SEPARATOR . substr($logicalPathPsr4, $lastPos + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// $pathEnd /example.php(hh)</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">$this</span>-&gt;prefixDirsPsr4[$search] <span class="keyword">as</span> $dir) &#123;</span><br><span class="line">                <span class="comment">// 遍历 3 个</span></span><br><span class="line">                <span class="keyword">if</span> (file_exists($file = $dir . $pathEnd)) &#123;</span><br><span class="line">                    <span class="comment">// $file __DIR__ . '/..' . /phpdocumentor/type-resolver/src/example.php(hh)`</span></span><br><span class="line">                    <span class="keyword">return</span> $file;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="PSR0"><a href="#PSR0" class="headerlink" title="PSR0"></a>PSR0</h3><p>如果 <code>PSR4</code> 标准加载失败，则要进行 <code>PSR0</code> 标准加载。对于 <code>phpDocumentor\Reflection\example</code>，当尝试利用 <code>PSR0</code> 标准映射目录时，步骤如下：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// $class: phpDocumentor\Reflection\example</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// PSR-0 lookup</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">false</span> !== $pos = strrpos($class, <span class="string">'\\'</span>)) &#123;</span><br><span class="line">    <span class="comment">// namespaced class name</span></span><br><span class="line">    $logicalPathPsr0 = substr($logicalPathPsr4, <span class="number">0</span>, $pos + <span class="number">1</span>)</span><br><span class="line">        . strtr(substr($logicalPathPsr4, $pos + <span class="number">1</span>), <span class="string">'_'</span>, DIRECTORY_SEPARATOR);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// PEAR-like class name</span></span><br><span class="line">    $logicalPathPsr0 = strtr($class, <span class="string">'_'</span>, DIRECTORY_SEPARATOR) . $ext;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// $logicalPathPsr0: phpDocumentor/Reflection/example.php(hh)`</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;prefixesPsr0[$first])) &#123;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">$this</span>-&gt;prefixesPsr0[$first] <span class="keyword">as</span> $prefix =&gt; $dirs) &#123;</span><br><span class="line">        <span class="comment">/* 'P' =&gt;</span></span><br><span class="line"><span class="comment">        array (</span></span><br><span class="line"><span class="comment">            'Prophecy\\' =&gt;</span></span><br><span class="line"><span class="comment">            array (</span></span><br><span class="line"><span class="comment">                0 =&gt; __DIR__ . '/..' . '/phpspec/prophecy/src',</span></span><br><span class="line"><span class="comment">            ),</span></span><br><span class="line"><span class="comment">            'Parsedown' =&gt;</span></span><br><span class="line"><span class="comment">            array (</span></span><br><span class="line"><span class="comment">                0 =&gt; __DIR__ . '/..' . '/erusev/parsedown',</span></span><br><span class="line"><span class="comment">            ),</span></span><br><span class="line"><span class="comment">        ), */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> === strpos($class, $prefix)) &#123;</span><br><span class="line">            <span class="keyword">foreach</span> ($dirs <span class="keyword">as</span> $dir) &#123;</span><br><span class="line">                <span class="keyword">if</span> (file_exists($file = $dir . DIRECTORY_SEPARATOR . $logicalPathPsr0)) &#123;</span><br><span class="line">                    <span class="comment">// $file __DIR__ . '/..' . '/phpspec/prophecy/src' . phpDocumentor/Reflection/example.php(hh)</span></span><br><span class="line">                    <span class="keyword">return</span> $file;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><p>个人一些疑问：</p><h3 id="防止用户自定义与-ClassLoader-命名空间冲突"><a href="#防止用户自定义与-ClassLoader-命名空间冲突" class="headerlink" title="防止用户自定义与 ClassLoader 命名空间冲突"></a>防止用户自定义与 ClassLoader 命名空间冲突</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">spl_autoload_register(<span class="keyword">array</span>(<span class="string">'ComposerAutoloaderInit76e88f0b305cd64c7c84b90b278c31db'</span>, <span class="string">'loadClassLoader'</span>), <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">self</span>::$loader = $loader = <span class="keyword">new</span> \Composer\Autoload\ClassLoader();</span><br><span class="line">spl_autoload_unregister(<span class="keyword">array</span>(<span class="string">'ComposerAutoloaderInit76e88f0b305cd64c7c84b90b278c31db'</span>, <span class="string">'loadClassLoader'</span>));</span><br></pre></td></tr></table></figure><p>为什么这样可以解决：与用户也定义了个 <code>\Composer\Autoload\ClassLoader</code> 命名空间，导致自动加载错误文件。</p><p>与第四个参数 <code>$prepend</code> <code>true</code> 有关吗？</p><h3 id="composer-StaticLoader-有什么优势"><a href="#composer-StaticLoader-有什么优势" class="headerlink" title="composer StaticLoader 有什么优势"></a>composer StaticLoader 有什么优势</h3><p><code>composer</code> 在加载类和加载全局方法时，都有两种方式。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$useStaticLoader = PHP_VERSION_ID &gt;= 50600 &amp;&amp; !defined(&apos;HHVM_VERSION&apos;) &amp;&amp; (!function_exists(&apos;zend_loader_file_encoded&apos;) || !zend_loader_file_encoded());</span><br></pre></td></tr></table></figure><p>以 <code>$useStaticLoader</code> 的值进行选择，为什么一定分两种，静态方法是有什么优势吗？</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><blockquote><ul><li><a href="https://github.com/imzyf/reboot-php" target="_blank" rel="noopener">imzyf/reboot-php - relearning PHP</a></li><li><a href="https://github.com/LeoYang90/laravel-source-analysis/blob/master/PHP%20Composer%E2%80%94%E2%80%94%20%E5%88%9D%E5%A7%8B%E5%8C%96%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.md" target="_blank" rel="noopener">PHP Composer - 初始化源码分析</a></li></ul></blockquote><p>– EOF –</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn-qn.yifans.com/imzyf/dayne-topkin-60559-unsplash.jpg&quot; alt=&quot;php-composer-basic&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;启动&quot;&gt;&lt;a href=&quot;#启动&quot; class=&quot;headerlink&quot; title=&quot;启动&quot;&gt;&lt;/a&gt;启动&lt;/h2&gt;&lt;p&gt;&lt;code&gt;public/index.php&lt;/code&gt;：&lt;/p&gt;
&lt;figure class=&quot;highlight php&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Register The Auto Loader&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;require&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;__DIR__&lt;/span&gt;.&lt;span class=&quot;string&quot;&gt;&#39;/../vendor/autoload.php&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;autoload.php&lt;/code&gt; 不负责具体功能逻辑，只做了两件事：初始化自动加载类、注册自动加载类。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;autoload_real.php&lt;/code&gt; 中的类名为 &lt;code&gt;ComposerAutoloaderInit...&lt;/code&gt; 这可能是为防止与用户自定义类名跟这个类重复冲突，加上了哈希值。&lt;/p&gt;
&lt;p&gt;其实还有一个做法我们更加熟悉，是定义一个命名空间。这里为什么不定义一个命名空间呢？一种理解：命名空间一般都是为了复用，而这个类只需要运行一次即可，以后也不会用得到，用哈希值更加合适。&lt;/p&gt;
    
    </summary>
    
    
      <category term="php" scheme="https://zyf.im/tags/php/"/>
    
      <category term="composer" scheme="https://zyf.im/tags/composer/"/>
    
  </entry>
  
  <entry>
    <title>PHP 请小心判断 strpos</title>
    <link href="https://zyf.im/2019/04/10/php-strpos-warning/"/>
    <id>https://zyf.im/2019/04/10/php-strpos-warning/</id>
    <published>2019-04-10T12:27:21.000Z</published>
    <updated>2019-04-10T09:09:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>有开始写世界上最后的语言 PHP 了（狗头保命）。一个很简单的字符串是否包含判断就掉坑了。</p><p>方法签名：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">strpos ( string $haystack , mixed $needle [, int $offset = <span class="number">0</span> ] ) : int</span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$mystring = <span class="string">'abc'</span>;</span><br><span class="line">$findme   = <span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">if</span> (strpos($mystring, $findme)) &#123;</span><br><span class="line">   dump(<span class="string">'yes'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这时是不会输出 <code>yes</code>，因为 <code>strpos($mystring, $findme)</code> 返回的是 <code>0</code>。就想官方文档说的：</p><blockquote><p>Warning 此函数可能返回布尔值 FALSE，但也可能返回等同于 FALSE 的非布尔值。应使用 === 运算符来测试此函数的返回值。</p></blockquote><p>正解：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (strpos($mystring, $findme) !== <span class="keyword">false</span>) &#123;</span><br><span class="line">   dump(<span class="string">'yes'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这次问题是网上一搜，找到 <code>strpos</code> 后看到 <code>如果没找到 needle，将返回 FALSE</code> 就没多想就用了。语言间的差异还有注意。</p><blockquote><p>Reference:</p><ul><li><a href="https://www.php.net/manual/zh/function.strpos.php" target="_blank" rel="noopener">php.net - strpos</a></li></ul></blockquote><p>– EOF –</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有开始写世界上最后的语言 PHP 了（狗头保命）。一个很简单的字符串是否包含判断就掉坑了。&lt;/p&gt;
&lt;p&gt;方法签名：&lt;/p&gt;
&lt;figure class=&quot;highlight php&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;strpos ( string $haystack , mixed $needle [, int $offset = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; ] ) : int&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="php" scheme="https://zyf.im/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>ES6 中使用 jQuery $(this) 的问题</title>
    <link href="https://zyf.im/2019/04/10/es6-jquery-this-arrow-function/"/>
    <id>https://zyf.im/2019/04/10/es6-jquery-this-arrow-function/</id>
    <published>2019-04-10T09:09:23.000Z</published>
    <updated>2019-04-10T09:09:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>在老项目中开始改用 <code>laravel-mix</code> <code>ES6</code> 逐渐过渡。摸索中遇到在与 <code>jQuery</code> 一同使用时 <code>箭头函数</code> 中 <code>$(this)</code> 的含义发生了变化。</p><a id="more"></a><p>遇到这个问题主要是没有搞清楚 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="noopener">箭头函数</a>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&apos;.js-bottom-btn&apos;).click(() =&gt; &#123;</span><br><span class="line">    let flag = $(this).date(&apos;flag&apos;);</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>转换为了：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&apos;.js-bottom-btn&apos;).click(function() &#123;</span><br><span class="line">    let flag = $(_this).date(&apos;flag&apos;);</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>_this</code> is undefined</p><p>根据 <a href="https://api.jquery.com/click/" target="_blank" rel="noopener">jQuery click 文档</a> 可以修改为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&apos;.js-bottom-btn&apos;).click(event =&gt; &#123;</span><br><span class="line">    let flag = $(event.currentTarget).date(&apos;flag&apos;);</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>类似的问题：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&apos;jquery-selector&apos;).each(() =&gt; &#123;</span><br><span class="line">    $(this).click();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>需要改为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&apos;jquery-selector&apos;).each((index, element) =&gt; &#123;</span><br><span class="line">    $(element).click();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>Reference:</p><ul><li><a href="https://stackoverflow.com/questions/27670401/using-jquery-this-with-es6-arrow-functions-lexical-this-binding" target="_blank" rel="noopener">Using jQuery \$(this) with ES6 Arrow Functions (lexical this binding)</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在老项目中开始改用 &lt;code&gt;laravel-mix&lt;/code&gt; &lt;code&gt;ES6&lt;/code&gt; 逐渐过渡。摸索中遇到在与 &lt;code&gt;jQuery&lt;/code&gt; 一同使用时 &lt;code&gt;箭头函数&lt;/code&gt; 中 &lt;code&gt;$(this)&lt;/code&gt; 的含义发生了变化。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://zyf.im/tags/js/"/>
    
      <category term="es6" scheme="https://zyf.im/tags/es6/"/>
    
      <category term="jquery" scheme="https://zyf.im/tags/jquery/"/>
    
  </entry>
  
  <entry>
    <title>寻找数组中轴索引</title>
    <link href="https://zyf.im/2019/03/06/find-pivot-index/"/>
    <id>https://zyf.im/2019/03/06/find-pivot-index/</id>
    <published>2019-03-06T06:00:00.000Z</published>
    <updated>2019-03-06T06:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn-qn.yifans.com/imzyf/lance-asper-160766-unsplash.jpg" alt="find-pivot-index"></p><p>将 pivot 索引定义为：左边的数字之和等于索引右边的数字之和。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">nums = [1, 7, 3, 6, 5, 6]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">1 + 7 + 3 = 5 + 6</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">nums = [1, 2, 3]</span><br><span class="line">Output: -1</span><br><span class="line">Explanation:</span><br><span class="line">There is no index that satisfies the conditions in the problem statement.</span><br></pre></td></tr></table></figure><a id="more"></a><p>Note:</p><ul><li>The length of <code>nums</code> will be in the range <code>[0, 10000]</code>.</li><li>Each element <code>nums[i]</code> will be an integer in the range <code>[-1000, 1000]</code>.</li></ul><h2 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h2><ul><li>动态规划</li><li>数组的和 - 中轴数 = 中轴数左边数组的和 * 2</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func findPivot(_ array: [Int]) -&gt; Int &#123;</span><br><span class="line">    // 数组和</span><br><span class="line">    let sum = array.reduce(0, +)</span><br><span class="line">    // 左侧数组和</span><br><span class="line">    var leftSum = 0</span><br><span class="line">    for (key, value) in array.enumerated() &#123;</span><br><span class="line">        if sum - value == leftSum * 2 &#123;</span><br><span class="line">            return key</span><br><span class="line">        &#125;</span><br><span class="line">        leftSum += value</span><br><span class="line">    &#125;</span><br><span class="line">    return -1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let array = [1, 7, 3, 6, 5, 6]</span><br><span class="line">search(array) // 3</span><br></pre></td></tr></table></figure><blockquote><p>Reference:</p><ul><li><a href="https://my.oschina.net/liyurong/blog/1608204" target="_blank" rel="noopener">找到数组中左右两边的和相等的 pivot 的下标 Find Pivot Index</a></li></ul></blockquote><p>– EOF –</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn-qn.yifans.com/imzyf/lance-asper-160766-unsplash.jpg&quot; alt=&quot;find-pivot-index&quot;&gt;&lt;/p&gt;
&lt;p&gt;将 pivot 索引定义为：左边的数字之和等于索引右边的数字之和。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Input:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;nums = [1, 7, 3, 6, 5, 6]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Explanation:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1 + 7 + 3 = 5 + 6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Input:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;nums = [1, 2, 3]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: -1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Explanation:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;There is no index that satisfies the conditions in the problem statement.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="swift" scheme="https://zyf.im/tags/swift/"/>
    
      <category term="algorithm" scheme="https://zyf.im/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>m 进制转 n 进制</title>
    <link href="https://zyf.im/2019/03/02/convert-m-number-to-n-number/"/>
    <id>https://zyf.im/2019/03/02/convert-m-number-to-n-number/</id>
    <published>2019-03-02T06:00:00.000Z</published>
    <updated>2019-03-02T06:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn-qn.yifans.com/imzyf/mika-baumeister-703680-unsplash.jpg" alt="convert-m-number-to-n-number"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li>m 进制 -&gt; 十进制 -&gt; n 进制</li><li>利用柯里化生成函数（炫技 🐶）</li></ul><a id="more"></a><h2 id="m-进制-gt-十进制"><a href="#m-进制-gt-十进制" class="headerlink" title="m 进制 -&gt; 十进制"></a>m 进制 -&gt; 十进制</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// carry 范围值: 2-36</span><br><span class="line">// origin 范围值: 0-9 [ascii 48-58], A-Z [65-90], a-z [97-122]</span><br><span class="line">func carryToDecimalism(_ carry: Int) -&gt; (_ origin: String) -&gt; Int &#123;</span><br><span class="line">    return &#123; origin in</span><br><span class="line">        // 得到字符串对应的 ascii 码</span><br><span class="line">        let asciis = origin.uppercased().unicodeScalars.map &#123; Int($0.value) &#125;</span><br><span class="line">        // 累加每一位</span><br><span class="line">        let result = asciis.reversed().enumerated().map &#123; (index, ascii) -&gt; Int in</span><br><span class="line">            var standard: Int</span><br><span class="line">            if 65 &lt;= ascii &amp;&amp; ascii &lt;= 90 &#123;</span><br><span class="line">                standard = ascii - 65 + 10</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                standard = ascii - 48</span><br><span class="line">            &#125;</span><br><span class="line">            return standard * Int(pow(Double(carry), Double(index)))</span><br><span class="line">        &#125;.reduce(0, +)</span><br><span class="line">        return result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let 十六进制转十进制 = carryToDecimalism(16)</span><br><span class="line">print(十六进制转十进制(&quot;1a&quot;)) // 26</span><br><span class="line"></span><br><span class="line">let 二进制转十进制 = carryToDecimalism(2)</span><br><span class="line">print(二进制转十进制(&quot;110&quot;)) // 6</span><br></pre></td></tr></table></figure><h2 id="十进制-gt-n-进制"><a href="#十进制-gt-n-进制" class="headerlink" title="十进制 -&gt; n 进制"></a>十进制 -&gt; n 进制</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func decimalismToCarry(_ carry: Int) -&gt; (_ origin: Int) -&gt; String &#123;</span><br><span class="line">    return &#123; origin in</span><br><span class="line">        var result = [Int]()</span><br><span class="line">        var remain = origin</span><br><span class="line">        while remain &gt; 0 &#123;</span><br><span class="line">            result.append(remain % carry)</span><br><span class="line">            remain /= carry</span><br><span class="line">        &#125;</span><br><span class="line">        if carry &lt;= 10 &#123;</span><br><span class="line">            return result.reversed().map(String.init).joined()</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return result.reversed().map &#123; i -&gt; String in</span><br><span class="line">                return i &lt; 10 ? String(i) : String(UnicodeScalar(i + 55)!)</span><br><span class="line">            &#125;.joined()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let 十进制转二进制 = decimalismToCarry(2)</span><br><span class="line">print(十进制转二进制(26)) // &quot;11010&quot;</span><br></pre></td></tr></table></figure><blockquote><p>Reference:</p><ul><li><a href="http://ascii.911cha.com/" target="_blank" rel="noopener">ASCII 码对照表</a></li></ul></blockquote><p>– EOF –</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn-qn.yifans.com/imzyf/mika-baumeister-703680-unsplash.jpg&quot; alt=&quot;convert-m-number-to-n-number&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;m 进制 -&amp;gt; 十进制 -&amp;gt; n 进制&lt;/li&gt;
&lt;li&gt;利用柯里化生成函数（炫技 🐶）&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="swift" scheme="https://zyf.im/tags/swift/"/>
    
      <category term="algorithm" scheme="https://zyf.im/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>超长阶乘的计算</title>
    <link href="https://zyf.im/2019/03/01/extra-long-factorials/"/>
    <id>https://zyf.im/2019/03/01/extra-long-factorials/</id>
    <published>2019-03-01T06:00:00.000Z</published>
    <updated>2019-03-01T06:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn-qn.yifans.com/imzyf/daniel-corneschi-529450-unsplash.jpg" alt="extra-long-factorials"></p><p>打印 <code>n!</code> 的结果（1 &lt;= n &lt;= 100）。注意：当 <code>n &gt; 20</code> 时 64 位的 <code>Int</code> 将无法直接存储结果。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li>将大数字用 <strong>数组</strong> 形式表示。比如 987 使用 [9,8,7] 代替。</li><li>每一位乘以 n，再进行进位操作，得到新数组。</li></ul><a id="more"></a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let nums = [9, 8, 7]</span><br><span class="line">let tmpNums = nums.map &#123; $0 * 2 &#125; // [18, 16, 14]</span><br><span class="line"></span><br><span class="line">// 遍历 tmpNums 每一个数字，进行进制操作</span><br><span class="line"></span><br><span class="line">[18, 16, 14] -&gt; [18, 17, 4] -&gt; [19, 7, 4] -&gt; [1, 9, 7, 4]</span><br><span class="line"></span><br><span class="line">print(tmpNums.map(String.init).joined()) // 1974</span><br></pre></td></tr></table></figure><h2 id="解答项目"><a href="#解答项目" class="headerlink" title="解答项目"></a>解答项目</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func extraLongFactorials(n: Int) -&gt; Void &#123;</span><br><span class="line">    guard n &gt; 0 else &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    // 结果数组</span><br><span class="line">    var result: [Int] = [1]</span><br><span class="line">    for index in 1...n &#123;</span><br><span class="line">        // 数组翻转 从低位开始每一位乘以本次的数字</span><br><span class="line">        let tmpNums = result.reversed().map &#123; $0 * index &#125;</span><br><span class="line">        // 进位数</span><br><span class="line">        var carryNum = 0</span><br><span class="line">        // 重置结果</span><br><span class="line">        result = []</span><br><span class="line">        tmpNums.forEach &#123;</span><br><span class="line">            // 每一位加上上一位的进的数</span><br><span class="line">            let tmpNum = $0 + carryNum</span><br><span class="line">            // 向下一位进制的数</span><br><span class="line">            carryNum = tmpNum / 10</span><br><span class="line">            // 本位实际剩下的数 插入结果</span><br><span class="line">            result.append(tmpNum % 10)</span><br><span class="line">        &#125;</span><br><span class="line">        // 处理剩余进位数 进位数是可能大于 100</span><br><span class="line">        while carryNum &gt; 0 &#123;</span><br><span class="line">            // 逐渐插入进制</span><br><span class="line">            result.append(carryNum % 10)</span><br><span class="line">            carryNum /= 10</span><br><span class="line">        &#125;</span><br><span class="line">        // 翻转回数组</span><br><span class="line">        result = result.reversed()</span><br><span class="line">    &#125;</span><br><span class="line">    // 连接字符串</span><br><span class="line">    print(result.map(String.init).joined())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Reference:</p><ul><li><a href="https://www.hackerrank.com/challenges/extra-long-factorials/problem" target="_blank" rel="noopener">Extra Long Factorials | HackerRank</a></li><li><a href="https://stackoverflow.com/questions/43830151/swift-3-calculate-factorial-number-result-becomes-too-high" target="_blank" rel="noopener">Swift 3 calculate factorial number. Result becomes too high?</a></li></ul></blockquote><p>– EOF –</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn-qn.yifans.com/imzyf/daniel-corneschi-529450-unsplash.jpg&quot; alt=&quot;extra-long-factorials&quot;&gt;&lt;/p&gt;
&lt;p&gt;打印 &lt;code&gt;n!&lt;/code&gt; 的结果（1 &amp;lt;= n &amp;lt;= 100）。注意：当 &lt;code&gt;n &amp;gt; 20&lt;/code&gt; 时 64 位的 &lt;code&gt;Int&lt;/code&gt; 将无法直接存储结果。&lt;/p&gt;
&lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;将大数字用 &lt;strong&gt;数组&lt;/strong&gt; 形式表示。比如 987 使用 [9,8,7] 代替。&lt;/li&gt;
&lt;li&gt;每一位乘以 n，再进行进位操作，得到新数组。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="swift" scheme="https://zyf.im/tags/swift/"/>
    
      <category term="algorithm" scheme="https://zyf.im/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>fastlane 入门使用</title>
    <link href="https://zyf.im/2019/02/28/fastlane-getting-started/"/>
    <id>https://zyf.im/2019/02/28/fastlane-getting-started/</id>
    <published>2019-02-28T02:00:00.000Z</published>
    <updated>2019-02-28T02:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn-qn.yifans.com/imzyf/caleb-george-352-unsplash.jpg" alt="fastlane-getting-started"></p><p>这次以 <a href="https://fastlane.tools/" target="_blank" rel="noopener">fastlane</a> 为例，尝试项目中有什么事情可以被自动完成。</p><p>fastlane 是 Ruby scripts 的集合，安装方法不多说了见 <a href="https://docs.fastlane.tools/" target="_blank" rel="noopener">官网文档</a>。</p><p>fastlane 中有但不限于以下工具集：</p><ul><li><a href="https://docs.fastlane.tools/actions/produce/" target="_blank" rel="noopener">produce</a> 同时在 Apple Developer Portal 和 App Store Connect 中创建新的 iOS apps。</li><li><a href="https://docs.fastlane.tools/actions/cert/" target="_blank" rel="noopener">cert</a> 自动创建和维护 iOS 签名证书。</li><li><a href="https://docs.fastlane.tools/actions/sigh/" target="_blank" rel="noopener">sigh</a> 创建，更新，下载和修复配置文件。</li><li><a href="https://docs.fastlane.tools/actions/snapshot/" target="_blank" rel="noopener">snapshot</a> 自动在每台设备上获取 iOS 应用的本地化屏幕截图。</li><li><a href="https://docs.fastlane.tools/actions/frameit/" target="_blank" rel="noopener">frameit</a> 将您的屏幕截图放入正确的设备框架中。</li><li><a href="https://docs.fastlane.tools/actions/gym/" target="_blank" rel="noopener">gym</a> 构建和打包您的 iOS apps。</li><li><a href="https://docs.fastlane.tools/actions/deliver/" target="_blank" rel="noopener">deliver</a> 将截图，元数据和您的应用上传到 App Store。</li><li><a href="https://docs.fastlane.tools/actions/pem/" target="_blank" rel="noopener">pem</a> 自动生成并更新推送通知配置文件。</li><li><a href="https://github.com/fastlane/fastlane/tree/master/spaceship" target="_blank" rel="noopener">spaceship</a> 一个 Ruby 库能够访问苹果开发者中心和应用商店连接 api。</li><li><a href="https://docs.fastlane.tools/actions/pilot/" target="_blank" rel="noopener">pilot</a> 自动化 TestFlight 部署并管理测试用户。</li><li><a href="https://github.com/fastlane/boarding" target="_blank" rel="noopener">boarding</a> 邀请 beta 测试人员。</li><li><a href="https://docs.fastlane.tools/actions/match/" target="_blank" rel="noopener">match</a> 使用 Git 同步整个团队的证书和配置文件。</li><li><a href="https://docs.fastlane.tools/actions/scan/" target="_blank" rel="noopener">scan</a> 运行 app 测试。</li></ul><a id="more"></a><blockquote><p>实验环境：Xcode 10.1、Swift 4.2、fastlane 2.116.1、\$99 开发者账户</p></blockquote><h2 id="项目添加-fastlane"><a href="#项目添加-fastlane" class="headerlink" title="项目添加 fastlane"></a>项目添加 fastlane</h2><p>在项目根目录下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fastlane init</span><br></pre></td></tr></table></figure><p>在出现 <code>What would you like to use fastlane for?</code> 是选择 <code>4 Manual setup</code>，在根据提示回车确认。</p><p>之后项目文件中将新增：</p><ul><li><code>Gemfile</code> 这个文件包含了 fastlane gem 的依赖</li><li><code>fastlane</code> 这个文件夹包含<ul><li><code>Appfile</code> 存储 app identifier，Apple ID 以及 fastlane 设置 app 所需的任何其他标识信息</li><li><code>Fastfile</code> 管理 lanes 创建的可被调用的 actions</li></ul></li></ul><h2 id="创建-App"><a href="#创建-App" class="headerlink" title="创建 App"></a>创建 App</h2><p>打开 <code>Fastfile</code> 将里面所有内容替换为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">default_platform(:ios)</span><br><span class="line"></span><br><span class="line">platform :ios do</span><br><span class="line"># 1 lane 的描述</span><br><span class="line">  desc &quot;Create app on Apple Developer and App Store Connect sites&quot;</span><br><span class="line"># 2 create_app 是这个 lane 的名字</span><br><span class="line">  lane :create_app do</span><br><span class="line"># 3 使用 produce action 将 app 添加到 Developer Portal 和 App Store Connect</span><br><span class="line">​    produce</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>打开 <code>Appfile</code> 将 <code>apple_id</code> 前的 # 移除，将 <code>[[APPLE_ID]]</code> 替换为真实 Apple ID，这样 fastlane 将不会反复提示你输入。</p><p>如果 App Store Connect 和 Apple Developer Portal 可以将 <code>apple_id</code> 替换为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apple_dev_portal_id(&quot;[[APPLE_DEVELOPER_ACCOUNT_USERNAME]]&quot;)</span><br><span class="line">itunes_connect_id(&quot;[[APP_STORE_CONNECT_ACCOUNT_USERNAME]]&quot;)</span><br></pre></td></tr></table></figure><p>打开命令行在项目目录输入：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fastlane create_app</span><br></pre></td></tr></table></figure><p>根据提示输入密码，之后将提示你输入 bundle ID，以反 host 格式创建 ID，之后是 App name 最长 30 个字符。</p><p>完成后登陆 Apple Developer Center 和 App Store Connect，app 在二者已经都被创建了。</p><p>再次打开 Appfile 将 <code>app_identifier</code> 填写刚才创建的 bundle ID。</p><h2 id="生成交付文件"><a href="#生成交付文件" class="headerlink" title="生成交付文件"></a>生成交付文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bundle exec fastlane deliver</span><br></pre></td></tr></table></figure><p>根据提醒暂不使用 Swift 代替 Ruby，因为 <code>fastlane.swift</code> 现在为 beta。</p><p>完成后 fastlane 文件夹中新增：</p><ul><li><code>metadata</code> 这个文件夹存放了 app 大部分的 metadata 元数据</li><li><code>Deliverfile</code> 保存这剩余小部分的元数据</li><li><code>screenshots</code> 将保存 app 截图</li></ul><p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1g0lz3u80l5j31eb0e6q8a.jpg" alt="fastlane-getting-started-metadata"></p><p><code>metadata</code> 文件夹中文件内容就是提交给 App Store Connect，多语言 app 可以手动创建对应的语言文件夹。</p><p>更多 <code>deliver</code> 参数见 <a href="https://docs.fastlane.tools/actions/deliver/#more-options" target="_blank" rel="noopener">这里</a></p><h2 id="自动截图"><a href="#自动截图" class="headerlink" title="自动截图"></a>自动截图</h2><p>多种设备和多语言 app 的截图是繁杂的。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fastlane snapshot init</span><br></pre></td></tr></table></figure><p>fastlane 文件夹中新增：<code>Snapfile</code>，将里面的所有内容替换为一下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 1 - 想截图的设备列表</span><br><span class="line"></span><br><span class="line">devices([</span><br><span class="line">  &quot;iPhone 8 Plus&quot;,</span><br><span class="line">  &quot;iPhone SE&quot;</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"># 2 - 支持的语言列表</span><br><span class="line"></span><br><span class="line">languages([</span><br><span class="line">  &apos;en-US&apos;,</span><br><span class="line">  &apos;fr-FR&apos;</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"># 3 - 包含 UI Tests 的 scheme 名字</span><br><span class="line"></span><br><span class="line">scheme(&quot;mZone Poker UITests&quot;)</span><br><span class="line"></span><br><span class="line"># 4 - 截图存储位置</span><br><span class="line"></span><br><span class="line">output_directory &quot;./fastlane/screenshots&quot;</span><br><span class="line"></span><br><span class="line"># 5 - 是否清理之前的截图</span><br><span class="line"></span><br><span class="line">clear_previous_screenshots(true)</span><br></pre></td></tr></table></figure><p>保存关闭，然后命令中执行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fastlane snapshot init</span><br></pre></td></tr></table></figure><p><img src="https://ws1.sinaimg.cn/large/006tKfTcly1g0m3olslyhj30vq0ft44l.jpg" alt="fastlane-getting-started-screenshots" style="width: 600px; display: block; margin: auto;"></p><h3 id="创建-Test-Target"><a href="#创建-Test-Target" class="headerlink" title="创建 Test Target"></a>创建 Test Target</h3><p>在 Xcode 选择 File -&gt; New -&gt; Target 选择 iOS UI Testing Bundle 点击 Next。</p><p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1g0m6hxg0dej30m80g0781.jpg" alt="fastlane-getting-started-screenshots" style="width: 600px; display: block; margin: auto;"></p><p>Product Name 输入上面 <code>scheme</code> 填写的名字 MZone Poker UITests 点击 Finish。</p><p>之后将 fastlane 文件夹中的 SnapshotHelper.swift 拖到 mZone Poker UITests 中。</p><p>之后将 mZone_Poker_UITests.swift 中的 setUp() 和 tearDown() 移除，替换 testExample()：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 1 设置截屏和启动 app</span><br><span class="line">let app = XCUIApplication()</span><br><span class="line">setupSnapshot(app)</span><br><span class="line">app.launch()</span><br><span class="line">// 2 点击 Chip Count 输入框（在 Storyboard 中的 accessibility identifier 设置 &quot;chip count&quot;）然后输入 10</span><br><span class="line">let chipCountTextField = app.textFields[&quot;chip count&quot;]</span><br><span class="line">chipCountTextField.tap()</span><br><span class="line">chipCountTextField.typeText(&quot;10&quot;)</span><br><span class="line">// 3 点击 Big Blind 输入框 然后输入 100</span><br><span class="line">let bigBlindTextField = app.textFields[&quot;big blind&quot;]</span><br><span class="line">bigBlindTextField.tap()</span><br><span class="line">bigBlindTextField.typeText(&quot;100&quot;)</span><br><span class="line">// 4 截图</span><br><span class="line">snapshot(&quot;01UserEntries&quot;)</span><br><span class="line">// 5 点击 what should i do 再进行截图</span><br><span class="line">app.buttons[&quot;what should i do&quot;].tap()</span><br><span class="line">snapshot(&quot;02Suggestion&quot;)</span><br></pre></td></tr></table></figure><p>之后创建 mZone Poker UITests scheme，点击 run stop 右边的按钮选择 <code>Manage Schemes...</code></p><p><img src="https://ws1.sinaimg.cn/large/006tKfTcly1g0m88o46ovj30m80ccdit.jpg" alt="fastlane-getting-started-create-test-target" style="width: 600px; display: block; margin: auto;"></p><p>选择 <code>Edit Schemes...</code> 勾选 <code>Test</code> 和 <code>Run</code></p><p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1g0m8eq3o8uj30m80c0di3.jpg" alt="fastlane-getting-started-create-test-target" style="width: 600px; display: block; margin: auto;"></p><p>打开 Fastfile 添加：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">desc &quot;Take screenshots&quot;</span><br><span class="line">lane :screenshot do</span><br><span class="line">  snapshot</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>命令行执行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bundle exec fastlane screenshot</span><br></pre></td></tr></table></figure><p>完成后将自动打开：</p><p><img src="https://ws4.sinaimg.cn/large/006tKfTcly1g0m8gy5vl9j30df0dwgpb.jpg" alt="fastlane-getting-started-create-test-target" style="width: 600px; display: block; margin: auto;"></p><h2 id="创建-IPA-文件"><a href="#创建-IPA-文件" class="headerlink" title="创建 IPA 文件"></a>创建 IPA 文件</h2><p>首先要确保已经 <code>target</code> 设置 <code>bundle identifier</code> 和 <code>signing identity</code>。</p><p>命令行执行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fastlane gym init</span><br></pre></td></tr></table></figure><p>打开 <code>Gymfile</code> 替换为以下内容：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 1 指定 scheme</span><br><span class="line">scheme(&quot;mZone Poker&quot;)</span><br><span class="line"># 2 指定存放 .ipa 文件夹</span><br><span class="line">output_directory(&quot;./fastlane/builds&quot;)</span><br><span class="line"># 3 从构建中排除 bitcode。Bitcode 允许 Apple 优化你的 app，但是现在排除它以提高构建速度。</span><br><span class="line">include_bitcode(false)</span><br><span class="line"># 4 从构建中排除符号。包含符号允许 Apple 访问应用程序的调试信息，但是现在排除它以提高构建速度。</span><br><span class="line">include_symbols(false)</span><br><span class="line"># 5 允许 Xcode 使用自动配置。</span><br><span class="line">export_xcargs(&quot;-allowProvisioningUpdates&quot;)</span><br></pre></td></tr></table></figure><p>打开 <code>Fastfile</code> 添加：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">desc &quot;Create ipa&quot;</span><br><span class="line">lane :build do</span><br><span class="line">  # 1 允许 Xcode 自动配置</span><br><span class="line">  enable_automatic_code_signing</span><br><span class="line">  # 2 构建号自增（App Store Connect 要求构建号不能重复）</span><br><span class="line">  increment_build_number</span><br><span class="line">  # 3 创建签名的 .ipa 文件</span><br><span class="line">  gym</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>保存后命令行执行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bundle exec fastlane build</span><br></pre></td></tr></table></figure><p><img src="https://ws1.sinaimg.cn/large/006tKfTcly1g0m8ua4im3j30xy0ceaca.jpg" alt="fastlane-getting-started-create-test-target" style="width: 600px; display: block; margin: auto;"></p><h2 id="上传到-App-Store-Connect"><a href="#上传到-App-Store-Connect" class="headerlink" title="上传到 App Store Connect"></a>上传到 App Store Connect</h2><p>使用 <code>deliver</code> 将截图、元数据、.ipa 文件上传到 App Store Connect。</p><p>替换 <code>Deliverfile</code> 内容：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 1 价格为 0 则是免费应用</span><br><span class="line">price_tier(0)</span><br><span class="line"># 2 回答 Apple 在手动提交审核时会向您呈现的问题</span><br><span class="line">submission_information(&#123;</span><br><span class="line">    export_compliance_encryption_updated: false,</span><br><span class="line">    export_compliance_uses_encryption: false,</span><br><span class="line">    content_rights_contains_third_party_content: false,</span><br><span class="line">    add_id_info_uses_idfa: false</span><br><span class="line">&#125;)</span><br><span class="line"># 3 提供应用评级配置位置</span><br><span class="line">app_rating_config_path(&quot;./fastlane/metadata/app_store_rating_config.json&quot;)</span><br><span class="line"># 4 提供.ipa文件位置</span><br><span class="line">ipa(&quot;./fastlane/builds/mZone Poker.ipa”)</span><br><span class="line"># 5 将s ubmit_for_review 设置为 true 以自动提交应用以供审核</span><br><span class="line">submit_for_review(true)</span><br><span class="line"># 6 必须在应用审核接受后手动发布应用</span><br><span class="line">automatic_release(false)</span><br></pre></td></tr></table></figure><p>在 <code>Fastfile</code> 中添加：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">desc &quot;Upload to App Store&quot;</span><br><span class="line">lane :upload do</span><br><span class="line">  deliver</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>然后命令行执行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bundle exec fastlane upload</span><br></pre></td></tr></table></figure><p>完成后，登录 App Store Connect。屏幕截图，元数据和构建应该在那里，等待审查。</p><h2 id="将命令放在一起"><a href="#将命令放在一起" class="headerlink" title="将命令放在一起"></a>将命令放在一起</h2><p>打开 <code>Fastfile</code> 添加：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">desc &quot;Create app, take screenshots, build and upload to App Store&quot;</span><br><span class="line">lane :do_everything do</span><br><span class="line">  create_app</span><br><span class="line">  screenshot</span><br><span class="line">  build</span><br><span class="line">  upload</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>在 <code>Deliverfile</code> 添加：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">force(true)</span><br></pre></td></tr></table></figure><p>执行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bundle exec fastlane do_everything</span><br></pre></td></tr></table></figure><blockquote><p>Reference:</p><ul><li><a href="https://www.raywenderlich.com/233168-fastlane-tutorial-getting-started" target="_blank" rel="noopener">fastlane Tutorial: Getting Started</a></li></ul></blockquote><p>– EOF –</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn-qn.yifans.com/imzyf/caleb-george-352-unsplash.jpg&quot; alt=&quot;fastlane-getting-started&quot;&gt;&lt;/p&gt;
&lt;p&gt;这次以 &lt;a href=&quot;https://fastlane.tools/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;fastlane&lt;/a&gt; 为例，尝试项目中有什么事情可以被自动完成。&lt;/p&gt;
&lt;p&gt;fastlane 是 Ruby scripts 的集合，安装方法不多说了见 &lt;a href=&quot;https://docs.fastlane.tools/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官网文档&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;fastlane 中有但不限于以下工具集：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.fastlane.tools/actions/produce/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;produce&lt;/a&gt; 同时在 Apple Developer Portal 和 App Store Connect 中创建新的 iOS apps。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.fastlane.tools/actions/cert/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;cert&lt;/a&gt; 自动创建和维护 iOS 签名证书。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.fastlane.tools/actions/sigh/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;sigh&lt;/a&gt; 创建，更新，下载和修复配置文件。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.fastlane.tools/actions/snapshot/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;snapshot&lt;/a&gt; 自动在每台设备上获取 iOS 应用的本地化屏幕截图。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.fastlane.tools/actions/frameit/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;frameit&lt;/a&gt; 将您的屏幕截图放入正确的设备框架中。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.fastlane.tools/actions/gym/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;gym&lt;/a&gt; 构建和打包您的 iOS apps。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.fastlane.tools/actions/deliver/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;deliver&lt;/a&gt; 将截图，元数据和您的应用上传到 App Store。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.fastlane.tools/actions/pem/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;pem&lt;/a&gt; 自动生成并更新推送通知配置文件。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/fastlane/fastlane/tree/master/spaceship&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;spaceship&lt;/a&gt; 一个 Ruby 库能够访问苹果开发者中心和应用商店连接 api。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.fastlane.tools/actions/pilot/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;pilot&lt;/a&gt; 自动化 TestFlight 部署并管理测试用户。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/fastlane/boarding&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;boarding&lt;/a&gt; 邀请 beta 测试人员。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.fastlane.tools/actions/match/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;match&lt;/a&gt; 使用 Git 同步整个团队的证书和配置文件。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.fastlane.tools/actions/scan/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;scan&lt;/a&gt; 运行 app 测试。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="ios" scheme="https://zyf.im/tags/ios/"/>
    
      <category term="fastlane" scheme="https://zyf.im/tags/fastlane/"/>
    
  </entry>
  
  <entry>
    <title>PromiseKit 入门使用</title>
    <link href="https://zyf.im/2019/01/19/promisekit-getting-started/"/>
    <id>https://zyf.im/2019/01/19/promisekit-getting-started/</id>
    <published>2019-01-19T06:00:00.000Z</published>
    <updated>2019-01-19T06:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn-qn.yifans.com/imzyf/rawpixel-1054574-unsplash.jpg" alt="promisekit-getting-started"></p><p>在 GitHub Trending 中总是看到 <a href="https://github.com/mxcl/PromiseKit" target="_blank" rel="noopener">mxcl/PromiseKit</a> 它是主要解决的是 “回调地狱” 的问题，决定尝试用一下。</p><blockquote><p>环境：Swift 4.2、PromiseKit 6</p></blockquote><h2 id="then-and-done"><a href="#then-and-done" class="headerlink" title="then and done"></a>then and done</h2><p>下面是一个典型的 promise 链式（chain）调用：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firstly &#123;</span><br><span class="line">    login()</span><br><span class="line">&#125;.then &#123; creds in</span><br><span class="line">    fetch(avatar: creds.user)</span><br><span class="line">&#125;.done &#123; image in</span><br><span class="line">    self.imageView = image</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>如果这段代码使用完成回调（<code>completion handler</code>）实现，他将是：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">login &#123; creds, error in</span><br><span class="line">    if let creds = creds &#123;</span><br><span class="line">        fetch(avatar: creds.user) &#123; image, error in</span><br><span class="line">            if let image = image &#123;</span><br><span class="line">                self.imageView = image</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>then</code> 是完成回调的另一种方式，但是它更丰富。在处级阶段的理解，它更具有可读性。上面的 promise chain 更容易阅读和理解：一个异步操作接着另一个，一行接一行。它与程序代码非常接近，因为我们很容易得到 Swift 的当前状态。</p><p><code>done</code> 与 <code>then</code> 基本是一样的，但是它将不再返回 promise。它是典型的在末尾 “success” 部分的 chain。在上面的例子 <code>done</code> 中，我们接收到了最终的图片并使用它设置了 UI。</p><p>让我们对比一下两个 <code>login</code> 的方法签名：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Promise:</span><br><span class="line">func login() -&gt; Promise&lt;Creds&gt;</span><br><span class="line"></span><br><span class="line">// Compared with:</span><br><span class="line">func login(completion: (Creds?, Error?) -&gt; Void)</span><br><span class="line">                    // 可选型，两者都是可选</span><br></pre></td></tr></table></figure><p>区别在于 promise，方法返回 promises 而不是的接受和运行回调。每一个处理器（handler）都会返回一个 promise。Promise 对象们定义 <code>then</code> 方法，该方法在继续链式调用之前等待 promise 的完成。chains 在程序上解决，一次一个 promise。</p><p>Promise 代表未来异步方法的输入值。它有一个表示它包装的对象类型的类型。例如，在上面的例子里，<code>login</code> 的返回 Promise 值代表一个 Creds 的一个实例。</p><p>可以注意到这与 completion pattern 的不同，promises chain 似乎忽略错误。并不是这样，实际上：promise chain 使错误处理更容易访问（accessible），并使错误更难被忽略。</p><h2 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h2><p>有了 promises，错误在 promise chain 上级联（cascade along），确保你的应用的健壮（robust）和清晰的代码。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firstly &#123;</span><br><span class="line">    login()</span><br><span class="line">&#125;.then &#123; creds in</span><br><span class="line">    fetch(avatar: creds.user)</span><br><span class="line">&#125;.done &#123; image in</span><br><span class="line">    self.imageView = image</span><br><span class="line">&#125;.catch &#123;</span><br><span class="line">    // 整个 chain 上的错误都到了这里</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果你忘记了 catch 这个 chain，Swift 会发出警告</p></blockquote><p>每个 promise 都是一个表示单个（individual）异步任务的对象。如果任务失败，它的 promise 将成为 <code>rejected</code>。产生 <code>rejected</code> promises 将跳过后面所有的 <code>then</code>，而是将执行 <code>catch</code>。（严格上说是执行后续所有的 <code>catch</code> 处理）</p><p>这与 completion handler 对比：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func handle(error: Error) &#123;</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">login &#123; creds, error in</span><br><span class="line">    guard let creds = creds else &#123; return handle(error: error!) &#125;</span><br><span class="line">    fetch(avatar: creds.user) &#123; image, error in</span><br><span class="line">        guard let image = image else &#123; return handle(error: error!) &#125;</span><br><span class="line">        self.imageView.image = image</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>guard</code> 和合并错误对处理有所保证，但是 promise chain 更具有可读性。</p><h2 id="ensure"><a href="#ensure" class="headerlink" title="ensure"></a>ensure</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firstly &#123;</span><br><span class="line">    UIApplication.shared.isNetworkActivityIndicatorVisible = true</span><br><span class="line">    return login()</span><br><span class="line">&#125;.then &#123;</span><br><span class="line">    fetch(avatar: $0.user)</span><br><span class="line">&#125;.done &#123;</span><br><span class="line">    self.imageView = $0</span><br><span class="line">&#125;.ensure &#123;</span><br><span class="line">    UIApplication.shared.isNetworkActivityIndicatorVisible = false</span><br><span class="line">&#125;.catch &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论在 chain 哪里结束，成功或者失败，<code>ensure</code> 终将被执行。也可以使用 <code>finally</code> 来完成相同的事情，区别是没有返回值。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">spinner(visible: <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">firstly &#123;</span><br><span class="line">    foo()</span><br><span class="line">&#125;.done &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;.<span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;.finally &#123;</span><br><span class="line">    <span class="keyword">self</span>.spinner(visible: <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="when"><a href="#when" class="headerlink" title="when"></a>when</h2><p>多个异步操作同时处理时可能又难又慢。例如当 <code>操作1</code> 和 <code>操作2</code> 都完成时再返回结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 串行操作</span><br><span class="line">operation1 &#123; result1 in</span><br><span class="line">    operation2 &#123; result2 in</span><br><span class="line">        finish(result1, result2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 并行操作</span><br><span class="line">var result1: ...!</span><br><span class="line">var result2: ...!</span><br><span class="line">let group = DispatchGroup()</span><br><span class="line">group.enter()</span><br><span class="line">group.enter()</span><br><span class="line">operation1 &#123;</span><br><span class="line">    result1 = $0</span><br><span class="line">    group.leave()</span><br><span class="line">&#125;</span><br><span class="line">operation2 &#123;</span><br><span class="line">    result2 = $0</span><br><span class="line">    group.leave()</span><br><span class="line">&#125;</span><br><span class="line">group.notify(queue: .main) &#123;</span><br><span class="line">    finish(result1, result2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使人 Promises 将变得容易很多：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firstly &#123;</span><br><span class="line">    when(fulfilled: operation1(), operation2())</span><br><span class="line">&#125;.done &#123; result1, result2 in</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>when</code> 等待所有的完成再返回 promises 结果。</p><h2 id="PromiseKit-扩展"><a href="#PromiseKit-扩展" class="headerlink" title="PromiseKit 扩展"></a>PromiseKit 扩展</h2><p>PromiseKit 提过了一些 Apple API 的扩展，例如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firstly &#123;</span><br><span class="line">    CLLocationManager.promise()</span><br><span class="line">&#125;.then &#123; location in</span><br><span class="line">    CLGeocoder.reverseGeocode(location)</span><br><span class="line">&#125;.done &#123; placemarks in</span><br><span class="line">    self.placemark.text = &quot;\(placemarks.first)&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时需要指定 subspaces：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pod &quot;PromiseKit&quot;</span><br><span class="line">pod &quot;PromiseKit/CoreLocation&quot;</span><br><span class="line">pod &quot;PromiseKit/MapKit&quot;</span><br></pre></td></tr></table></figure><p>更多的扩展可以查询 <a href="https://github.com/PromiseKit" target="_blank" rel="noopener">PromiseKit organization</a>，甚至扩展了 <a href="https://github.com/PromiseKit/Alamofire-" target="_blank" rel="noopener">Alamofire</a> 这样的公共库。</p><h2 id="制作-Promises"><a href="#制作-Promises" class="headerlink" title="制作 Promises"></a>制作 Promises</h2><p>有时你的 chains 仍然需要以自己开始，或许你使用的三方库没有提供 promises 或者自己写了异步系统，没关系，他们非常容易添加 promises。如果你查看了 PromiseKit 的标准扩展，可以看到使用了下面相同的描述：</p><p>已有代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func fetch(completion: (String?, Error?) -&gt; Void)</span><br></pre></td></tr></table></figure><p>转换：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func fetch() -&gt; Promise&lt;String&gt; &#123;</span><br><span class="line">    return Promise &#123; fetch(completion: $0.resolve) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更具有可读性的：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func fetch() -&gt; Promise&lt;String&gt; &#123;</span><br><span class="line">    return Promise &#123; seal in</span><br><span class="line">        fetch &#123; result, error in</span><br><span class="line">            seal.resolve(result, error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Promise 初始化程序提供的 <code>seal</code> 对象定义了很多处理 <code>garden-variety</code> 完成回调的方法。</p><blockquote><p>PromiseKit 设置尝试以 <code>Promise(fetch)</code> 进行处理，但是完成通过编译器的消歧义。</p></blockquote><h2 id="Guarantee"><a href="#Guarantee" class="headerlink" title="Guarantee"></a>Guarantee<t></t></h2><p>从 PromiseKit 5 开始，提供了 Guarantee 以做补充，目的是完善 Swift 强的的异常处理。</p><p><code>Guarantee</code> 永远不会失败，所以不能被 <code>rejected</code>。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firstly &#123;</span><br><span class="line">    after(seconds: 0.1)</span><br><span class="line">&#125;.done &#123;</span><br><span class="line">    // 这里不要加 catch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Guarantee</code> 的语法相较更简单：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func fetch() -&gt; Promise&lt;String&gt; &#123;</span><br><span class="line">    return Guarantee &#123; seal in</span><br><span class="line">        fetch &#123; result in</span><br><span class="line">            seal(result)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 减少为</span><br><span class="line"></span><br><span class="line">func fetch() -&gt; Promise&lt;String&gt; &#123;</span><br><span class="line">    return Guarantee(resolver: fetch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="map-compactMap-等"><a href="#map-compactMap-等" class="headerlink" title="map compactMap 等"></a>map compactMap 等</h2><ul><li><code>then</code> 要求返回另一个 promise</li><li><code>map</code> 要求返回一个 object 或 value 类型</li><li><code>compactMap</code> 要求返回一个 可选型，如过返回 <code>nil</code>，chain 将失败并报错 <code>PMKError.compactMap</code></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firstly &#123;</span><br><span class="line">    URLSession.shared.dataTask(.promise, with: rq)</span><br><span class="line">&#125;.compactMap &#123;</span><br><span class="line">    try JSONSerialization.jsonObject($0.data) as? [String]</span><br><span class="line">&#125;.done &#123; arrayOfStrings in</span><br><span class="line">    // ...</span><br><span class="line">&#125;.catch &#123; error in</span><br><span class="line">    // Foundation.JSONError if JSON was badly formed</span><br><span class="line">    // PMKError.compactMap if JSON was of different type</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外还有：<code>thenMap</code> <code>compactMapValues</code> <code>firstValue</code> etc</p><h2 id="get"><a href="#get" class="headerlink" title="get"></a>get</h2><p><code>get</code> 会得到 <code>done</code> 中相同值。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firstly &#123;</span><br><span class="line">    foo()</span><br><span class="line">&#125;.get &#123; foo in</span><br><span class="line">    // ...</span><br><span class="line">&#125;.done &#123; foo in</span><br><span class="line">    // same foo!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="tap"><a href="#tap" class="headerlink" title="tap"></a>tap</h2><p>为 debug 提供 <code>tap</code>，与 <code>get</code> 类似但是可以得到 <code>Result&lt;T&gt;</code> 这样就可以检查 chain 上的值：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firstly &#123;</span><br><span class="line">    foo()</span><br><span class="line">&#125;.tap &#123;</span><br><span class="line">    print($0)</span><br><span class="line">&#125;.done &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;.catch &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="firstly"><a href="#firstly" class="headerlink" title="firstly"></a>firstly</h3><p>上面例子中的 <code>firstly</code> 是语法糖，非必须但是可以让 chains 更有可读性。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firstly &#123;</span><br><span class="line">    login()</span><br><span class="line">&#125;.then &#123; creds in</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 也可以</span><br><span class="line">login().then &#123; creds in</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>知识点：<code>login()</code> 返回了一个 <code>Promise</code>，同时所有的 <code>Promise</code> 有一个 <code>then</code> 方法。<code>firstly</code> 返回一个 <code>Promise</code>，同样 <code>then</code> 也返回一个 <code>Promise</code>。</p><h3 id="when-变种"><a href="#when-变种" class="headerlink" title="when 变种"></a>when 变种</h3><ul><li><code>when(fulfilled:)</code> 在所有异步操作执行完后才执行回调，一个失败 chain 将 rejects。It’s important to note that all promises in the when continue. Promises have no control over the tasks they represent. Promises are just wrappers around tasks.</li><li><code>when(resolved:)</code> 使一个或多个组件承诺失败也会等待。此变体 <code>when</code> 生成的值是 <code>Result&lt;T&gt;</code> 的数组，所有要保证相同的泛型。</li><li><code>race</code> 只要有一个异步操作执行完毕，就立刻执行 <code>then</code> 回调。其它没有执行完毕的异步操作仍然会继续执行，而不是停止。</li></ul><h3 id="Swift-闭包接口"><a href="#Swift-闭包接口" class="headerlink" title="Swift 闭包接口"></a>Swift 闭包接口</h3><p>Swift 有自动推断返回值和单行返回。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">foo.then &#123;</span><br><span class="line">    bar($0)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// is the same as:</span><br><span class="line"></span><br><span class="line">foo.then &#123; baz -&gt; Promise&lt;String&gt; in</span><br><span class="line">    return bar(baz)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样有好有坏，具体可以查询 <a href="https://github.com/mxcl/PromiseKit/blob/master/Documentation/Troubleshooting.md" target="_blank" rel="noopener">Troubleshooting</a></p><h2 id="更多阅读"><a href="#更多阅读" class="headerlink" title="更多阅读"></a>更多阅读</h2><ul><li>强力建议阅读 <a href="https://mxcl.dev/PromiseKit/reference/v6/Classes/Promise.html" target="_blank" rel="noopener">API Reference</a></li><li>在 Xcode 使用 optinon-click 阅读 PromiseKit 代码</li><li>在网上有一些 PMK &lt; 5 的文章，里面的 API 有些不同要注意</li></ul><blockquote><p>Reference:</p><ul><li><a href="https://github.com/mxcl/PromiseKit/blob/master/Documentation/GettingStarted.md" target="_blank" rel="noopener">Getting Started</a></li><li><a href="https://www.hangge.com/blog/cache/detail_2231.html" target="_blank" rel="noopener">Swift - 异步编程库 PromiseKit 使用详解 1（安装配置、基本用法）</a></li></ul></blockquote><p>– EOF –</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn-qn.yifans.com/imzyf/rawpixel-1054574-unsplash.jpg&quot; alt=&quot;promisekit-getting-started&quot;&gt;&lt;/p&gt;
&lt;p&gt;在 GitHub Trending 中总是看到 &lt;a href=&quot;https://github.com/mxcl/PromiseKit&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;mxcl/PromiseKit&lt;/a&gt; 它是主要解决的是 “回调地狱” 的问题，决定尝试用一下。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;环境：Swift 4.2、PromiseKit 6&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;then-and-done&quot;&gt;&lt;a href=&quot;#then-and-done&quot; class=&quot;headerlink&quot; title=&quot;then and done&quot;&gt;&lt;/a&gt;then and done&lt;/h2&gt;&lt;p&gt;下面是一个典型的 promise 链式（chain）调用：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;firstly &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    login()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;.then &amp;#123; creds in&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    fetch(avatar: creds.user)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;.done &amp;#123; image in&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    self.imageView = image&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="ios" scheme="https://zyf.im/tags/ios/"/>
    
  </entry>
  
  <entry>
    <title>二分查找 Binary Search</title>
    <link href="https://zyf.im/2018/12/10/binary-search/"/>
    <id>https://zyf.im/2018/12/10/binary-search/</id>
    <published>2018-12-10T06:00:00.000Z</published>
    <updated>2018-12-10T06:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn-qn.yifans.com/imzyf/anelale-najera-764022-unsplash.jpg" alt="binary-search"></p><p>快速从一个数组中查找一个元素。</p><h2 id="Linear-Search-线性查找"><a href="#Linear-Search-线性查找" class="headerlink" title="Linear Search 线性查找"></a>Linear Search 线性查找</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func linearSearch&lt;T: Equatable&gt;(_ a: [T], _ key: T) -&gt; Int? &#123;</span><br><span class="line">    for i in 0 ..&lt; a.count &#123;</span><br><span class="line">        if a[i] == key &#123;</span><br><span class="line">            return i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线性查找在最坏情况：遍历了整个数组，但没有找到合适的元素。平均要遍历一半的元素性能为 <code>O(n)</code>，而二分查找的效率为 <code>O(log n)</code>，也就是说一个有 <code>1,000,000</code> 元素的数组只需要 <code>20</code> 步就可以找到想要的元素 <code>log_2(1,000,000) = 19.9</code>。</p><a id="more"></a><p>但是二分查找要求数组必须是排好序。</p><p>二分查找步骤：</p><ol><li>将数组分为两半。</li><li>判断想要找的元素是在左边数组还是右边，这也是数组需要排好顺序的原因。</li><li>如果要的元素在左边，就将左边的数组分成更小的两部分，并判断要的元素在哪部分。</li><li>重复步骤直到找到想要的元素。如果数组不能进一步查分，就说明要找的元素不在数组中。</li></ol><p>divide-and-conquer</p><h2 id="The-code"><a href="#The-code" class="headerlink" title="The code"></a>The code</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func binarySearch&lt;T: Comparable&gt;(_ a: [T], key: T, range: Range&lt;Int&gt;) -&gt; Int? &#123;</span><br><span class="line">    if range.lowerBound &gt;= range.upperBound &#123;</span><br><span class="line">        // If we get here, then the search key is not present in the array.</span><br><span class="line">        return nil</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // Calculate where to split the array.</span><br><span class="line">        let midIndex = range.lowerBound + (range.upperBound - range.lowerBound) / 2</span><br><span class="line"></span><br><span class="line">        // Is the search key in the left half?</span><br><span class="line">        if a[midIndex] &gt; key &#123;</span><br><span class="line">            return binarySearch(a, key: key, range: range.lowerBound ..&lt; midIndex)</span><br><span class="line"></span><br><span class="line">        // Is the search key in the right half?</span><br><span class="line">        // 这里 + 1 的原因是排除 midIndex 中间值</span><br><span class="line">        &#125; else if a[midIndex] &lt; key &#123;</span><br><span class="line">            return binarySearch(a, key: key, range: midIndex + 1 ..&lt; range.upperBound)</span><br><span class="line"></span><br><span class="line">        // If we get here, then we&apos;ve found the search key!</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return midIndex</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 19 numbers</span><br><span class="line">let numbers = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67]</span><br><span class="line"></span><br><span class="line">// 0 ..&lt; numbers.count 覆盖所有范围</span><br><span class="line">binarySearch(numbers, key: 43, range: 0 ..&lt; numbers.count)  // gives 13</span><br></pre></td></tr></table></figure><p>二分查找是将数组分为两个，但是我们不需要正真的创建两个新数组。取而代之，我们使用 Swift <code>Range</code> 对象跟踪这些拆分。左闭右开。upperBound 总是比最后一个元素的索引多一。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">midIndex = (lowerBound + upperBound) / 2</span><br></pre></td></tr></table></figure><p>如果这样写将存在一个 bug，就是当这两值非常大时，将存在一个越界的问题。</p><h2 id="Iterative-vs-recursive-迭代-vs-递归"><a href="#Iterative-vs-recursive-迭代-vs-递归" class="headerlink" title="Iterative vs recursive 迭代 vs 递归"></a>Iterative vs recursive 迭代 vs 递归</h2><p>二分查找本质是递归。</p><p>使用迭代的方式实现：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func binarySearch(_ a: [Int], key: Int) -&gt; Int? &#123;</span><br><span class="line">    var lowerBound = 0</span><br><span class="line">    var upperBound = a.count</span><br><span class="line">    while lowerBound &lt; upperBound &#123;</span><br><span class="line">        // 这行僵硬了 没有必要的</span><br><span class="line">        var range = lowerBound ..&lt; upperBound</span><br><span class="line">        let midIndex = range.lowerBound + (range.upperBound - range.lowerBound) / 2</span><br><span class="line">        let midValue = a[midIndex]</span><br><span class="line">        if key &lt; midValue &#123;</span><br><span class="line">            upperBound = midIndex</span><br><span class="line">        &#125; else if key &gt; midValue &#123;</span><br><span class="line">            lowerBound = midIndex + 1</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return midIndex</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="The-end"><a href="#The-end" class="headerlink" title="The end"></a>The end</h2><p>查找前数组一定要先排序吗？这取决于排序花费的时间，有时候：数组排序加二分查找比线性搜索还要慢。二分查找的优势在于一次排序后多次查找。</p><p>文章代码：<a href="https://github.com/imzyf/data-structure-and-algorithm/tree/master/004-Binary%20Search" target="_blank" rel="noopener">GitHub - imzyf/data-structure-and-algorithm/004-Binary Search/</a>。</p><blockquote><p>Reference:</p><ul><li><a href="https://github.com/raywenderlich/swift-algorithm-club/tree/master/Binary%20Search" target="_blank" rel="noopener">raywenderlich/swift-algorithm-club/Binary Search</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn-qn.yifans.com/imzyf/anelale-najera-764022-unsplash.jpg&quot; alt=&quot;binary-search&quot;&gt;&lt;/p&gt;
&lt;p&gt;快速从一个数组中查找一个元素。&lt;/p&gt;
&lt;h2 id=&quot;Linear-Search-线性查找&quot;&gt;&lt;a href=&quot;#Linear-Search-线性查找&quot; class=&quot;headerlink&quot; title=&quot;Linear Search 线性查找&quot;&gt;&lt;/a&gt;Linear Search 线性查找&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;func linearSearch&amp;lt;T: Equatable&amp;gt;(_ a: [T], _ key: T) -&amp;gt; Int? &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    for i in 0 ..&amp;lt; a.count &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if a[i] == key &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            return i&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return nil&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;线性查找在最坏情况：遍历了整个数组，但没有找到合适的元素。平均要遍历一半的元素性能为 &lt;code&gt;O(n)&lt;/code&gt;，而二分查找的效率为 &lt;code&gt;O(log n)&lt;/code&gt;，也就是说一个有 &lt;code&gt;1,000,000&lt;/code&gt; 元素的数组只需要 &lt;code&gt;20&lt;/code&gt; 步就可以找到想要的元素 &lt;code&gt;log_2(1,000,000) = 19.9&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="swift" scheme="https://zyf.im/tags/swift/"/>
    
      <category term="algorithm" scheme="https://zyf.im/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>插入排序 Insertion Sort</title>
    <link href="https://zyf.im/2018/11/24/insertion-sort/"/>
    <id>https://zyf.im/2018/11/24/insertion-sort/</id>
    <published>2018-11-24T08:00:00.000Z</published>
    <updated>2018-11-24T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn-qn.yifans.com/imzyf/jordane-mathieu-539965-unsplash.jpg" alt="insertion-sort"></p><p>将一个数组从高到低或者从低到高排序。</p><p>插入排序算法的工作原理：</p><ol><li>将若干数字放在一个数组里，数组是乱序的。</li><li>从数组中挑选一个数字，它是哪个并不重要，但是为了方便我们挑选数组头部的这个。</li><li>将这个数字插入到一个新的数组里。</li><li>从乱序数组里挑选下一个数字也将它放到新数组里。这个数字要么在第一个数字前或者后，所以这个两个数字是被排序的。</li><li>再次重从乱序数组里挑选下一个数字也将它放到新数组里，并将数字放在正确的位置。</li><li>一直如此进行直到乱序数组中没有数字。这时也将等到一个排序好的新数组。</li></ol><a id="more"></a><p>自己的一个实现：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let array = [2, 1, 3, 8, 3, 5, 4]</span><br><span class="line"></span><br><span class="line">var newArray = [Int]()</span><br><span class="line">for (k, v) in array.enumerated() &#123;</span><br><span class="line">    for (nK, nV) in newArray.enumerated() &#123;</span><br><span class="line">        // 本次的数 小于 存在的数的第一个(nv)</span><br><span class="line">        if v &lt; nV &#123;</span><br><span class="line">            newArray.insert(v, at: nK)</span><br><span class="line">            break</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 没有插入成功 放在末尾</span><br><span class="line">    if newArray.count &lt; k + 1 &#123;</span><br><span class="line">        newArray.append(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="In-place-sort"><a href="#In-place-sort" class="headerlink" title="In-place sort"></a>In-place sort</h2><p>上面的排序需要两个数组，一个原始的，一个排好顺序的。但是我们也可以 <em>就地排序</em> 无需创建一个额外的数组。我们只需要跟踪记录原始数组中哪里部分排好顺序了，哪一部分还没有排序。</p><p>举例：<code>[ 8, 3, 5, 4, 6 ]</code> 使用 <code>|</code> 分割是否排好顺序的部分。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 开始时 | 在最前</span><br><span class="line">[| 8, 3, 5, 4, 6 ]</span><br><span class="line"></span><br><span class="line">// 开始向左移动，左侧只有个 8 无论什么顺序都是正确的，右侧是未排序的部分</span><br><span class="line">[ 8 | 3, 5, 4, 6 ]</span><br><span class="line"></span><br><span class="line">// 依次进行 将未排序的头部元素放在已排部分的正确位置</span><br><span class="line">[ 3, 8 | 5, 4, 6 ]</span><br><span class="line">[ 3, 5, 8 | 4, 6 ]</span><br><span class="line">[ 3, 4, 5, 8 | 6 ]</span><br><span class="line">[ 3, 4, 5, 6, 8 |]</span><br></pre></td></tr></table></figure><p>每次 <code>|</code> 移动，都对左侧进行排序，未排序的部分逐渐减少，排序部分增加。直到未排序部分为零。</p><h2 id="How-to-insert"><a href="#How-to-insert" class="headerlink" title="How to insert"></a>How to insert</h2><p>将未排序的头部元素放在已排部分的正确位置，如何这到这点的？</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 从此状态开始。下个说的 4，我们需要将 4 插入到 [ 3, 5, 8 ] 这个已经排好的数组里</span><br><span class="line">[ 3, 5, 8 | 4, 6 ]</span><br><span class="line"></span><br><span class="line">// 移动 |，这时我们注意 8 这个元素</span><br><span class="line">[ 3, 5, 8, 4 | 6 ]</span><br><span class="line">        ^</span><br><span class="line"></span><br><span class="line">// 8 大于 4，所有 8 应该在 4 的右边，8 与 4 进行位置调换</span><br><span class="line">[ 3, 5, 4, 8 | 6 ]</span><br><span class="line">        &lt;--&gt;</span><br><span class="line">      swapped</span><br><span class="line"></span><br><span class="line">// 将 4 与现在的前面的元素 5 进行比较，5 大于 4，所以 5 与 4 进行位置调换</span><br><span class="line">[ 3, 4, 5, 8 | 6 ]</span><br><span class="line">     &lt;--&gt;</span><br><span class="line">    swapped</span><br><span class="line"></span><br><span class="line">// 3 小于 4 这个数，所以我们完成了对 4 的排序，这时从头到 |，是排好顺序的</span><br><span class="line">[ 3, 4, 5, 8 | 6 ]</span><br></pre></td></tr></table></figure><p>这就是对插入排序算法的内循环的描述。</p><h2 id="The-code"><a href="#The-code" class="headerlink" title="The code"></a>The code</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func insertionSort(_ array: [Int]) -&gt; [Int] &#123;</span><br><span class="line">    // 1</span><br><span class="line">    var a = array</span><br><span class="line">    // 2</span><br><span class="line">    for x in 1..&lt;a.count &#123;</span><br><span class="line">        var y = x</span><br><span class="line">        // 3</span><br><span class="line">        while y &gt; 0 &amp;&amp; a[y] &lt; a[y - 1] &#123;</span><br><span class="line">            a.swapAt(y - 1, y)</span><br><span class="line">            y -= 1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>将 <code>array</code> 复制一个副本。因为我们无法直接修改参数中的 <code>array</code>，就想 Swift 自身的 <code>sort()</code>，<code>insertionSort()</code> 将返回一个排序顺序的副本数组。</li><li>两个循环在方法中。外层循环遍历轮到排序的元素，也就是从待排数组中挑选出头部的元素。<code>x</code> 索引为排好顺序的结尾索引同时也是待排数组的开头。记住，如何时间从开头到 <code>x</code> 永远都是排好顺序的，从 <code>x</code> 到最后的元素都是未排序的。</li><li>内层循环查询 x 索引位置的元素。这个元素可能小于之前排序顺序数组中的每一个元素。内层循环从后倒序遍历每一个已排序的元素，每次发现这个元素之前的元素比它大，则交互位置。当内层循环完成时，数组从开头到 x 将又是已排序的。</li></ol><p>tip：外层循环从索引 1 开始，而不是 0。将第一个元素从堆移动到排序部分实际上并没有改变任何东西，所以我们不妨跳过它。</p><h2 id="No-more-swaps"><a href="#No-more-swaps" class="headerlink" title="No more swaps"></a>No more swaps</h2><p>上面的插入排序可以正常的工作了。我们还可以通过移除调用 swap() 让程序更快一些。</p><p>我们可以将所有需要换位置的元素向右移动一个位置，然后将新数字复制到正确的位置。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ 3, 5, 8, 4 | 6 ]   remember 4</span><br><span class="line">           *</span><br><span class="line"></span><br><span class="line">[ 3, 5, 8, 8 | 6 ]   shift 8 to the right</span><br><span class="line">        ---&gt;</span><br><span class="line"></span><br><span class="line">[ 3, 5, 5, 8 | 6 ]   shift 5 to the right</span><br><span class="line">     ---&gt;</span><br><span class="line"></span><br><span class="line">[ 3, 4, 5, 8 | 6 ]   copy 4 into place</span><br><span class="line">     *</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func insertionSort(_ array: [Int]) -&gt; [Int] &#123;</span><br><span class="line">    var a = array</span><br><span class="line">    for x in 1..&lt;a.count &#123;</span><br><span class="line">        var y = x</span><br><span class="line">        let temp = a[y]</span><br><span class="line">        // tip</span><br><span class="line">        while y &gt; 0 &amp;&amp; temp &lt; a[y - 1] &#123;</span><br><span class="line">            // 1</span><br><span class="line">            a[y] = a[y - 1]</span><br><span class="line">            y -= 1</span><br><span class="line">        &#125;</span><br><span class="line">        // 2</span><br><span class="line">        a[y] = temp</span><br><span class="line">    &#125;</span><br><span class="line">    return a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>原本需要换位置的元素右移一个位置。</li><li>当内层结束时，<code>y</code> 的索引位置就是新元素的排序后的位置，将元素放在此。</li></ol><p>tip：这里我自己写成了 <code>while y &gt; 0 &amp;&amp; a[y] &lt; a[y - 1]</code> 这是不对的，因为我要找的是 <strong>原本</strong> 的 <code>a[y]</code> 的位置，但是循环一次后 <code>a[y]</code> 将发生变化。</p><h2 id="Making-it-generic"><a href="#Making-it-generic" class="headerlink" title="Making it generic"></a>Making it generic</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func insertionSort&lt;T&gt;(_ array: [T], _ isOrderedBefore: (T, T) -&gt; Bool) -&gt; [T] &#123;</span><br><span class="line">    var a = array</span><br><span class="line">    for x in 1..&lt;a.count &#123;</span><br><span class="line">        var y = x</span><br><span class="line">        let temp = a[y]</span><br><span class="line">        while y &gt; 0, isOrderedBefore(temp, a[y - 1])  &#123;</span><br><span class="line">            a[y] = a[y - 1]</span><br><span class="line">            y -= 1</span><br><span class="line">        &#125;</span><br><span class="line">        a[y] = temp</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过闭包来执行大小比较。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let numbers = [ 10, -1, 3, 9, 2, 27, 8, 5, 1, 3, 0, 26 ]</span><br><span class="line">insertionSort(numbers, &lt;)</span><br><span class="line"></span><br><span class="line">let objects = [ obj1, obj2, obj3, ... ]</span><br><span class="line">insertionSort(objects) &#123; $0.priority &lt; $1.priority &#125;</span><br></pre></td></tr></table></figure><p>插入排序是一种稳定 <code>stable</code> 的排序。当排序后具有相同排序键的元素保持相同的相对顺序时，排序是稳定的。这对于诸如数字或字符串之类的简单值并不重要，但在排序更复杂的对象时这很重要。在上面的示例中，如果两个对象具有相同的优先级，则无论其他属性的值如何，这两个对象都不会被交换。</p><h2 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h2><p>最差的插入排序是 <code>O(n^2)</code> 因为俩个相近的循环嵌套。其他排序算法（如快速排序和合并排序）具有 <code>O(n log n)</code> 性能，在大输入时速度更快。</p><p>插入排序实际上对于排序小数组非常快。某些标准库具有排序功能，当分区大小为 <code>10</code> 或更小时，可以从快速排序切换到插入排序。</p><p>将 <code>insertSort()</code> 与 Swift 的内置 <code>sort()</code> 进行比较。在大约 <code>100</code> 元素左右的阵列上，速度差异很小。但是，随着输入变大，<code>O(n^2)</code> 快速开始执行比 <code>O(n log n)</code> 差很多，并且插入排序无法跟上。</p><p>文章代码：<a href="https://github.com/imzyf/data-structure-and-algorithm/tree/master/003-Insertion%20Sort" target="_blank" rel="noopener">GitHub - imzyf/data-structure-and-algorithm/003-Insertion Sort/</a>。</p><blockquote><p>Reference:</p><ul><li><a href="https://github.com/raywenderlich/swift-algorithm-club/tree/master/Insertion%20Sort" target="_blank" rel="noopener">raywenderlich/swift-algorithm-club/Insertion Sort</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn-qn.yifans.com/imzyf/jordane-mathieu-539965-unsplash.jpg&quot; alt=&quot;insertion-sort&quot;&gt;&lt;/p&gt;
&lt;p&gt;将一个数组从高到低或者从低到高排序。&lt;/p&gt;
&lt;p&gt;插入排序算法的工作原理：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将若干数字放在一个数组里，数组是乱序的。&lt;/li&gt;
&lt;li&gt;从数组中挑选一个数字，它是哪个并不重要，但是为了方便我们挑选数组头部的这个。&lt;/li&gt;
&lt;li&gt;将这个数字插入到一个新的数组里。&lt;/li&gt;
&lt;li&gt;从乱序数组里挑选下一个数字也将它放到新数组里。这个数字要么在第一个数字前或者后，所以这个两个数字是被排序的。&lt;/li&gt;
&lt;li&gt;再次重从乱序数组里挑选下一个数字也将它放到新数组里，并将数字放在正确的位置。&lt;/li&gt;
&lt;li&gt;一直如此进行直到乱序数组中没有数字。这时也将等到一个排序好的新数组。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="swift" scheme="https://zyf.im/tags/swift/"/>
    
      <category term="algorithm" scheme="https://zyf.im/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>队列 Queue Data Structure</title>
    <link href="https://zyf.im/2018/11/22/queue-data-structure/"/>
    <id>https://zyf.im/2018/11/22/queue-data-structure/</id>
    <published>2018-11-22T08:00:00.000Z</published>
    <updated>2018-11-22T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn-qn.yifans.com/imzyf/mael-balland-1389916-unsplash.jpg" alt="queue-data-structure"></p><p>实现一个 <code>队列</code>，包括 <code>enqueue</code>、<code>dequeue</code>、<code>peek</code>。</p><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><p><code>队列</code> 核心也是 array，A queue gives you a FIFO or first-in, first-out order. 队列是：先进先出的。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public struct Queue&lt;T&gt; &#123;    </span><br><span class="line">    fileprivate var array = [T]()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="enqueue"><a href="#enqueue" class="headerlink" title="enqueue"></a>enqueue</h2><p>进队，在数组尾部追加元素。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public mutating func enqueue(_ element: T) &#123;</span><br><span class="line">    array.append(element)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="dequeue"><a href="#dequeue" class="headerlink" title="dequeue"></a>dequeue</h2><p>出队，将首位的元素移除。因为首位元素移除后，其他元素依次向前移动，所以是 O(n)。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public var isEmpty: Bool &#123;</span><br><span class="line">    // 使用数组自身的方法，而不是 array.count &gt; 0</span><br><span class="line">    return array.isEmpty</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public mutating func dequeue() -&gt; T? &#123;</span><br><span class="line">    // 使用定义的变量</span><br><span class="line">    if isEmpty &#123;</span><br><span class="line">        return nil</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return array.removeLast()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="peek"><a href="#peek" class="headerlink" title="peek"></a>peek</h2><p>查看队首元素。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/// peek() 改为更有语义话的只读变量</span><br><span class="line">public var front: T? &#123;</span><br><span class="line">    return array.first</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优化出队"><a href="#优化出队" class="headerlink" title="优化出队"></a>优化出队</h2><p>在出队后不移动元素而是移动 <code>起始索引</code>，就像动的收银台而不是排队的人。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/// 优化 队列 的出队</span><br><span class="line">public struct OptimizedQueue&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    /// 这里改为了可选型，为了可以清理无效的元素</span><br><span class="line">    fileprivate var array = [T?]()</span><br><span class="line">    /// 起始索引</span><br><span class="line">    fileprivate var head = 0</span><br><span class="line"></span><br><span class="line">    public var count: Int &#123;</span><br><span class="line">        // 减去 起始索引 前面的数量</span><br><span class="line">        return array.count - head</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public var isEmpty: Bool &#123;</span><br><span class="line">        // 根据实际数量判断</span><br><span class="line">        return count == 0</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 保持不变</span><br><span class="line">    public mutating func enqueue(_ element: T) &#123;</span><br><span class="line">        array.append(element)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public mutating func dequeue() -&gt; T? &#123;</span><br><span class="line">        guard head &lt; array.count,</span><br><span class="line">            let element = array[head] else &#123;</span><br><span class="line">            return nil</span><br><span class="line">        &#125;</span><br><span class="line">        // 置空当前位置元素</span><br><span class="line">        array[head] = nil</span><br><span class="line">        // 前移起始索引</span><br><span class="line">        head += 1</span><br><span class="line"></span><br><span class="line">        // 空索引的占用比例</span><br><span class="line">        let percentage = Double(head)/Double(array.count)</span><br><span class="line">        // 50 0.25 都是魔法数字，主要是为了控制数组修剪的频率，可以自行调整</span><br><span class="line">        if array.count &gt; 50 &amp;&amp; percentage &gt; 0.25 &#123;</span><br><span class="line">            // 将起始空元素删除</span><br><span class="line">            array.removeFirst(head)</span><br><span class="line">            // 重置 起始索引</span><br><span class="line">            head = 0</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return element</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public var front: T? &#123;</span><br><span class="line">        if isEmpty &#123;</span><br><span class="line">            return nil</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 根据 起始索引进行 返回</span><br><span class="line">            return array[head]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文章代码：<a href="https://github.com/imzyf/data-structure-and-algorithm/tree/master/002-Queue" target="_blank" rel="noopener">GitHub - imzyf/data-structure-and-algorithm/002-Queue/</a>。</p><blockquote><p>Reference:</p><ul><li><a href="https://github.com/raywenderlich/swift-algorithm-club/tree/master/Queue" target="_blank" rel="noopener">raywenderlich/swift-algorithm-club/Queue</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn-qn.yifans.com/imzyf/mael-balland-1389916-unsplash.jpg&quot; alt=&quot;queue-data-structure&quot;&gt;&lt;/p&gt;
&lt;p&gt;实现一个 &lt;code&gt;队列&lt;/code&gt;，包括 &lt;code&gt;enqueue&lt;/code&gt;、&lt;code&gt;dequeue&lt;/code&gt;、&lt;code&gt;peek&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;Queue&quot;&gt;&lt;a href=&quot;#Queue&quot; class=&quot;headerlink&quot; title=&quot;Queue&quot;&gt;&lt;/a&gt;Queue&lt;/h2&gt;&lt;p&gt;&lt;code&gt;队列&lt;/code&gt; 核心也是 array，A queue gives you a FIFO or first-in, first-out order. 队列是：先进先出的。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public struct Queue&amp;lt;T&amp;gt; &amp;#123;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    fileprivate var array = [T]()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="swift" scheme="https://zyf.im/tags/swift/"/>
    
      <category term="algorithm" scheme="https://zyf.im/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>栈 Stack Data Structure</title>
    <link href="https://zyf.im/2018/11/22/stack-data-structure/"/>
    <id>https://zyf.im/2018/11/22/stack-data-structure/</id>
    <published>2018-11-22T06:00:00.000Z</published>
    <updated>2018-11-22T06:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn-qn.yifans.com/imzyf/johnson-wang-20675-unsplash.jpg" alt="queue-data-structure"></p><p>加入 <a href="https://github.com/raywenderlich/swift-algorithm-club" target="_blank" rel="noopener">Swift Algorithm Club</a> /‘ælgə’rɪðəm/，回炉重新学习数据结构与算法。</p><p>自己创建的项目：<a href="https://github.com/imzyf/data-structure-and-algorithm" target="_blank" rel="noopener">GitHub - imzyf/data-structure-and-algorithm</a>。</p><p>实现一个 <code>栈</code> /stæk/，包含 <code>push</code> <code>peek</code> <code>pop</code> 与 <code>Generics</code> 泛型。</p><a id="more"></a><h2 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h2><p><code>栈</code> 非常像一个数组，它包括少量的方法。</p><ul><li>push 添加一个新元素到栈顶</li><li>pop 从栈顶移除一个元素</li><li>peek 查看栈顶的一个元素但是不 pop</li></ul><p>A stack gives you a LIFO or last-in first-out order. 栈是后进先出，队列是先进先出。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public struct Stack&lt;Element&gt; &#123;</span><br><span class="line">    fileprivate var array: [Element] = []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="push"><a href="#push" class="headerlink" title="push"></a>push</h2><p><code>push</code> 是在数组的尾部添加元素是以 <code>O(1)</code>，如果是在数组最前添加是 <code>O(n)</code> 这是昂贵的。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public mutating func push(_ element: Element) &#123;</span><br><span class="line">  array.append(element)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为使用的 <code>struct</code>，修改属性值的方法要加 <code>mutating</code>。</p><h2 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h2><p>想从一个空栈中弹出最后一个元素将返回 <code>nil</code>。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public mutating func pop(_ element: Element) &#123;</span><br><span class="line">    return array.popLast()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="peek"><a href="#peek" class="headerlink" title="peek"></a>peek</h2><p>与 <code>pop</code> 有点像，但是并没有移除栈顶的元素。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/// peek 改为更加语义化的 top 只读变量</span><br><span class="line">public var top: T? &#123;</span><br><span class="line">    return array.last</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="other"><a href="#other" class="headerlink" title="other"></a>other</h2><p>两个其他的常用属性，栈是否为空，栈中元素的个数。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public var isEmpty: Bool &#123;</span><br><span class="line">  return array.isEmpty</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public var count: Int &#123;</span><br><span class="line">  return array.count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Reference:</p><ul><li><a href="https://www.raywenderlich.com/800-swift-algorithm-club-swift-stack-data-structure" target="_blank" rel="noopener">Swift Algorithm Club: Swift Stack Data Structure</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn-qn.yifans.com/imzyf/johnson-wang-20675-unsplash.jpg&quot; alt=&quot;queue-data-structure&quot;&gt;&lt;/p&gt;
&lt;p&gt;加入 &lt;a href=&quot;https://github.com/raywenderlich/swift-algorithm-club&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Swift Algorithm Club&lt;/a&gt; /‘ælgə’rɪðəm/，回炉重新学习数据结构与算法。&lt;/p&gt;
&lt;p&gt;自己创建的项目：&lt;a href=&quot;https://github.com/imzyf/data-structure-and-algorithm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub - imzyf/data-structure-and-algorithm&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;实现一个 &lt;code&gt;栈&lt;/code&gt; /stæk/，包含 &lt;code&gt;push&lt;/code&gt; &lt;code&gt;peek&lt;/code&gt; &lt;code&gt;pop&lt;/code&gt; 与 &lt;code&gt;Generics&lt;/code&gt; 泛型。&lt;/p&gt;
    
    </summary>
    
    
      <category term="swift" scheme="https://zyf.im/tags/swift/"/>
    
      <category term="algorithm" scheme="https://zyf.im/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>解决 Too many symbol files</title>
    <link href="https://zyf.im/2018/10/30/correct-too-many-symbol-files-issues/"/>
    <id>https://zyf.im/2018/10/30/correct-too-many-symbol-files-issues/</id>
    <published>2018-10-30T06:00:00.000Z</published>
    <updated>2018-10-30T06:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn-qn.yifans.com/imzyf/mika-baumeister-703680-unsplash.jpg" alt="correct-too-many-symbol-files-issues"></p><p>在上传 App 到 App Store 后收到邮件，有 issues <strong>Too many symbol files</strong>。在之前看到 <em>Your delivery was successful</em>，此 issues 不影响发布，所以一直搁置了。</p><p>今天决定彻底处理下。</p><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>先说 <code>*.symbols</code> 这文件是干嘛的，我现在（2018-10）对此的理解：</p><ul><li>symbols 为符号表文件</li><li>符号表是内存地址与函数名、文件名、行号的映射表 <code>&lt;起始地址&gt; &lt;结束地址&gt; &lt;函数&gt; [&lt;文件名:行号&gt;]</code></li></ul><p>为什么要配置符号表？</p><p>为了能快速并准确地定位用户 App 发生 <strong>Crash 的代码位置</strong>，使用符号表对 App 发生 Crash 的程序 <em>堆栈</em> 进行 <em>解析</em> 和 <em>还原</em>。</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwq98vcjeoj30i00383yh.jpg" alt="为什么要配置符号表"></p><h2 id="项目情况"><a href="#项目情况" class="headerlink" title="项目情况"></a>项目情况</h2><p>再说下项目情况，因为数字都是用了的是 Int，为防止 32 位设备发生越界情况（理由好像有点扯），所以项目端设置了设备限制 <code>arm64</code>，也就是 5s 之前的设备不可以安装。</p><p>因为使用了三方库，但是三方库是支持 32 位设备的，所以生成了冗余的 symbols 文件。</p><p>查询 symbols 文件的生成情况：Xcode Window -&gt; Organizer 选择有问题的 archive，右击选择 Show in finder，命令行进入 *.app 中的 dSYMs 文件夹，执行 <code>dwarfdump --uuid *</code> 可以查询到是否生成了多余的文件。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>在 <code>Podfile</code> 中：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">post_install do |installer|</span><br><span class="line">  installer.pods_project.targets.each do |target|</span><br><span class="line">    target.build_configurations.each do |config|</span><br><span class="line">      config.build_settings[&apos;ENABLE_BITCODE&apos;] = &apos;NO&apos;</span><br><span class="line">      config.build_settings[&apos;ARCHS&apos;] = &apos;arm64&apos;</span><br><span class="line">    end</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h2 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h2><p>在 <code>info.plist</code> 中：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;key&gt;UIRequiredDeviceCapabilities&lt;/key&gt;</span><br><span class="line">&lt;array&gt;</span><br><span class="line">    &lt;string&gt;arm64&lt;/string&gt;</span><br><span class="line">&lt;/array&gt;</span><br></pre></td></tr></table></figure><p>在 build Settings 搜索 <code>valid architecture</code> 中，填写 <code>arm64</code></p><blockquote><p>Reference:</p><ul><li><a href="https://stackoverflow.com/questions/25755240/too-many-symbol-files-after-successfully-submitting-my-apps" target="_blank" rel="noopener">“Too many symbol files” after successfully submitting my apps</a></li><li><a href="https://stackoverflow.com/questions/34313049/too-many-symbol-files-warnning-when-submitting-app" target="_blank" rel="noopener">“Too many symbol files” warnning when submitting app</a></li><li><a href="https://www.jianshu.com/p/3511ec38ca20" target="_blank" rel="noopener">App提交iTunes Connect,”二进制无效”问题解决方案。</a></li><li><a href="https://bugly.qq.com/docs/user-guide/symbol-configuration-ios/?v=20180709165613#_2" target="_blank" rel="noopener">Bugly iOS 符号表配置</a></li></ul></blockquote><p>– EOF –</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn-qn.yifans.com/imzyf/mika-baumeister-703680-unsplash.jpg&quot; alt=&quot;correct-too-many-symbol-files-issues&quot;&gt;&lt;/p&gt;
&lt;p&gt;在上传 App 到 App Store 后收到邮件，有 issues &lt;strong&gt;Too many symbol files&lt;/strong&gt;。在之前看到 &lt;em&gt;Your delivery was successful&lt;/em&gt;，此 issues 不影响发布，所以一直搁置了。&lt;/p&gt;
&lt;p&gt;今天决定彻底处理下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="ios" scheme="https://zyf.im/tags/ios/"/>
    
  </entry>
  
  <entry>
    <title>2018.08 工程月度总结</title>
    <link href="https://zyf.im/2018/08/30/2018-08-monthly-report-of-development/"/>
    <id>https://zyf.im/2018/08/30/2018-08-monthly-report-of-development/</id>
    <published>2018-08-30T15:00:00.000Z</published>
    <updated>2018-10-09T15:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据库表索引被删除造成慢查询"><a href="#数据库表索引被删除造成慢查询" class="headerlink" title="数据库表索引被删除造成慢查询"></a>数据库表索引被删除造成慢查询</h2><p>为方便整理数据删除了索引，没有添加回来，上线后 SQL 查询堆积，拖慢项目。</p><a id="more"></a><h2 id="Google-Sites-amp-AWS-S3"><a href="#Google-Sites-amp-AWS-S3" class="headerlink" title="Google Sites &amp; AWS S3"></a>Google Sites &amp; AWS S3</h2><p>对 Search 排名有一定的 trick。</p><p><a href="https://sites.google.com" target="_blank" rel="noopener">Google Sites</a> 经典 classic 版本可以使用 <a href="https://github.com/googleapis/google-api-php-client" target="_blank" rel="noopener">API</a> 进行页面生成。SDK 没有封装好接口，需要结合文档自己写。</p><p>可使用的 HTML 标签是受限，推荐找一个已经有的网站仿照的写。</p><blockquote><p>待续</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;数据库表索引被删除造成慢查询&quot;&gt;&lt;a href=&quot;#数据库表索引被删除造成慢查询&quot; class=&quot;headerlink&quot; title=&quot;数据库表索引被删除造成慢查询&quot;&gt;&lt;/a&gt;数据库表索引被删除造成慢查询&lt;/h2&gt;&lt;p&gt;为方便整理数据删除了索引，没有添加回来，上线后 SQL 查询堆积，拖慢项目。&lt;/p&gt;
    
    </summary>
    
    
      <category term="report" scheme="https://zyf.im/tags/report/"/>
    
  </entry>
  
  <entry>
    <title>2018.07 工程月度总结</title>
    <link href="https://zyf.im/2018/07/30/2018-07-monthly-report-of-development/"/>
    <id>https://zyf.im/2018/07/30/2018-07-monthly-report-of-development/</id>
    <published>2018-07-30T15:00:00.000Z</published>
    <updated>2018-08-22T05:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用-…-运算符定义变长参数函数"><a href="#使用-…-运算符定义变长参数函数" class="headerlink" title="使用 … 运算符定义变长参数函数"></a>使用 … 运算符定义变长参数函数</h2><p>在写一方式时使用了 <code>...</code> 运算符，但是这个运算符是 PHP 5.6 增加的，线上是 PHP 5.5 导致 500 报错，环境问题暴露。</p><p>如果可能出错，就一定会出错。</p><blockquote><p><a href="http://php.net/manual/zh/migration56.new-features.php" target="_blank" rel="noopener">从 PHP 5.5.x 移植到 PHP 5.6.x</a></p></blockquote><a id="more"></a><h2 id="Ubuntu-核心参数"><a href="#Ubuntu-核心参数" class="headerlink" title="Ubuntu 核心参数"></a>Ubuntu 核心参数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net.ipv4.tcp_fin_timeout = 30</span><br><span class="line">net.ipv4.tcp_keepalive_time = 300</span><br><span class="line">net.ipv4.tcp_syncookies = 1</span><br><span class="line">net.ipv4.tcp_tw_reuse = 1</span><br><span class="line">net.ipv4.tcp_tw_recycle = 1</span><br><span class="line">net.ipv4.ip_local_port_range = 5000 65000</span><br></pre></td></tr></table></figure><p><code>sysctl -p</code> 显示系统内核参数变化。</p><p><em>其中含义待研究。</em></p><h2 id="etc-sysctl-conf"><a href="#etc-sysctl-conf" class="headerlink" title="/etc/sysctl.conf"></a>/etc/sysctl.conf</h2><p><code>net.ipv4.tcp_tw_recycle</code> 改为 <code>0</code></p><p><code>tcp_tw_recycle</code> 和 <code>tcp_timestmaps</code> 同时开启时，会有 risk，来自 NAT 网路的用户访问会有丢包情况从而导致 504。<code>tcp_tw_recycle</code> 默认是不开启的，之前的优化配置开启该选项时时并没有考虑这一点。从 Linux 4.12 开始，该选项已被移除。</p><h2 id="正确使用-Redis"><a href="#正确使用-Redis" class="headerlink" title="正确使用 Redis"></a>正确使用 Redis</h2><p>在读 Redis 大数组会占用大量的 PHP-FPM 内存，影响查询效率。</p><p>在大量（百万级）使用存储 Redis Key 发现慢查询，拖累服务器，<strong>是否是此原因待详细查</strong>。</p><p><em>如何正确使用 Redis、配置 Redis 需要总结。</em></p><h2 id="MySQL-索引选择"><a href="#MySQL-索引选择" class="headerlink" title="MySQL 索引选择"></a>MySQL 索引选择</h2><p>某查询中通过 explain 发现 MySQL 选择了一个较慢的索引，发现相同条件下不同的时间会使用不同的索引，引发了慢查询。</p><p><em>需要研究 MySQL 如何进行索引的选择，和如何建立合理的索引。</em></p><h2 id="AWS-EC2-服务器类型"><a href="#AWS-EC2-服务器类型" class="headerlink" title="AWS EC2 服务器类型"></a>AWS EC2 服务器类型</h2><p><code>定额配置</code> 与 <code>信用积分</code>，影响服务器性能。</p><h2 id="Python-SELECT-查询事务"><a href="#Python-SELECT-查询事务" class="headerlink" title="Python SELECT 查询事务"></a>Python SELECT 查询事务</h2><p>Python 的 <code>SELECT</code> 查询默认是事务性的操作，期间无法对表 <code>DDL</code> 进行改变。</p><p><code>SELECT</code> 语句也应该进行 <code>COMMIT</code>。</p><p><em>道听途说，待自测详查。</em></p><h2 id="try-catch-导致的死循环"><a href="#try-catch-导致的死循环" class="headerlink" title="try catch 导致的死循环"></a>try catch 导致的死循环</h2><p>外层函数 <code>while(1)</code> 内部 <code>catch</code> 后 <code>continue</code> 导致死循环，不能假设处理一定成功。</p><h2 id="NGINX-Log-中挖掘项目隐藏的问题"><a href="#NGINX-Log-中挖掘项目隐藏的问题" class="headerlink" title="NGINX Log 中挖掘项目隐藏的问题"></a>NGINX Log 中挖掘项目隐藏的问题</h2><ul><li>通过 log 监控流量、访问行为、发现爬虫</li><li>通过 log 分析非 200 状态码，检查项目页面</li></ul><h2 id="数据库字段中包含-HTML-元素导致页面错乱"><a href="#数据库字段中包含-HTML-元素导致页面错乱" class="headerlink" title="数据库字段中包含 HTML 元素导致页面错乱"></a>数据库字段中包含 HTML 元素导致页面错乱</h2><p>数据库数据有 <code>&lt;/div&gt;</code> 等标签，与模板元素连接在一起，导致页面错乱。</p><p>要显示的数据要 <code>htmlspecialchars</code> 转码。</p><h2 id="爬取检查时发生-Connection-to-the-other-side-was-lost-in-non-clean"><a href="#爬取检查时发生-Connection-to-the-other-side-was-lost-in-non-clean" class="headerlink" title="爬取检查时发生 Connection to the other side was lost in non-clean"></a>爬取检查时发生 Connection to the other side was lost in non-clean</h2><blockquote><p>thanks for xq24.</p></blockquote><p>Scrapy 快速的三次 retry 之后 give up，然后接着 url 都出现这个问题。</p><p>此时状态：</p><p>这时浏览器挂上代理能访问出现问题的 url，但是本地无代理时 IP 无法访问。</p><p>查看服务器 Log：</p><p>发现有状态码 499 但是，只有访问一次这个 url 会出现俩三个 499 的 response，然后一段时间内，整个站就都不能访问了，没有反应了，Nginx 日志里面也没有记录到任何东西了，说明数据没有到 Nginx 应该是 Tcp 层的网络有问题。</p><p>验证：</p><p><code>tcpdump</code> + <code>Wirsshark</code> 分析。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo tcpdump tcp -i eth0 -t -s 0 -c 1000 and dst port ! 22 -w ./target.cap</span><br></pre></td></tr></table></figure><p>出现了很多的 <code>RST</code> 导致 TCP 连接中断，仔细看，发现里面的 ACK 完全和上一个包的 Seq 对不上，我们客服端的 ACK 的是一个巨大的随机数。导致服务器端返回 <code>RST</code>。</p><p>因为项目是 HTTP 应用层的，不会影响到 TCP 层，所以 Google 关键字 <code>tcp reset + blogspot.com</code> 看到 reddit 一篇 8 年前的讨论。讲到了 <a href="https://www.reddit.com/r/programming/comments/aph4r/tcp_resets_how_the_baidublogspotgooglecomblockout/" target="_blank" rel="noopener">关于中国防火墙</a>。中国 GFW 会有根据 tcp 协议里面的关键字来进行屏蔽。然后会通过 reset 修改来屏蔽整个站几分钟。https 协议的不会。</p><p>测试了俩个国外的网站：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://site.aace.org/conf/blogspot.com</span><br><span class="line">http://www.motogp.com/blogspot.com</span><br></pre></td></tr></table></figure><p>加入了 blogspot.com 就无法访问了。</p><p>所以问题找到了中国 GFW 会通过 URL 里面的敏感字进行封锁网站，<a href="http://fanqianghuayuan.blogspot.com/2013/05/ignore-gfw.html" target="_blank" rel="noopener">有篇具体分析的文章</a>。线上因为用的 HTTPS 协议所以内容加密了，没有被 block，解决方法:</p><ul><li>将测试服务器换成 HTTPS 然后就可以访问了</li><li>通过代理访问</li></ul><h2 id="NGINX-Log-出现大量（10K）HTTP-499-错误"><a href="#NGINX-Log-出现大量（10K）HTTP-499-错误" class="headerlink" title="NGINX Log 出现大量（10K）HTTP 499 错误"></a>NGINX Log 出现大量（10K）HTTP 499 错误</h2><p><a href="https://httpstatuses.com/499" target="_blank" rel="noopener">499 CLIENT CLOSED REQUEST</a></p><p>A non-standard status code introduced by nginx for the case when a client closes the connection while nginx is processing the request.</p><p>NGINX Log 出现大量（10K）HTTP 499 错误，几乎都是 AJAX POST 请求。经过日志排查，发现这些 499 请求都是来自于 Safari 浏览器，再通过日志查看，这些请求都是正常的用户行为。在本地使用 Safari 浏览器实测时也是会出现这样的问题。基本可以断定是 Safari 浏览器导致。</p><p>最终确定为在点击一个 button 时同发送了两请求，分别为 async: false，async: true。</p><p>在进行控制变量的测试中，基本确定与 AJAX 同异步请求有关。不建议修改 async 为 false。</p><p>在测试的过程中，也发现虽然使用 Safari 请求显示 NGINX 日志中会显示 499，但是数据的记录并没有受到影响。</p><h2 id="服务器器运维工具-atop"><a href="#服务器器运维工具-atop" class="headerlink" title="服务器器运维工具 atop"></a>服务器器运维工具 atop</h2><p><em>待整理</em></p><h2 id="完全独立的分支"><a href="#完全独立的分支" class="headerlink" title="完全独立的分支"></a>完全独立的分支</h2><p>在使用 Git 进行版本控制的某些场景中我们可能需要在一个项目中建立完全独立的分支，此分支将作为一个独立的版本历史根节点，不与之前任何分支拥有相同的版本祖先。</p><p>比如当我们要在一个项目中使用一个分支进行项目文档的管理时，或者当我们想要发布一个软件的开源版本但又不希望将软件的版本历史暴露给外界时，都可以使用以下的方法建立一个独立分支。</p><p>通过带有 <code>--orphan</code> 参数的 <code>checkout</code> 命令即可从 <code>start_point</code> 或者 <code>HEAD</code> 创建一个独立分支：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout --orphan 新分支名 &lt;start_point&gt;</span><br></pre></td></tr></table></figure><p>如果希望创建全新的独立分支，例如用于文档管理，不想出现项目代码，则还需要进行如下删除操作。注意如果有不在索引中的文件，则需要手工删除（包括 .gitignore），删除此分支中的索引及索引中的所有文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git rm -rf .</span><br></pre></td></tr></table></figure><p>然后从新建立文件和提交。</p><p><em>通过一个独立分支管理文档？一个思路。</em></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;使用-…-运算符定义变长参数函数&quot;&gt;&lt;a href=&quot;#使用-…-运算符定义变长参数函数&quot; class=&quot;headerlink&quot; title=&quot;使用 … 运算符定义变长参数函数&quot;&gt;&lt;/a&gt;使用 … 运算符定义变长参数函数&lt;/h2&gt;&lt;p&gt;在写一方式时使用了 &lt;code&gt;...&lt;/code&gt; 运算符，但是这个运算符是 PHP 5.6 增加的，线上是 PHP 5.5 导致 500 报错，环境问题暴露。&lt;/p&gt;
&lt;p&gt;如果可能出错，就一定会出错。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://php.net/manual/zh/migration56.new-features.php&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;从 PHP 5.5.x 移植到 PHP 5.6.x&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="report" scheme="https://zyf.im/tags/report/"/>
    
  </entry>
  
  <entry>
    <title>2018.06 工程月度总结</title>
    <link href="https://zyf.im/2018/06/30/2018-06-monthly-report-of-development/"/>
    <id>https://zyf.im/2018/06/30/2018-06-monthly-report-of-development/</id>
    <published>2018-06-30T15:00:00.000Z</published>
    <updated>2018-06-30T15:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="未明确指定字段所属表的隐患"><a href="#未明确指定字段所属表的隐患" class="headerlink" title="未明确指定字段所属表的隐患"></a>未明确指定字段所属表的隐患</h2><p>在修改表结构时，在 <code>a</code> 表新添加 <code>name</code> 字段，<code>b</code> 表本事就有 <code>name</code> 字段；原来的项目中有 <code>a</code> <code>b</code> 表的关联查询，并用到了 <code>name</code> 字段</p><p>这时，因为 <code>a</code> 表中也添加了 <code>name</code> 字段，原来 <code>name</code> 指的是 <code>a</code> 还是 <code>b</code> 表中的变的不确定了，造成报错。</p><p>主要原因就是在连表时：未明确指定字段所属表，造成了伏笔。</p><a id="more"></a><h2 id="数据库枚举值的坑"><a href="#数据库枚举值的坑" class="headerlink" title="数据库枚举值的坑"></a>数据库枚举值的坑</h2><p>在数据库使用枚举时可以规范数据字典，但是也造成了要添加值时，需要修改数据库结构，这是不可接受的。</p><p>而且枚举值查询可以使用 <code>0</code>,<code>1</code>,<code>2</code>.. 索引值进行查询，也可以使用 ‘public’ ‘private’ 这样的规定的字典值查询，有二义性，可能有伏笔。</p><p>字典类型的字段我都以 <code>_type</code> 结尾，<code>tinyint</code> 型，无符号，数字代表的值写在字段注释里。eg: book_type</p><p>有 <code>是否</code> 概念的字段也不要用 枚举，我会使用 <code>is_</code> 开头。eg: is_review</p><p>补充说明：</p><p>枚举类型不但可以使用下标 <code>0</code>,<code>1</code>,<code>2</code>.. 查询，也可以使用不加引号的 <code>0</code>,<code>1</code>,<code>2</code>..（下标）来写入某个类型。</p><p>举个栗子：</p><p>类型：<code>enum(&#39;none&#39;,&#39;public&#39;,&#39;private&#39;,&#39;1&#39;)</code> 当你 <code>insert into ... set a = 1</code> 时：</p><p>当 <code>a = 1</code> 是插入 enum 的第一个值，即 public。</p><p>当 <code>a = &#39;1&#39;</code> 是插入 enum 值为 1 的类型。</p><p>所以在 PHP 弱类型语言中，数字可以不加单引号，所以要注意到这点。</p><h2 id="ThinkPHP-3-addAll-插入错误"><a href="#ThinkPHP-3-addAll-插入错误" class="headerlink" title="ThinkPHP 3 addAll 插入错误"></a>ThinkPHP 3 addAll 插入错误</h2><p>在使用 <code>addAll</code> 插入多条数据时，要保证每条数据的结构是一样的，数组的 key 不要有多有少，会导致插入失败。</p><h2 id="修改存储引擎和大数据更快导入"><a href="#修改存储引擎和大数据更快导入" class="headerlink" title="修改存储引擎和大数据更快导入"></a>修改存储引擎和大数据更快导入</h2><p>今天要修改一个表的 存储引擎，表有 2G 数据，直接修改等了 1 个多小时都没完成。</p><p>所以想到先 <code>mysqldump --no-create-info</code> 导出数据，然后清空表，修改存储引擎，再倒回数据。</p><p>倒回数据时，数据导入越来越慢，想到可能是 <code>索引</code> 问题，然后删除索引，再倒回数据果然快很多。</p><p><a href="https://www.jb51.net/article/53595.htm" target="_blank" rel="noopener">MySQL 导出所有 Index 和约束的方法</a></p><blockquote><p>提问：更改存储引擎的初衷是什么？更改前后有什么质的变化？</p></blockquote><p>原来是 MyISAM 历史问题，现在库中的表统一使用 InnoDB。</p><p>对于数据库优化，首先还是要考虑 SQL 优化，表的设计优化，其次才是数据库设置优化。</p><p>MyISAM 理论上读更快，表级锁，没事务；但是一般都是推荐使用 InnoDB 再具体原因还不清楚。</p><h2 id="NGINX-没有配置结束符的伏笔"><a href="#NGINX-没有配置结束符的伏笔" class="headerlink" title="NGINX 没有配置结束符的伏笔"></a>NGINX 没有配置结束符的伏笔</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location ~*.xml$ &#123;</span><br><span class="line">    rewrite &apos;^/sitemap/([a-z_0-9]*)\.(xml)$&apos; /sitemap/$1 last;</span><br><span class="line">    add_header X-Robots-Tag noindex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是配置 sitemap XML 转发和添加 header，在 <code>~*.xml$</code> 中，如果没有 <code>$</code> 会造成只要 slug 中有 <code>xml</code> 就进行了转发。eg: <code>/abc/abcxmldef</code> 将被转发 这是不符合预期的。</p><h2 id="MySQL-连接遇到的端口问题"><a href="#MySQL-连接遇到的端口问题" class="headerlink" title="MySQL 连接遇到的端口问题"></a>MySQL 连接遇到的端口问题</h2><p>自己的电脑有两个 MySQL 服务，一个 3306 一个 3307。</p><p>在使用 <code>mysql -uroot -p -P3307</code> 这样指定端口连接是无效的。</p><p>其实这个是 MySQL 故意设计的，如果你的 host 是 localhost（如果不指定默认也是 localhost），那 MySQL 必须用 unix socket 连接，那样的话设置端口什么的当然没用啦。所以正确的做法是指定 host 为 127.0.0.1 再指定端口，绝对管用。</p><p>查看端口：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show global variables like &apos;port&apos;;</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://www.chrisyue.com/set-no-port-when-mysql-connect-localhost.html" target="_blank" rel="noopener">MySQL 客户端的指定端口问题</a></p></blockquote><p>MySQL 配合文件的读取顺序和位置可以通过 <code>mysql --help</code> 查看。</p><h2 id="测试，坚持如一"><a href="#测试，坚持如一" class="headerlink" title="测试，坚持如一"></a>测试，坚持如一</h2><p>今天发现了：因为测试不全导致的手机端部分页面显示异常的情况。</p><p>问题的发现还是用户发现后反馈的。</p><p>原因：手机端的页面代码位置应该总体是和 PC 端是一致的，但是在整理代码时，一个两端的结构差异导致了缺少引用一个 JavaScript 库，在测试过程中，没有测试到此一级页面，PC 端代段此级正常。</p><p>还是自己懈怠了， 测试，坚持如一，欠的总会还。引以为戒。</p><h2 id="MySQL-用户不同导致的数据库无法打开"><a href="#MySQL-用户不同导致的数据库无法打开" class="headerlink" title="MySQL 用户不同导致的数据库无法打开"></a>MySQL 用户不同导致的数据库无法打开</h2><p>使用 Navicat 无法打开数据库，提示大概是权限什么的问题，使用 mysql 命令是可以的。</p><p>后来发现是：在线上建立了一个视图，使用的是一个远程用户，后来数据备份，视图也被备份到本地了。但是这个远程用户在本地是没有的，所以导致使用 Navicat 时，无法打开数据库。</p><h2 id="页面中-JavaScript-中正则表达式中的特殊字符被转码"><a href="#页面中-JavaScript-中正则表达式中的特殊字符被转码" class="headerlink" title="页面中 JavaScript 中正则表达式中的特殊字符被转码"></a>页面中 JavaScript 中正则表达式中的特殊字符被转码</h2><p>今天遇到 HTML 页面中直接写了 JavaScript 的验证的表达式：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&apos;[©]+&apos;</span><br></pre></td></tr></table></figure><p>里面涉及了一个特殊字符 <code>©</code>，页面第一次加载时，一起正常，但是 <code>ajax</code> 提交后，<code>pjax reload</code> 页面后，<code>©</code> 被 <code>encode</code>。</p><p>解决方法：使用 <code>unicode</code> <code>[\\u00A9]+·</code></p><p>一款很秀的 正则表达式 工具推荐给大家 <a href="jex.im/regulex">jex.im/regulex</a></p><h2 id="Firefox-word-break-break-word"><a href="#Firefox-word-break-break-word" class="headerlink" title="Firefox word-break: break-word"></a>Firefox word-break: break-word</h2><p>Firefox 疑似不支持 <code>word-break: break-word</code> 对词进行折行</p><ul><li>Use <code>word-break: break-all;</code> instead of <code>word-break: break-word;</code></li><li>Or, Use <code>word-wrap: break-word;</code> instead of <code>word-break: break-word;</code></li></ul><p>所以 CSS 编写要考虑好厂商差异，亟待使用前端工具，最近准备使用 gulp 优化项目前端</p><p><a href="https://stackoverflow.com/questions/17143614/word-breakbreak-word-not-working-in-firefox-21" target="_blank" rel="noopener">Word-break:break-word not working in Firefox 21</a></p><h2 id="Policy-条款要认真对待"><a href="#Policy-条款要认真对待" class="headerlink" title="Policy 条款要认真对待"></a>Policy 条款要认真对待</h2><p>在做部分功能是违反了 Google Policy，被直接标记为恶意网站，流量骤降。</p><p>对应敏感信息要认真对待不可轻视。</p><h2 id="数据查询的-N-1-问题"><a href="#数据查询的-N-1-问题" class="headerlink" title="数据查询的 N+1 问题"></a>数据查询的 N+1 问题</h2><p><a href="https://laravel-china.org/topics/7778/summary-using-the-laravel-development-tool-the-n-1-problem-of-the-orm-query" target="_blank" rel="noopener">N+1 查询问题</a> 就是查询扩展字段时的循环查询问题。</p><p>为了解决 N+1 问题我使用了模型 <a href="https://laravel-china.org/docs/laravel/5.5/eloquent-relationships/1265#eager-loading" target="_blank" rel="noopener">预加载</a> 方式，但是由于后台框架限制（也可能是使用不当），将 <em>一对多</em> 的被关联的模型数据都查出来了，数据量很大，导致页面卡顿，一次反向优化。</p><p>优化要权衡不能硬搬书本。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;未明确指定字段所属表的隐患&quot;&gt;&lt;a href=&quot;#未明确指定字段所属表的隐患&quot; class=&quot;headerlink&quot; title=&quot;未明确指定字段所属表的隐患&quot;&gt;&lt;/a&gt;未明确指定字段所属表的隐患&lt;/h2&gt;&lt;p&gt;在修改表结构时，在 &lt;code&gt;a&lt;/code&gt; 表新添加 &lt;code&gt;name&lt;/code&gt; 字段，&lt;code&gt;b&lt;/code&gt; 表本事就有 &lt;code&gt;name&lt;/code&gt; 字段；原来的项目中有 &lt;code&gt;a&lt;/code&gt; &lt;code&gt;b&lt;/code&gt; 表的关联查询，并用到了 &lt;code&gt;name&lt;/code&gt; 字段&lt;/p&gt;
&lt;p&gt;这时，因为 &lt;code&gt;a&lt;/code&gt; 表中也添加了 &lt;code&gt;name&lt;/code&gt; 字段，原来 &lt;code&gt;name&lt;/code&gt; 指的是 &lt;code&gt;a&lt;/code&gt; 还是 &lt;code&gt;b&lt;/code&gt; 表中的变的不确定了，造成报错。&lt;/p&gt;
&lt;p&gt;主要原因就是在连表时：未明确指定字段所属表，造成了伏笔。&lt;/p&gt;
    
    </summary>
    
    
      <category term="report" scheme="https://zyf.im/tags/report/"/>
    
  </entry>
  
  <entry>
    <title>AWS CLI 入门使用</title>
    <link href="https://zyf.im/2018/06/22/aws-cli-getting-started/"/>
    <id>https://zyf.im/2018/06/22/aws-cli-getting-started/</id>
    <published>2018-06-22T03:00:00.000Z</published>
    <updated>2018-08-18T09:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul><li><a href="https://docs.aws.amazon.com/cli/latest/userguide/awscli-install-linux.html" target="_blank" rel="noopener">AWS CLI - User Guide</a></li></ul><p><code>apt</code> <code>yum</code> 中也有 <code>awscli</code> 包，但是不保证是最新版本，所以推荐使用 <code>pip</code> 安装。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ pip install awscli --upgrade --user</span><br><span class="line"></span><br><span class="line">$ aws --version</span><br></pre></td></tr></table></figure><p>这个发现使用 <code>pip</code> 总是安装失败，原因暂不明，后来是使用 <code>pip3</code> 安装成功的。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ls -a ~</span><br></pre></td></tr></table></figure><p>在 <code>.bashrc</code> 或者 <code>.zshrc</code> 中添加：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export PATH=~/.local/bin:$PATH</span><br></pre></td></tr></table></figure><p>应用：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ source ~/.bashrc</span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ aws configure</span><br></pre></td></tr></table></figure><p>配置文件默认存储在了 <code>~/.aws</code></p><h2 id="S3-命令"><a href="#S3-命令" class="headerlink" title="S3 命令"></a>S3 命令</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ aws s3 help</span><br><span class="line"></span><br><span class="line">$ aws s3 sync help</span><br></pre></td></tr></table></figure><h3 id="文件同步"><a href="#文件同步" class="headerlink" title="文件同步"></a>文件同步</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">aws s3 sync ./coupon s3://www.couponscdn.com/ --exclude &quot;*.DS_Store&quot; --cache-control max-age=2592000</span><br></pre></td></tr></table></figure><ul><li>exclude 排除文件</li><li>cache-control  游览器缓存时间</li></ul><h3 id="备份脚本"><a href="#备份脚本" class="headerlink" title="备份脚本"></a>备份脚本</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">/home/ubuntu/.local/bin/aws s3 sync s3://S3URI /home/ubuntu/LocalPath</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.aws.amazon.com/cli/latest/userguide/awscli-install-linux.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;AWS CLI - User Guide&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;apt&lt;/code&gt; &lt;code&gt;yum&lt;/code&gt; 中也有 &lt;code&gt;awscli&lt;/code&gt; 包，但是不保证是最新版本，所以推荐使用 &lt;code&gt;pip&lt;/code&gt; 安装。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ pip install awscli --upgrade --user&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ aws --version&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个发现使用 &lt;code&gt;pip&lt;/code&gt; 总是安装失败，原因暂不明，后来是使用 &lt;code&gt;pip3&lt;/code&gt; 安装成功的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="aws" scheme="https://zyf.im/tags/aws/"/>
    
  </entry>
  
</feed>
