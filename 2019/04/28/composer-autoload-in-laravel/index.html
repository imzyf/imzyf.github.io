<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Laravel 中 composer 加载流程 | ZYF.IM BLOG</title><meta name=keywords content="php,composer"><meta name=description content="启动

Laravel 5.8

文章以 Laravel 学习。入口文件 public/index.php：
// Register The Auto Loader
require __DIR__.'/../vendor/autoload.php';
autoload.php 不负责具体功能逻辑，只做了两件事：初始化自动加载类、注册自动加载类。
autoload_real.php 中的类名为 ComposerAutoloaderInit... 这可能是为防止与用户自定义类名跟这个类重复冲突，加上了哈希值。
其实还有一个做法我们更加熟悉，是定义一个命名空间。这里为什么不定义一个命名空间呢？一种理解：命名空间一般都是为了复用，而这个类只需要运行一次即可，以后也不会用得到，用哈希值更加合适。

autoload_real.php
autoload.php 主要调用了 getLoader()：
public static function getLoader()
{
    // 单例模式，自动加载类只能有一个 1
    if (null !== self::$loader) {
        return self::$loader;
    }

    // 获得自动加载核心类对象 2
    spl_autoload_register(array('ComposerAutoloaderInit76e88f0b305cd64c7c84b90b278c31db', 'loadClassLoader'), true, true);
    self::$loader = $loader = new \Composer\Autoload\ClassLoader();
    spl_autoload_unregister(array('ComposerAutoloaderInit76e88f0b305cd64c7c84b90b278c31db', 'loadClassLoader'));

    // 初始化自动加载核心类对象 3
    $useStaticLoader = PHP_VERSION_ID >= 50600 && !defined('HHVM_VERSION') && (!function_exists('zend_loader_file_encoded') || !zend_loader_file_encoded());
    if ($useStaticLoader) {
        require_once __DIR__ . '/autoload_static.php';

        call_user_func(\Composer\Autoload\ComposerStaticInit76e88f0b305cd64c7c84b90b278c31db::getInitializer($loader));
    } else {
        $map = require __DIR__ . '/autoload_namespaces.php';
        foreach ($map as $namespace => $path) {
            $loader->set($namespace, $path);
        }

        $map = require __DIR__ . '/autoload_psr4.php';
        foreach ($map as $namespace => $path) {
            $loader->setPsr4($namespace, $path);
        }

        $classMap = require __DIR__ . '/autoload_classmap.php';
        if ($classMap) {
            $loader->addClassMap($classMap);
        }
    }

    // 注册自动加载核心类对象 4
    $loader->register(true);

    // 自动加载全局函数 5
    if ($useStaticLoader) {
        $includeFiles = Composer\Autoload\ComposerStaticInit76e88f0b305cd64c7c84b90b278c31db::$files;
    } else {
        $includeFiles = require __DIR__ . '/autoload_files.php';
    }
    foreach ($includeFiles as $fileIdentifier => $file) {
        composerRequire76e88f0b305cd64c7c84b90b278c31db($fileIdentifier, $file);
    }

    return $loader;
}
单例模式 1
if (null !== self::$loader) {
    return self::$loader;
}
构造 ClassLoader 核心类 2
spl_autoload_register(array('ComposerAutoloaderInit76e88f0b305cd64c7c84b90b278c31db', 'loadClassLoader'), true, true);
self::$loader = $loader = new \Composer\Autoload\ClassLoader();
spl_autoload_unregister(array('ComposerAutoloaderInit76e88f0b305cd64c7c84b90b278c31db', 'loadClassLoader'));
public static function loadClassLoader($class)
{
    if ('Composer\Autoload\ClassLoader' === $class) {
        require __DIR__ . '/ClassLoader.php';
    }
}
composer 先向 PHP 自动加载机制注册了一个函数，这个函数 require 了 ClassLoader 文件。成功 new 出该文件中核心类 ClassLoader() 后，又销毁了该函数。"><meta name=author content="Me"><link rel=canonical href=https://zyf.im/2019/04/28/composer-autoload-in-laravel/><link crossorigin=anonymous href=/assets/css/stylesheet.63618a0fd0c7dd946ad6f368012c097fc6e5a8464cefd289c140dd28c01ec58d.css integrity="sha256-Y2GKD9DH3ZRq1vNoASwJf8blqEZM79KJwUDdKMAexY0=" rel="preload stylesheet" as=style><link rel=icon href=https://zyf.im/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zyf.im/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://zyf.im/favicon-32x32.png><link rel=apple-touch-icon href=https://zyf.im/apple-touch-icon.png><link rel=mask-icon href=https://zyf.im/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://zyf.im/2019/04/28/composer-autoload-in-laravel/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-6DVZ6E58DG"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-6DVZ6E58DG")}</script><meta property="og:url" content="https://zyf.im/2019/04/28/composer-autoload-in-laravel/"><meta property="og:site_name" content="ZYF.IM BLOG"><meta property="og:title" content="Laravel 中 composer 加载流程"><meta property="og:description" content="启动 Laravel 5.8 文章以 Laravel 学习。入口文件 public/index.php：
// Register The Auto Loader require __DIR__.'/../vendor/autoload.php'; autoload.php 不负责具体功能逻辑，只做了两件事：初始化自动加载类、注册自动加载类。
autoload_real.php 中的类名为 ComposerAutoloaderInit... 这可能是为防止与用户自定义类名跟这个类重复冲突，加上了哈希值。
其实还有一个做法我们更加熟悉，是定义一个命名空间。这里为什么不定义一个命名空间呢？一种理解：命名空间一般都是为了复用，而这个类只需要运行一次即可，以后也不会用得到，用哈希值更加合适。
autoload_real.php autoload.php 主要调用了 getLoader()：
public static function getLoader() { // 单例模式，自动加载类只能有一个 1 if (null !== self::$loader) { return self::$loader; } // 获得自动加载核心类对象 2 spl_autoload_register(array('ComposerAutoloaderInit76e88f0b305cd64c7c84b90b278c31db', 'loadClassLoader'), true, true); self::$loader = $loader = new \Composer\Autoload\ClassLoader(); spl_autoload_unregister(array('ComposerAutoloaderInit76e88f0b305cd64c7c84b90b278c31db', 'loadClassLoader')); // 初始化自动加载核心类对象 3 $useStaticLoader = PHP_VERSION_ID >= 50600 && !defined('HHVM_VERSION') && (!function_exists('zend_loader_file_encoded') || !zend_loader_file_encoded()); if ($useStaticLoader) { require_once __DIR__ . '/autoload_static.php'; call_user_func(\Composer\Autoload\ComposerStaticInit76e88f0b305cd64c7c84b90b278c31db::getInitializer($loader)); } else { $map = require __DIR__ . '/autoload_namespaces.php'; foreach ($map as $namespace => $path) { $loader->set($namespace, $path); } $map = require __DIR__ . '/autoload_psr4.php'; foreach ($map as $namespace => $path) { $loader->setPsr4($namespace, $path); } $classMap = require __DIR__ . '/autoload_classmap.php'; if ($classMap) { $loader->addClassMap($classMap); } } // 注册自动加载核心类对象 4 $loader->register(true); // 自动加载全局函数 5 if ($useStaticLoader) { $includeFiles = Composer\Autoload\ComposerStaticInit76e88f0b305cd64c7c84b90b278c31db::$files; } else { $includeFiles = require __DIR__ . '/autoload_files.php'; } foreach ($includeFiles as $fileIdentifier => $file) { composerRequire76e88f0b305cd64c7c84b90b278c31db($fileIdentifier, $file); } return $loader; } 单例模式 1 if (null !== self::$loader) { return self::$loader; } 构造 ClassLoader 核心类 2 spl_autoload_register(array('ComposerAutoloaderInit76e88f0b305cd64c7c84b90b278c31db', 'loadClassLoader'), true, true); self::$loader = $loader = new \Composer\Autoload\ClassLoader(); spl_autoload_unregister(array('ComposerAutoloaderInit76e88f0b305cd64c7c84b90b278c31db', 'loadClassLoader')); public static function loadClassLoader($class) { if ('Composer\Autoload\ClassLoader' === $class) { require __DIR__ . '/ClassLoader.php'; } } composer 先向 PHP 自动加载机制注册了一个函数，这个函数 require 了 ClassLoader 文件。成功 new 出该文件中核心类 ClassLoader() 后，又销毁了该函数。"><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-04-28T19:21:12+08:00"><meta property="article:modified_time" content="2019-04-28T19:21:12+08:00"><meta property="article:tag" content="Php"><meta property="article:tag" content="Composer"><meta name=twitter:card content="summary"><meta name=twitter:title content="Laravel 中 composer 加载流程"><meta name=twitter:description content="启动

Laravel 5.8

文章以 Laravel 学习。入口文件 public/index.php：
// Register The Auto Loader
require __DIR__.'/../vendor/autoload.php';
autoload.php 不负责具体功能逻辑，只做了两件事：初始化自动加载类、注册自动加载类。
autoload_real.php 中的类名为 ComposerAutoloaderInit... 这可能是为防止与用户自定义类名跟这个类重复冲突，加上了哈希值。
其实还有一个做法我们更加熟悉，是定义一个命名空间。这里为什么不定义一个命名空间呢？一种理解：命名空间一般都是为了复用，而这个类只需要运行一次即可，以后也不会用得到，用哈希值更加合适。

autoload_real.php
autoload.php 主要调用了 getLoader()：
public static function getLoader()
{
    // 单例模式，自动加载类只能有一个 1
    if (null !== self::$loader) {
        return self::$loader;
    }

    // 获得自动加载核心类对象 2
    spl_autoload_register(array('ComposerAutoloaderInit76e88f0b305cd64c7c84b90b278c31db', 'loadClassLoader'), true, true);
    self::$loader = $loader = new \Composer\Autoload\ClassLoader();
    spl_autoload_unregister(array('ComposerAutoloaderInit76e88f0b305cd64c7c84b90b278c31db', 'loadClassLoader'));

    // 初始化自动加载核心类对象 3
    $useStaticLoader = PHP_VERSION_ID >= 50600 && !defined('HHVM_VERSION') && (!function_exists('zend_loader_file_encoded') || !zend_loader_file_encoded());
    if ($useStaticLoader) {
        require_once __DIR__ . '/autoload_static.php';

        call_user_func(\Composer\Autoload\ComposerStaticInit76e88f0b305cd64c7c84b90b278c31db::getInitializer($loader));
    } else {
        $map = require __DIR__ . '/autoload_namespaces.php';
        foreach ($map as $namespace => $path) {
            $loader->set($namespace, $path);
        }

        $map = require __DIR__ . '/autoload_psr4.php';
        foreach ($map as $namespace => $path) {
            $loader->setPsr4($namespace, $path);
        }

        $classMap = require __DIR__ . '/autoload_classmap.php';
        if ($classMap) {
            $loader->addClassMap($classMap);
        }
    }

    // 注册自动加载核心类对象 4
    $loader->register(true);

    // 自动加载全局函数 5
    if ($useStaticLoader) {
        $includeFiles = Composer\Autoload\ComposerStaticInit76e88f0b305cd64c7c84b90b278c31db::$files;
    } else {
        $includeFiles = require __DIR__ . '/autoload_files.php';
    }
    foreach ($includeFiles as $fileIdentifier => $file) {
        composerRequire76e88f0b305cd64c7c84b90b278c31db($fileIdentifier, $file);
    }

    return $loader;
}
单例模式 1
if (null !== self::$loader) {
    return self::$loader;
}
构造 ClassLoader 核心类 2
spl_autoload_register(array('ComposerAutoloaderInit76e88f0b305cd64c7c84b90b278c31db', 'loadClassLoader'), true, true);
self::$loader = $loader = new \Composer\Autoload\ClassLoader();
spl_autoload_unregister(array('ComposerAutoloaderInit76e88f0b305cd64c7c84b90b278c31db', 'loadClassLoader'));
public static function loadClassLoader($class)
{
    if ('Composer\Autoload\ClassLoader' === $class) {
        require __DIR__ . '/ClassLoader.php';
    }
}
composer 先向 PHP 自动加载机制注册了一个函数，这个函数 require 了 ClassLoader 文件。成功 new 出该文件中核心类 ClassLoader() 后，又销毁了该函数。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zyf.im/posts/"},{"@type":"ListItem","position":2,"name":"Laravel 中 composer 加载流程","item":"https://zyf.im/2019/04/28/composer-autoload-in-laravel/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Laravel 中 composer 加载流程","name":"Laravel 中 composer 加载流程","description":"启动 Laravel 5.8 文章以 Laravel 学习。入口文件 public/index.php：\n// Register The Auto Loader require __DIR__.\u0026#39;/../vendor/autoload.php\u0026#39;; autoload.php 不负责具体功能逻辑，只做了两件事：初始化自动加载类、注册自动加载类。\nautoload_real.php 中的类名为 ComposerAutoloaderInit... 这可能是为防止与用户自定义类名跟这个类重复冲突，加上了哈希值。\n其实还有一个做法我们更加熟悉，是定义一个命名空间。这里为什么不定义一个命名空间呢？一种理解：命名空间一般都是为了复用，而这个类只需要运行一次即可，以后也不会用得到，用哈希值更加合适。\nautoload_real.php autoload.php 主要调用了 getLoader()：\npublic static function getLoader() { // 单例模式，自动加载类只能有一个 1 if (null !== self::$loader) { return self::$loader; } // 获得自动加载核心类对象 2 spl_autoload_register(array(\u0026#39;ComposerAutoloaderInit76e88f0b305cd64c7c84b90b278c31db\u0026#39;, \u0026#39;loadClassLoader\u0026#39;), true, true); self::$loader = $loader = new \\Composer\\Autoload\\ClassLoader(); spl_autoload_unregister(array(\u0026#39;ComposerAutoloaderInit76e88f0b305cd64c7c84b90b278c31db\u0026#39;, \u0026#39;loadClassLoader\u0026#39;)); // 初始化自动加载核心类对象 3 $useStaticLoader = PHP_VERSION_ID \u0026gt;= 50600 \u0026amp;\u0026amp; !defined(\u0026#39;HHVM_VERSION\u0026#39;) \u0026amp;\u0026amp; (!function_exists(\u0026#39;zend_loader_file_encoded\u0026#39;) || !zend_loader_file_encoded()); if ($useStaticLoader) { require_once __DIR__ . \u0026#39;/autoload_static.php\u0026#39;; call_user_func(\\Composer\\Autoload\\ComposerStaticInit76e88f0b305cd64c7c84b90b278c31db::getInitializer($loader)); } else { $map = require __DIR__ . \u0026#39;/autoload_namespaces.php\u0026#39;; foreach ($map as $namespace =\u0026gt; $path) { $loader-\u0026gt;set($namespace, $path); } $map = require __DIR__ . \u0026#39;/autoload_psr4.php\u0026#39;; foreach ($map as $namespace =\u0026gt; $path) { $loader-\u0026gt;setPsr4($namespace, $path); } $classMap = require __DIR__ . \u0026#39;/autoload_classmap.php\u0026#39;; if ($classMap) { $loader-\u0026gt;addClassMap($classMap); } } // 注册自动加载核心类对象 4 $loader-\u0026gt;register(true); // 自动加载全局函数 5 if ($useStaticLoader) { $includeFiles = Composer\\Autoload\\ComposerStaticInit76e88f0b305cd64c7c84b90b278c31db::$files; } else { $includeFiles = require __DIR__ . \u0026#39;/autoload_files.php\u0026#39;; } foreach ($includeFiles as $fileIdentifier =\u0026gt; $file) { composerRequire76e88f0b305cd64c7c84b90b278c31db($fileIdentifier, $file); } return $loader; } 单例模式 1 if (null !== self::$loader) { return self::$loader; } 构造 ClassLoader 核心类 2 spl_autoload_register(array(\u0026#39;ComposerAutoloaderInit76e88f0b305cd64c7c84b90b278c31db\u0026#39;, \u0026#39;loadClassLoader\u0026#39;), true, true); self::$loader = $loader = new \\Composer\\Autoload\\ClassLoader(); spl_autoload_unregister(array(\u0026#39;ComposerAutoloaderInit76e88f0b305cd64c7c84b90b278c31db\u0026#39;, \u0026#39;loadClassLoader\u0026#39;)); public static function loadClassLoader($class) { if (\u0026#39;Composer\\Autoload\\ClassLoader\u0026#39; === $class) { require __DIR__ . \u0026#39;/ClassLoader.php\u0026#39;; } } composer 先向 PHP 自动加载机制注册了一个函数，这个函数 require 了 ClassLoader 文件。成功 new 出该文件中核心类 ClassLoader() 后，又销毁了该函数。\n","keywords":["php","composer"],"articleBody":"启动 Laravel 5.8 文章以 Laravel 学习。入口文件 public/index.php：\n// Register The Auto Loader require __DIR__.'/../vendor/autoload.php'; autoload.php 不负责具体功能逻辑，只做了两件事：初始化自动加载类、注册自动加载类。\nautoload_real.php 中的类名为 ComposerAutoloaderInit... 这可能是为防止与用户自定义类名跟这个类重复冲突，加上了哈希值。\n其实还有一个做法我们更加熟悉，是定义一个命名空间。这里为什么不定义一个命名空间呢？一种理解：命名空间一般都是为了复用，而这个类只需要运行一次即可，以后也不会用得到，用哈希值更加合适。\nautoload_real.php autoload.php 主要调用了 getLoader()：\npublic static function getLoader() { // 单例模式，自动加载类只能有一个 1 if (null !== self::$loader) { return self::$loader; } // 获得自动加载核心类对象 2 spl_autoload_register(array('ComposerAutoloaderInit76e88f0b305cd64c7c84b90b278c31db', 'loadClassLoader'), true, true); self::$loader = $loader = new \\Composer\\Autoload\\ClassLoader(); spl_autoload_unregister(array('ComposerAutoloaderInit76e88f0b305cd64c7c84b90b278c31db', 'loadClassLoader')); // 初始化自动加载核心类对象 3 $useStaticLoader = PHP_VERSION_ID \u003e= 50600 \u0026\u0026 !defined('HHVM_VERSION') \u0026\u0026 (!function_exists('zend_loader_file_encoded') || !zend_loader_file_encoded()); if ($useStaticLoader) { require_once __DIR__ . '/autoload_static.php'; call_user_func(\\Composer\\Autoload\\ComposerStaticInit76e88f0b305cd64c7c84b90b278c31db::getInitializer($loader)); } else { $map = require __DIR__ . '/autoload_namespaces.php'; foreach ($map as $namespace =\u003e $path) { $loader-\u003eset($namespace, $path); } $map = require __DIR__ . '/autoload_psr4.php'; foreach ($map as $namespace =\u003e $path) { $loader-\u003esetPsr4($namespace, $path); } $classMap = require __DIR__ . '/autoload_classmap.php'; if ($classMap) { $loader-\u003eaddClassMap($classMap); } } // 注册自动加载核心类对象 4 $loader-\u003eregister(true); // 自动加载全局函数 5 if ($useStaticLoader) { $includeFiles = Composer\\Autoload\\ComposerStaticInit76e88f0b305cd64c7c84b90b278c31db::$files; } else { $includeFiles = require __DIR__ . '/autoload_files.php'; } foreach ($includeFiles as $fileIdentifier =\u003e $file) { composerRequire76e88f0b305cd64c7c84b90b278c31db($fileIdentifier, $file); } return $loader; } 单例模式 1 if (null !== self::$loader) { return self::$loader; } 构造 ClassLoader 核心类 2 spl_autoload_register(array('ComposerAutoloaderInit76e88f0b305cd64c7c84b90b278c31db', 'loadClassLoader'), true, true); self::$loader = $loader = new \\Composer\\Autoload\\ClassLoader(); spl_autoload_unregister(array('ComposerAutoloaderInit76e88f0b305cd64c7c84b90b278c31db', 'loadClassLoader')); public static function loadClassLoader($class) { if ('Composer\\Autoload\\ClassLoader' === $class) { require __DIR__ . '/ClassLoader.php'; } } composer 先向 PHP 自动加载机制注册了一个函数，这个函数 require 了 ClassLoader 文件。成功 new 出该文件中核心类 ClassLoader() 后，又销毁了该函数。\n为什么不直接 require？原因是：怕有的用户也定义了个 \\Composer\\Autoload\\ClassLoader 命名空间，导致自动加载错误文件。\n那为什么不跟引导类一样用个哈希值呢？原因是：这个类是可以复用的，框架允许用户使用这个类。\n初始化核心类对象 3 对自动加载类的初始化，主要是给自动加载核心类初始化顶级命名空间映射。初始化的方法有两种：\n使用 autoload_static 进行静态初始化 调用核心类接口初始化 autoload_static 静态初始化 静态初始化只支持 PHP 5.6 以上版本、不支持 HHVM 虚拟机、不存在 Zend-encoded file。\nautoload_static.php\n\u003c?php // autoload_static.php @generated by Composer namespace Composer\\Autoload; // hash 防止冲突 class ComposerStaticInit76e88f0b305cd64c7c84b90b278c31db { public static $files = array (...); public static $prefixLengthsPsr4 = array (...); public static $prefixDirsPsr4 = array (...); public static $fallbackDirsPsr4 = array (...); public static $prefixesPsr0 = array (...); public static $classMap = array array (...); public static function getInitializer(ClassLoader $loader) { return \\Closure::bind(function () use ($loader) { $loader-\u003eprefixLengthsPsr4 = ComposerStaticInit76e88f0b305cd64c7c84b90b278c31db::$prefixLengthsPsr4; $loader-\u003eprefixDirsPsr4 = ComposerStaticInit76e88f0b305cd64c7c84b90b278c31db::$prefixDirsPsr4; $loader-\u003efallbackDirsPsr4 = ComposerStaticInit76e88f0b305cd64c7c84b90b278c31db::$fallbackDirsPsr4; $loader-\u003eprefixesPsr0 = ComposerStaticInit76e88f0b305cd64c7c84b90b278c31db::$prefixesPsr0; $loader-\u003eclassMap = ComposerStaticInit76e88f0b305cd64c7c84b90b278c31db::$classMap; }, null, ClassLoader::class); } } 这个静态初始化类的核心就是 getInitializer() 函数，它将自己类中的顶级命名空间映射给了 ClassLoader 类。\n值得注意的是这个函数返回的是一个匿名函数，为什么呢？原因就是 ClassLoader 中的 prefixLengthsPsr4 、prefixDirsPsr4 等等方法都是 private 的。普通的函数没办法给类的 private 成员变量赋值。利用匿名函数的绑定功能就可以将把匿名函数转为 ClassLoader 类的成员函数。\n关于匿名函数的 绑定功能。\n接下来就是 顶级命名空间 初始化的关键了。\nclassMap public static $classMap = array ( 'App\\\\Api\\\\Middleware\\\\DeviceRecord' =\u003e __DIR__ . '/../..' . '/app/Api/Middleware/DeviceRecord.php', 'App\\\\Api\\\\Middleware\\\\HeaderCheck' =\u003e __DIR__ . '/../..' . '/app/Api/Middleware/HeaderCheck.php', ... ) 直接命名空间全名与目录的映射，没有顶级命名空间。简单粗暴，也导致这个数组相当的大。\nPSR0 顶级命名空间映射 public static $prefixesPsr0 = array ( 'P' =\u003e array ( 'Prophecy\\\\' =\u003e array ( 0 =\u003e __DIR__ . '/..' . '/phpspec/prophecy/src', ), 'Parsedown' =\u003e array ( 0 =\u003e __DIR__ . '/..' . '/erusev/parsedown', ), ), ... ); 为了快速找到顶级命名空间，这里使用命名空间第一个字母作为前缀索引。这个映射的用法比较明显，假如我们有 Parsedown/example 这样的命名空间，首先通过首字母 P，找到：\n'P' =\u003e array (...) 这个数组，然后就会遍历这个数组来和 Parsedown/example 比较，发现第一个 Prophecy 不符合，第二个 Parsedown 符合，然后得到了映射目录（映射目录可能不止一个）：\n0 =\u003e __DIR__ . '/..' . '/erusev/parsedown', 接着遍历这个数组，尝试 __DIR__ . '/..' . '/erusev/parsedown/Parsedown/example.php' 是否存在，如果不存在接着遍历数组（这个例子数组只有一个元素），如果数组遍历完都没有，就会加载失败。\nPSR4 标准顶级命名空间映射 public static $prefixLengthsPsr4 = array ( 'p' =\u003e array ( 'phpDocumentor\\\\Reflection\\\\' =\u003e 25, ), 'Z' =\u003e array ( 'Zend\\\\Diactoros\\\\' =\u003e 15, ), ... ); public static $prefixDirsPsr4 = array ( 'phpDocumentor\\\\Reflection\\\\' =\u003e array ( 0 =\u003e __DIR__ . '/..' . '/phpdocumentor/reflection-common/src', 1 =\u003e __DIR__ . '/..' . '/phpdocumentor/reflection-docblock/src', 2 =\u003e __DIR__ . '/..' . '/phpdocumentor/type-resolver/src', ), 'Zend\\\\Diactoros\\\\' =\u003e array ( 0 =\u003e __DIR__ . '/..' . '/zendframework/zend-diactoros/src', ), ... ); PSR4 标准 顶级命名空间 映射用了两个数组，第一个和 PSR0 一样用命名空间第一个字母作为前缀索引，然后是 顶级命名空间，但是最终并不是文件路径，而是 顶级命名空间 的长度。为什么呢？因为 PSR4 的文件目录更加灵活，更加简洁。\nPSR0 中 顶级命名空间 目录 直接加 到命名空间前面就可以得到路径：\n↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓ Parsedown/example =\u003e __DIR__ . '/..' . '/erusev/parsedown/Parsedown/example.php ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑ 而 PSR4 却是用顶级命名空间目录 替换 顶级命名空间，所以获得顶级命名空间的 长度 很重要：\n↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓ Parsedown/example =\u003e __DIR__ . '/..' . '/erusev/parsedown/example.php ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑ 举例：假如我们找 Symfony\\\\Polyfill\\\\Mbstring\\\\example 这个类，和 PSR0 一样通过前缀索引和字符串匹配我们得到了:\n'Symfony\\\\Polyfill\\\\Mbstring\\\\' =\u003e 26, 这条记录，键是顶级命名空间，值是命名空间的长度。拿到顶级命名空间后去 $prefixDirsPsr4 获取它的映射目录数组（注意映射目录可能不止一条）：\n'Symfony\\\\Polyfill\\\\Mbstring\\\\' =\u003e array ( 0 =\u003e __DIR__ . '/..' . '/symfony/polyfill-mbstring', ), 将 Symfony\\\\Polyfill\\\\Mbstring\\\\example 前 26 个字母替换为 __DIR__ . '/..' . '/symfony/polyfill-mbstring 也就是：\n__DIR__ . '/..' . '/symfony/polyfill-mbstring/example.php 先验证磁盘上这个文件是否存在，如果不存在接着遍历。如果遍历后没有找到，则加载失败。\n自动加载核心类 ClassLoader 的静态初始化完成！\n其实还有 $fallbackDirsPsr4，暂未研究\n调用接口初始化 如果 PHP 版本低于 5.6 或者使用 HHVM 虚拟机环境或者存在 zend_loader_file_encoded，那么就要使用核心类的接口进行初始化。\n/* PSR0 取出命名空间的第一个字母作为索引，一个索引对应多个顶级命名空间，一个顶级命名空间对应多个目录路径，具体形式可以查看上面的 autoload_static 的 $prefixesPsr0。 如果没有顶级命名空间，就只存储一个路径名，以便在后面尝试加载。 */ $map = require __DIR__ . '/autoload_namespaces.php'; foreach ($map as $namespace =\u003e $path) { $loader-\u003eset($namespace, $path); } /* PSR4 如果没有顶级命名空间，就直接保存目录。 如果有命名空间的话，要保证顶级命名空间最后是 \\，然后分别保存 ( 前缀 -\u003e 顶级命名空间，顶级命名空间 -\u003e 顶级命名空间长度 ) ( 顶级命名空间 -\u003e 目录 ) 这两个映射数组。具体形式可以查看上面我们讲的 autoload_static 的 prefixLengthsPsr4、$prefixDirsPsr4 。 */ $map = require __DIR__ . '/autoload_psr4.php'; foreach ($map as $namespace =\u003e $path) { $loader-\u003esetPsr4($namespace, $path); } /* 整个命名空间与目录之间的映射 */ $classMap = require __DIR__ . '/autoload_classmap.php'; if ($classMap) { $loader-\u003eaddClassMap($classMap); } 注册核心类对象 4 Composer 自动加载功能的启动与初始化，经过启动与初始化，自动加载核心类对象已经获得了顶级命名空间与相应目录的映射，换句话说，如果有命名空间 App\\Console\\Kernel，我们已经知道了 App\\ 对应的目录，接下来我们就要解决下面的就是 \\Console\\Kernel 这一段。\n/** * Registers this instance as an autoloader. * * @param bool $prepend Whether to prepend the autoloader or not */ public function register($prepend = false) { spl_autoload_register(array($this, 'loadClass'), true, $prepend); } 一行代码实现自动加载。核心在 ClassLoader 的 loadClass() 函数上，这个函数负责按照 PSR 标准将顶层命名空间以下的内容转为对应的目录，也就是上面所说的将 App\\Console\\Kernel 中 Console\\Kernel 这一段转为目录。\n自动加载全局函数 5 Composer 不止可以自动加载命名空间，还可以加载全局函数。就是把全局函数写到特定的文件里面去，在程序运行前挨个 require 就行了。\nif ($useStaticLoader) { // 静态初始化 $includeFiles = Composer\\Autoload\\ComposerStaticInit76e88f0b305cd64c7c84b90b278c31db::$files; } else { // 普通初始化 $includeFiles = require __DIR__ . '/autoload_files.php'; } foreach ($includeFiles as $fileIdentifier =\u003e $file) { composerRequire76e88f0b305cd64c7c84b90b278c31db($fileIdentifier, $file); } function composerRequire76e88f0b305cd64c7c84b90b278c31db($fileIdentifier, $file) { if (empty($GLOBALS['__composer_autoload_files'][$fileIdentifier])) { require $file; $GLOBALS['__composer_autoload_files'][$fileIdentifier] = true; } } 问题 1 为什么不直接 require $includeFiles 里面的每个文件名，而要用类外面的函数 composerRequire... ？\n避免和用户定义函数冲突 防止有人在全局函数所在的文件写 $this 或者 self 假如 $includeFiles 有个 app/helper.php 文件，这个 helper.php 文件的函数外有一行代码： $this-\u003efoo()，如果引导类在 getLoader() 函数直接 require($file)，那么引导类就会运行这句代码，调用自己的 foo() 函数，这显然是错的。\n事实上 helper.php 就不应该出现 $this 或 self 这样的代码，这样写一般都是用户写错了的，一旦这样的事情发生：\n第一种情况：引导类恰好有 foo() 函数，那么就会莫名其妙执行了引导类的 foo()。 第二种情况：引导类没有 foo() 函数，但是却甩出来引导类没有 foo() 方法这样的错误提示，用户不知道自己哪里错了。把 require 语句放到 引导类的外面，遇到 $this 或者 self ，程序就会告诉用户根本没有类， $this 或 self 无效，错误信息更加明朗。 问题 2 为什么要用 hash 作为 $fileIdentifier？\n这个变量是用来控制全局函数只被 require 一次的，那为什么不用 require_once 呢？事实上 require_once 比 require 效率低很多，使用全局变量 $GLOBALS 这样控制加载会更快。猜测另一个原因应该是 require_once 对相对路径的支持并不理想，所以 composer 尽量少用 require_once。\n运行 ClassLoader 将 loadClass() 函数注册到 PHP SPL 中的 spl_autoload_register() 里面去。这样，每当 PHP 遇到一个不认识的命名空间的时候，PHP 会自动调用注册到 spl_autoload_register() 里面的函数堆栈，运行其中的每个函数，直到找到命名空间对应的文件。\n/** * Loads the given class or interface. * * @param string $class The name of the class * @return bool|null True if loaded, null otherwise */ public function loadClass($class) { if ($file = $this-\u003efindFile($class)) { includeFile($file); // include $file; Prevents access to $this/self from included files. return true; } } /** * Finds the path to the file where the class is defined. * * @param string $class The name of the class * * @return string|false The path if found, false otherwise */ public function findFile($class) { // class map lookup if (isset($this-\u003eclassMap[$class])) { return $this-\u003eclassMap[$class]; } // classMapAuthoritative 关闭搜索未在类映射中注册的类的 prefix and fallback directories。- 不清楚干啥的 暂没研究 if ($this-\u003eclassMapAuthoritative || isset($this-\u003emissingClasses[$class])) { return false; } // 如果启用扩展名，则使用 APCu 前缀来缓存已找到/未找到的类。 - 不清楚干啥的 暂没研究 if (null !== $this-\u003eapcuPrefix) { $file = apcu_fetch($this-\u003eapcuPrefix.$class, $hit); if ($hit) { return $file; } } $file = $this-\u003efindFileWithExtension($class, '.php'); // Search for Hack files if we are running on HHVM if (false === $file \u0026\u0026 defined('HHVM_VERSION')) { $file = $this-\u003efindFileWithExtension($class, '.hh'); } if (null !== $this-\u003eapcuPrefix) { apcu_add($this-\u003eapcuPrefix.$class, $file); } if (false === $file) { // Remember that this class does not exist. $this-\u003emissingClasses[$class] = true; } return $file; } loadClass() 主要调用 findFile() 函数。findFile() 在解析命名空间的时候主要分为两部分：\nclassMap 直接看命名空间是否在映射数组 findFileWithExtension() 包含了 PSR0、PSR4 如果我们在代码中写 'phpDocumentor\\Reflection\\example，PHP 会通过 SPL 调用 loadClass -\u003e findFile -\u003e findFileWithExtension。\n首先默认用 .php 后缀名调用 findFileWithExtension 函数里，利用 PSR4 标准尝试解析目录文件，如果文件不存在则继续用 PSR0 标准解析 如果解析出来的目录文件仍然不存在，但是环境是 HHVM 虚拟机，继续用后缀名 .hh 再次调用 findFileWithExtension 函数，如果不存在，说明此命名空间无法加载，放到 classMap 中设为 false，以便以后更快地加载 PSR4 对于 phpDocumentor\\Reflection\\example，当尝试利用 PSR4 标准映射目录时，步骤如下：\n// $class: phpDocumentor\\Reflection\\example // PSR-4 lookup $logicalPathPsr4 = strtr($class, '\\\\', DIRECTORY_SEPARATOR) . $ext; // $logicalPathPsr4: phpDocumentor/Reflection/example.php(hh)` $first = $class[0]; // $first: p if (isset($this-\u003eprefixLengthsPsr4[$first])) { /* 'p' =\u003e array ( 'phpDocumentor\\\\Reflection\\\\' =\u003e 25, ), */ $subPath = $class; // $subPath: phpDocumentor\\Reflection\\example while (false !== $lastPos = strrpos($subPath, '\\\\')) { // $lastPos 13 $subPath = substr($subPath, 0, $lastPos); $search = $subPath.'\\\\'; if (isset($this-\u003eprefixDirsPsr4[$search])) { // search phpDocumentor\\\\Reflection\\\\ // $lastPos 25 /* 'phpDocumentor\\\\Reflection\\\\' =\u003e array ( 0 =\u003e __DIR__ . '/..' . '/phpdocumentor/reflection-common/src', 1 =\u003e __DIR__ . '/..' . '/phpdocumentor/reflection-docblock/src', 2 =\u003e __DIR__ . '/..' . '/phpdocumentor/type-resolver/src', ), */ $pathEnd = DIRECTORY_SEPARATOR . substr($logicalPathPsr4, $lastPos + 1); // $pathEnd /example.php(hh) foreach ($this-\u003eprefixDirsPsr4[$search] as $dir) { // 遍历 3 个 if (file_exists($file = $dir . $pathEnd)) { // $file __DIR__ . '/..' . /phpdocumentor/type-resolver/src/example.php(hh)` return $file; } } } } } PSR0 如果 PSR4 标准加载失败，则要进行 PSR0 标准加载。对于 phpDocumentor\\Reflection\\example，当尝试利用 PSR0 标准映射目录时，步骤如下：\n// $class: phpDocumentor\\Reflection\\example // PSR-0 lookup if (false !== $pos = strrpos($class, '\\\\')) { // namespaced class name $logicalPathPsr0 = substr($logicalPathPsr4, 0, $pos + 1) . strtr(substr($logicalPathPsr4, $pos + 1), '_', DIRECTORY_SEPARATOR); } else { // PEAR-like class name $logicalPathPsr0 = strtr($class, '_', DIRECTORY_SEPARATOR) . $ext; } // $logicalPathPsr0: phpDocumentor/Reflection/example.php(hh)` if (isset($this-\u003eprefixesPsr0[$first])) { foreach ($this-\u003eprefixesPsr0[$first] as $prefix =\u003e $dirs) { /* 'P' =\u003e array ( 'Prophecy\\\\' =\u003e array ( 0 =\u003e __DIR__ . '/..' . '/phpspec/prophecy/src', ), 'Parsedown' =\u003e array ( 0 =\u003e __DIR__ . '/..' . '/erusev/parsedown', ), ), */ if (0 === strpos($class, $prefix)) { foreach ($dirs as $dir) { if (file_exists($file = $dir . DIRECTORY_SEPARATOR . $logicalPathPsr0)) { // $file __DIR__ . '/..' . '/phpspec/prophecy/src' . phpDocumentor/Reflection/example.php(hh) return $file; } } } } } Q\u0026A 个人一些疑问：\n防止用户自定义与 ClassLoader 命名空间冲突 spl_autoload_register(array('ComposerAutoloaderInit76e88f0b305cd64c7c84b90b278c31db', 'loadClassLoader'), true, true); self::$loader = $loader = new \\Composer\\Autoload\\ClassLoader(); spl_autoload_unregister(array('ComposerAutoloaderInit76e88f0b305cd64c7c84b90b278c31db', 'loadClassLoader')); 为什么这样可以解决：与用户也定义了个 \\Composer\\Autoload\\ClassLoader 命名空间，导致自动加载错误文件。\n与第四个参数 $prepend true 有关吗？\ncomposer StaticLoader 有什么优势 composer 在加载类和加载全局方法时，都有两种方式。\n$useStaticLoader = PHP_VERSION_ID \u003e= 50600 \u0026\u0026 !defined('HHVM_VERSION') \u0026\u0026 (!function_exists('zend_loader_file_encoded') || !zend_loader_file_encoded()); 以 $useStaticLoader 的值进行选择，为什么一定分两种，静态方法是有什么优势吗？\nReferences PHP Composer - 初始化源码分析 – EOF –\n","wordCount":"1435","inLanguage":"en","datePublished":"2019-04-28T19:21:12+08:00","dateModified":"2019-04-28T19:21:12+08:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zyf.im/2019/04/28/composer-autoload-in-laravel/"},"publisher":{"@type":"Organization","name":"ZYF.IM BLOG","logo":{"@type":"ImageObject","url":"https://zyf.im/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://zyf.im/ accesskey=h title="ZYF.IM (Alt + H)"><img src=https://zyf.im/apple-touch-icon.png alt aria-label=logo height=35>ZYF.IM</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://zyf.im/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://zyf.im/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://zyf.im/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://zyf.im/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://zyf.im/>Home</a>&nbsp;»&nbsp;<a href=https://zyf.im/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Laravel 中 composer 加载流程</h1><div class=post-meta><span title='2019-04-28 19:21:12 +0800 CST'>April 28, 2019</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;1435 words&nbsp;·&nbsp;Me</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#启动>启动</a></li><li><a href=#autoload_realphp>autoload_real.php</a></li><li><a href=#单例模式-1>单例模式 1</a></li><li><a href=#构造-classloader-核心类-2>构造 ClassLoader 核心类 2</a></li><li><a href=#初始化核心类对象-3>初始化核心类对象 3</a><ul><li><a href=#autoload_static-静态初始化>autoload_static 静态初始化</a></li><li><a href=#调用接口初始化>调用接口初始化</a></li></ul></li><li><a href=#注册核心类对象-4>注册核心类对象 4</a></li><li><a href=#自动加载全局函数-5>自动加载全局函数 5</a><ul><li><a href=#问题-1>问题 1</a></li><li><a href=#问题-2>问题 2</a></li></ul></li><li><a href=#运行>运行</a><ul><li><a href=#psr4>PSR4</a></li><li><a href=#psr0>PSR0</a></li></ul></li><li><a href=#qa>Q&amp;A</a><ul><li><a href=#防止用户自定义与-classloader-命名空间冲突>防止用户自定义与 ClassLoader 命名空间冲突</a></li><li><a href=#composer-staticloader-有什么优势>composer StaticLoader 有什么优势</a></li></ul></li><li><a href=#references>References</a></li></ul></nav></div></details></div><div class=post-content><h2 id=启动>启动<a hidden class=anchor aria-hidden=true href=#启动>#</a></h2><ul><li>Laravel 5.8</li></ul><p>文章以 Laravel 学习。入口文件 <code>public/index.php</code>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-php data-lang=php><span class=line><span class=cl><span class=c1>// Register The Auto Loader
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>require</span> <span class=no>__DIR__</span><span class=o>.</span><span class=s1>&#39;/../vendor/autoload.php&#39;</span><span class=p>;</span>
</span></span></code></pre></div><p><code>autoload.php</code> 不负责具体功能逻辑，只做了两件事：初始化自动加载类、注册自动加载类。</p><p><code>autoload_real.php</code> 中的类名为 <code>ComposerAutoloaderInit...</code> 这可能是为防止与用户自定义类名跟这个类重复冲突，加上了哈希值。</p><p>其实还有一个做法我们更加熟悉，是定义一个命名空间。这里为什么不定义一个命名空间呢？一种理解：命名空间一般都是为了复用，而这个类只需要运行一次即可，以后也不会用得到，用哈希值更加合适。</p><h2 id=autoload_realphp>autoload_real.php<a hidden class=anchor aria-hidden=true href=#autoload_realphp>#</a></h2><p><code>autoload.php</code> 主要调用了 <code>getLoader()</code>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-php data-lang=php><span class=line><span class=cl><span class=k>public</span> <span class=k>static</span> <span class=k>function</span> <span class=nf>getLoader</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 单例模式，自动加载类只能有一个 1
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=k>null</span> <span class=o>!==</span> <span class=nx>self</span><span class=o>::</span><span class=nv>$loader</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>self</span><span class=o>::</span><span class=nv>$loader</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 获得自动加载核心类对象 2
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>spl_autoload_register</span><span class=p>(</span><span class=k>array</span><span class=p>(</span><span class=s1>&#39;ComposerAutoloaderInit76e88f0b305cd64c7c84b90b278c31db&#39;</span><span class=p>,</span> <span class=s1>&#39;loadClassLoader&#39;</span><span class=p>),</span> <span class=k>true</span><span class=p>,</span> <span class=k>true</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nx>self</span><span class=o>::</span><span class=nv>$loader</span> <span class=o>=</span> <span class=nv>$loader</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>\Composer\Autoload\ClassLoader</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=nx>spl_autoload_unregister</span><span class=p>(</span><span class=k>array</span><span class=p>(</span><span class=s1>&#39;ComposerAutoloaderInit76e88f0b305cd64c7c84b90b278c31db&#39;</span><span class=p>,</span> <span class=s1>&#39;loadClassLoader&#39;</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 初始化自动加载核心类对象 3
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nv>$useStaticLoader</span> <span class=o>=</span> <span class=nx>PHP_VERSION_ID</span> <span class=o>&gt;=</span> <span class=mi>50600</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=nx>defined</span><span class=p>(</span><span class=s1>&#39;HHVM_VERSION&#39;</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=o>!</span><span class=nx>function_exists</span><span class=p>(</span><span class=s1>&#39;zend_loader_file_encoded&#39;</span><span class=p>)</span> <span class=o>||</span> <span class=o>!</span><span class=nx>zend_loader_file_encoded</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nv>$useStaticLoader</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>require_once</span> <span class=no>__DIR__</span> <span class=o>.</span> <span class=s1>&#39;/autoload_static.php&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=nx>call_user_func</span><span class=p>(</span><span class=nx>\Composer\Autoload\ComposerStaticInit76e88f0b305cd64c7c84b90b278c31db</span><span class=o>::</span><span class=na>getInitializer</span><span class=p>(</span><span class=nv>$loader</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nv>$map</span> <span class=o>=</span> <span class=k>require</span> <span class=no>__DIR__</span> <span class=o>.</span> <span class=s1>&#39;/autoload_namespaces.php&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>foreach</span> <span class=p>(</span><span class=nv>$map</span> <span class=k>as</span> <span class=nv>$namespace</span> <span class=o>=&gt;</span> <span class=nv>$path</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nv>$loader</span><span class=o>-&gt;</span><span class=na>set</span><span class=p>(</span><span class=nv>$namespace</span><span class=p>,</span> <span class=nv>$path</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=nv>$map</span> <span class=o>=</span> <span class=k>require</span> <span class=no>__DIR__</span> <span class=o>.</span> <span class=s1>&#39;/autoload_psr4.php&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>foreach</span> <span class=p>(</span><span class=nv>$map</span> <span class=k>as</span> <span class=nv>$namespace</span> <span class=o>=&gt;</span> <span class=nv>$path</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nv>$loader</span><span class=o>-&gt;</span><span class=na>setPsr4</span><span class=p>(</span><span class=nv>$namespace</span><span class=p>,</span> <span class=nv>$path</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=nv>$classMap</span> <span class=o>=</span> <span class=k>require</span> <span class=no>__DIR__</span> <span class=o>.</span> <span class=s1>&#39;/autoload_classmap.php&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=nv>$classMap</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nv>$loader</span><span class=o>-&gt;</span><span class=na>addClassMap</span><span class=p>(</span><span class=nv>$classMap</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 注册自动加载核心类对象 4
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nv>$loader</span><span class=o>-&gt;</span><span class=na>register</span><span class=p>(</span><span class=k>true</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 自动加载全局函数 5
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=nv>$useStaticLoader</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nv>$includeFiles</span> <span class=o>=</span> <span class=nx>Composer\Autoload\ComposerStaticInit76e88f0b305cd64c7c84b90b278c31db</span><span class=o>::</span><span class=nv>$files</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nv>$includeFiles</span> <span class=o>=</span> <span class=k>require</span> <span class=no>__DIR__</span> <span class=o>.</span> <span class=s1>&#39;/autoload_files.php&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>foreach</span> <span class=p>(</span><span class=nv>$includeFiles</span> <span class=k>as</span> <span class=nv>$fileIdentifier</span> <span class=o>=&gt;</span> <span class=nv>$file</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>composerRequire76e88f0b305cd64c7c84b90b278c31db</span><span class=p>(</span><span class=nv>$fileIdentifier</span><span class=p>,</span> <span class=nv>$file</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nv>$loader</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=单例模式-1>单例模式 1<a hidden class=anchor aria-hidden=true href=#单例模式-1>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-php data-lang=php><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=k>null</span> <span class=o>!==</span> <span class=nx>self</span><span class=o>::</span><span class=nv>$loader</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>self</span><span class=o>::</span><span class=nv>$loader</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=构造-classloader-核心类-2>构造 ClassLoader 核心类 2<a hidden class=anchor aria-hidden=true href=#构造-classloader-核心类-2>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-php data-lang=php><span class=line><span class=cl><span class=nx>spl_autoload_register</span><span class=p>(</span><span class=k>array</span><span class=p>(</span><span class=s1>&#39;ComposerAutoloaderInit76e88f0b305cd64c7c84b90b278c31db&#39;</span><span class=p>,</span> <span class=s1>&#39;loadClassLoader&#39;</span><span class=p>),</span> <span class=k>true</span><span class=p>,</span> <span class=k>true</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>self</span><span class=o>::</span><span class=nv>$loader</span> <span class=o>=</span> <span class=nv>$loader</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>\Composer\Autoload\ClassLoader</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=nx>spl_autoload_unregister</span><span class=p>(</span><span class=k>array</span><span class=p>(</span><span class=s1>&#39;ComposerAutoloaderInit76e88f0b305cd64c7c84b90b278c31db&#39;</span><span class=p>,</span> <span class=s1>&#39;loadClassLoader&#39;</span><span class=p>));</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-php data-lang=php><span class=line><span class=cl><span class=k>public</span> <span class=k>static</span> <span class=k>function</span> <span class=nf>loadClassLoader</span><span class=p>(</span><span class=nv>$class</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=s1>&#39;Composer\Autoload\ClassLoader&#39;</span> <span class=o>===</span> <span class=nv>$class</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>require</span> <span class=no>__DIR__</span> <span class=o>.</span> <span class=s1>&#39;/ClassLoader.php&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><code>composer</code> 先向 <code>PHP</code> 自动加载机制注册了一个函数，这个函数 <code>require</code> 了 <code>ClassLoader</code> 文件。成功 <code>new</code> 出该文件中核心类 <code>ClassLoader()</code> 后，又销毁了该函数。</p><p>为什么不直接 <code>require</code>？原因是：怕有的用户也定义了个 <code>\Composer\Autoload\ClassLoader</code> 命名空间，导致自动加载错误文件。</p><p>那为什么不跟引导类一样用个哈希值呢？原因是：这个类是可以复用的，框架允许用户使用这个类。</p><h2 id=初始化核心类对象-3>初始化核心类对象 3<a hidden class=anchor aria-hidden=true href=#初始化核心类对象-3>#</a></h2><p>对自动加载类的初始化，主要是给自动加载核心类初始化顶级命名空间映射。初始化的方法有两种：</p><ol><li>使用 <code>autoload_static</code> 进行静态初始化</li><li>调用核心类接口初始化</li></ol><h3 id=autoload_static-静态初始化>autoload_static 静态初始化<a hidden class=anchor aria-hidden=true href=#autoload_static-静态初始化>#</a></h3><p>静态初始化只支持 <code>PHP 5.6</code> 以上版本、不支持 <code>HHVM</code> 虚拟机、不存在 <code>Zend-encoded file</code>。</p><p><code>autoload_static.php</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-php data-lang=php><span class=line><span class=cl><span class=o>&lt;?</span><span class=nx>php</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// autoload_static.php @generated by Composer
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>namespace</span> <span class=nx>Composer\Autoload</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// hash 防止冲突
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>ComposerStaticInit76e88f0b305cd64c7c84b90b278c31db</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>public</span> <span class=k>static</span> <span class=nv>$files</span> <span class=o>=</span> <span class=k>array</span> <span class=p>(</span><span class=o>...</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>public</span> <span class=k>static</span> <span class=nv>$prefixLengthsPsr4</span> <span class=o>=</span> <span class=k>array</span> <span class=p>(</span><span class=o>...</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>public</span> <span class=k>static</span> <span class=nv>$prefixDirsPsr4</span> <span class=o>=</span> <span class=k>array</span> <span class=p>(</span><span class=o>...</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>public</span> <span class=k>static</span> <span class=nv>$fallbackDirsPsr4</span> <span class=o>=</span> <span class=k>array</span> <span class=p>(</span><span class=o>...</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>public</span> <span class=k>static</span> <span class=nv>$prefixesPsr0</span> <span class=o>=</span> <span class=k>array</span> <span class=p>(</span><span class=o>...</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>public</span> <span class=k>static</span> <span class=nv>$classMap</span> <span class=o>=</span> <span class=k>array</span> <span class=k>array</span> <span class=p>(</span><span class=o>...</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>public</span> <span class=k>static</span> <span class=k>function</span> <span class=nf>getInitializer</span><span class=p>(</span><span class=nx>ClassLoader</span> <span class=nv>$loader</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>\Closure</span><span class=o>::</span><span class=na>bind</span><span class=p>(</span><span class=k>function</span> <span class=p>()</span> <span class=k>use</span> <span class=p>(</span><span class=nv>$loader</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nv>$loader</span><span class=o>-&gt;</span><span class=na>prefixLengthsPsr4</span> <span class=o>=</span> <span class=nx>ComposerStaticInit76e88f0b305cd64c7c84b90b278c31db</span><span class=o>::</span><span class=nv>$prefixLengthsPsr4</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=nv>$loader</span><span class=o>-&gt;</span><span class=na>prefixDirsPsr4</span> <span class=o>=</span> <span class=nx>ComposerStaticInit76e88f0b305cd64c7c84b90b278c31db</span><span class=o>::</span><span class=nv>$prefixDirsPsr4</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=nv>$loader</span><span class=o>-&gt;</span><span class=na>fallbackDirsPsr4</span> <span class=o>=</span> <span class=nx>ComposerStaticInit76e88f0b305cd64c7c84b90b278c31db</span><span class=o>::</span><span class=nv>$fallbackDirsPsr4</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=nv>$loader</span><span class=o>-&gt;</span><span class=na>prefixesPsr0</span> <span class=o>=</span> <span class=nx>ComposerStaticInit76e88f0b305cd64c7c84b90b278c31db</span><span class=o>::</span><span class=nv>$prefixesPsr0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=nv>$loader</span><span class=o>-&gt;</span><span class=na>classMap</span> <span class=o>=</span> <span class=nx>ComposerStaticInit76e88f0b305cd64c7c84b90b278c31db</span><span class=o>::</span><span class=nv>$classMap</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=p>},</span> <span class=k>null</span><span class=p>,</span> <span class=nx>ClassLoader</span><span class=o>::</span><span class=na>class</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>这个静态初始化类的核心就是 <code>getInitializer()</code> 函数，它将自己类中的顶级命名空间映射给了 ClassLoader 类。</p><p>值得注意的是这个函数返回的是一个匿名函数，为什么呢？原因就是 <code>ClassLoader</code> 中的 <code>prefixLengthsPsr4</code> 、<code>prefixDirsPsr4</code> 等等方法都是 <code>private</code> 的。普通的函数没办法给类的 <code>private</code> 成员变量赋值。利用匿名函数的绑定功能就可以将把匿名函数转为 <code>ClassLoader</code> 类的成员函数。</p><p>关于匿名函数的 <a href=http://www.cnblogs.com/yjf512/p/4421289.html>绑定功能</a>。</p><p>接下来就是 顶级命名空间 初始化的关键了。</p><h4 id=classmap>classMap<a hidden class=anchor aria-hidden=true href=#classmap>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-php data-lang=php><span class=line><span class=cl><span class=k>public</span> <span class=k>static</span> <span class=nv>$classMap</span> <span class=o>=</span> <span class=k>array</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=s1>&#39;App\\Api\\Middleware\\DeviceRecord&#39;</span> <span class=o>=&gt;</span> <span class=no>__DIR__</span> <span class=o>.</span> <span class=s1>&#39;/../..&#39;</span> <span class=o>.</span> <span class=s1>&#39;/app/Api/Middleware/DeviceRecord.php&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=s1>&#39;App\\Api\\Middleware\\HeaderCheck&#39;</span> <span class=o>=&gt;</span> <span class=no>__DIR__</span> <span class=o>.</span> <span class=s1>&#39;/../..&#39;</span> <span class=o>.</span> <span class=s1>&#39;/app/Api/Middleware/HeaderCheck.php&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=o>...</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span></code></pre></div><p>直接命名空间全名与目录的映射，没有顶级命名空间。简单粗暴，也导致这个数组相当的大。</p><h4 id=psr0-顶级命名空间映射>PSR0 顶级命名空间映射<a hidden class=anchor aria-hidden=true href=#psr0-顶级命名空间映射>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-php data-lang=php><span class=line><span class=cl><span class=k>public</span> <span class=k>static</span> <span class=nv>$prefixesPsr0</span> <span class=o>=</span> <span class=k>array</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=s1>&#39;P&#39;</span> <span class=o>=&gt;</span>
</span></span><span class=line><span class=cl>    <span class=k>array</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=s1>&#39;Prophecy\\&#39;</span> <span class=o>=&gt;</span>
</span></span><span class=line><span class=cl>        <span class=k>array</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>            <span class=mi>0</span> <span class=o>=&gt;</span> <span class=no>__DIR__</span> <span class=o>.</span> <span class=s1>&#39;/..&#39;</span> <span class=o>.</span> <span class=s1>&#39;/phpspec/prophecy/src&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=p>),</span>
</span></span><span class=line><span class=cl>        <span class=s1>&#39;Parsedown&#39;</span> <span class=o>=&gt;</span>
</span></span><span class=line><span class=cl>        <span class=k>array</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>            <span class=mi>0</span> <span class=o>=&gt;</span> <span class=no>__DIR__</span> <span class=o>.</span> <span class=s1>&#39;/..&#39;</span> <span class=o>.</span> <span class=s1>&#39;/erusev/parsedown&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=p>),</span>
</span></span><span class=line><span class=cl>    <span class=p>),</span>
</span></span><span class=line><span class=cl>    <span class=o>...</span>
</span></span><span class=line><span class=cl><span class=p>);</span>
</span></span></code></pre></div><p>为了快速找到顶级命名空间，这里使用命名空间第一个字母作为前缀索引。这个映射的用法比较明显，假如我们有 <code>Parsedown/example</code> 这样的命名空间，首先通过首字母 <code>P</code>，找到：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-php data-lang=php><span class=line><span class=cl><span class=s1>&#39;P&#39;</span> <span class=o>=&gt;</span> <span class=k>array</span> <span class=p>(</span><span class=o>...</span><span class=p>)</span>
</span></span></code></pre></div><p>这个数组，然后就会遍历这个数组来和 <code>Parsedown/example</code> 比较，发现第一个 <code>Prophecy</code> 不符合，第二个 <code>Parsedown</code> 符合，然后得到了映射目录（映射目录可能不止一个）：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-php data-lang=php><span class=line><span class=cl><span class=mi>0</span> <span class=o>=&gt;</span> <span class=no>__DIR__</span> <span class=o>.</span> <span class=s1>&#39;/..&#39;</span> <span class=o>.</span> <span class=s1>&#39;/erusev/parsedown&#39;</span><span class=p>,</span>
</span></span></code></pre></div><p>接着遍历这个数组，尝试 <code>__DIR__ . '/..' . '/erusev/parsedown/Parsedown/example.php'</code> 是否存在，如果不存在接着遍历数组（这个例子数组只有一个元素），如果数组遍历完都没有，就会加载失败。</p><h4 id=psr4-标准顶级命名空间映射>PSR4 标准顶级命名空间映射<a hidden class=anchor aria-hidden=true href=#psr4-标准顶级命名空间映射>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-php data-lang=php><span class=line><span class=cl><span class=k>public</span> <span class=k>static</span> <span class=nv>$prefixLengthsPsr4</span> <span class=o>=</span> <span class=k>array</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=s1>&#39;p&#39;</span> <span class=o>=&gt;</span>
</span></span><span class=line><span class=cl>    <span class=k>array</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=s1>&#39;phpDocumentor\\Reflection\\&#39;</span> <span class=o>=&gt;</span> <span class=mi>25</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>),</span>
</span></span><span class=line><span class=cl>    <span class=s1>&#39;Z&#39;</span> <span class=o>=&gt;</span>
</span></span><span class=line><span class=cl>    <span class=k>array</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=s1>&#39;Zend\\Diactoros\\&#39;</span> <span class=o>=&gt;</span> <span class=mi>15</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>),</span>
</span></span><span class=line><span class=cl>    <span class=o>...</span>
</span></span><span class=line><span class=cl><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>public</span> <span class=k>static</span> <span class=nv>$prefixDirsPsr4</span> <span class=o>=</span> <span class=k>array</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=s1>&#39;phpDocumentor\\Reflection\\&#39;</span> <span class=o>=&gt;</span>
</span></span><span class=line><span class=cl>    <span class=k>array</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=mi>0</span> <span class=o>=&gt;</span> <span class=no>__DIR__</span> <span class=o>.</span> <span class=s1>&#39;/..&#39;</span> <span class=o>.</span> <span class=s1>&#39;/phpdocumentor/reflection-common/src&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=mi>1</span> <span class=o>=&gt;</span> <span class=no>__DIR__</span> <span class=o>.</span> <span class=s1>&#39;/..&#39;</span> <span class=o>.</span> <span class=s1>&#39;/phpdocumentor/reflection-docblock/src&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=mi>2</span> <span class=o>=&gt;</span> <span class=no>__DIR__</span> <span class=o>.</span> <span class=s1>&#39;/..&#39;</span> <span class=o>.</span> <span class=s1>&#39;/phpdocumentor/type-resolver/src&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>),</span>
</span></span><span class=line><span class=cl>    <span class=s1>&#39;Zend\\Diactoros\\&#39;</span> <span class=o>=&gt;</span>
</span></span><span class=line><span class=cl>    <span class=k>array</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=mi>0</span> <span class=o>=&gt;</span> <span class=no>__DIR__</span> <span class=o>.</span> <span class=s1>&#39;/..&#39;</span> <span class=o>.</span> <span class=s1>&#39;/zendframework/zend-diactoros/src&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>),</span>
</span></span><span class=line><span class=cl>    <span class=o>...</span>
</span></span><span class=line><span class=cl><span class=p>);</span>
</span></span></code></pre></div><p><code>PSR4</code> 标准 <code>顶级命名空间</code> 映射用了两个数组，第一个和 <code>PSR0</code> 一样用命名空间第一个字母作为前缀索引，然后是 <code>顶级命名空间</code>，但是最终并不是文件路径，而是 <code>顶级命名空间</code> 的长度。为什么呢？因为 <code>PSR4</code> 的文件目录更加灵活，更加简洁。</p><p><code>PSR0</code> 中 <code>顶级命名空间</code> 目录 <strong>直接加</strong> 到命名空间前面就可以得到路径：</p><pre tabindex=0><code>                                        ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
Parsedown/example =&gt; __DIR__ . &#39;/..&#39; . &#39;/erusev/parsedown/Parsedown/example.php
                                                         ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑
</code></pre><p>而 <code>PSR4</code> 却是用顶级命名空间目录 <strong>替换</strong> 顶级命名空间，所以获得顶级命名空间的 <strong>长度</strong> 很重要：</p><pre tabindex=0><code>                                        ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
Parsedown/example =&gt; __DIR__ . &#39;/..&#39; . &#39;/erusev/parsedown/example.php
                                                ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑
</code></pre><p>举例：假如我们找 <code>Symfony\\Polyfill\\Mbstring\\example</code> 这个类，和 <code>PSR0</code> 一样通过前缀索引和字符串匹配我们得到了:</p><pre tabindex=0><code>&#39;Symfony\\Polyfill\\Mbstring\\&#39; =&gt; 26,
</code></pre><p>这条记录，键是顶级命名空间，值是命名空间的长度。拿到顶级命名空间后去 <code>$prefixDirsPsr4</code> 获取它的映射目录数组（注意映射目录可能不止一条）：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-php data-lang=php><span class=line><span class=cl><span class=s1>&#39;Symfony\\Polyfill\\Mbstring\\&#39;</span> <span class=o>=&gt;</span>
</span></span><span class=line><span class=cl><span class=k>array</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=mi>0</span> <span class=o>=&gt;</span> <span class=no>__DIR__</span> <span class=o>.</span> <span class=s1>&#39;/..&#39;</span> <span class=o>.</span> <span class=s1>&#39;/symfony/polyfill-mbstring&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>),</span>
</span></span></code></pre></div><p>将 <code>Symfony\\Polyfill\\Mbstring\\example</code> 前 26 个字母替换为 <code>__DIR__ . '/..' . '/symfony/polyfill-mbstring</code> 也就是：</p><pre tabindex=0><code>__DIR__ . &#39;/..&#39; . &#39;/symfony/polyfill-mbstring/example.php
</code></pre><p>先验证磁盘上这个文件是否存在，如果不存在接着遍历。如果遍历后没有找到，则加载失败。</p><p>自动加载核心类 <code>ClassLoader</code> 的静态初始化完成！</p><blockquote><p>其实还有 <code>$fallbackDirsPsr4</code>，暂未研究</p></blockquote><h3 id=调用接口初始化>调用接口初始化<a hidden class=anchor aria-hidden=true href=#调用接口初始化>#</a></h3><p>如果 <code>PHP</code> 版本低于 <code>5.6</code> 或者使用 <code>HHVM</code> 虚拟机环境或者存在 <code>zend_loader_file_encoded</code>，那么就要使用核心类的接口进行初始化。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-php data-lang=php><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>PSR0 取出命名空间的第一个字母作为索引，一个索引对应多个顶级命名空间，一个顶级命名空间对应多个目录路径，具体形式可以查看上面的 autoload_static 的 $prefixesPsr0。
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>如果没有顶级命名空间，就只存储一个路径名，以便在后面尝试加载。
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl><span class=nv>$map</span> <span class=o>=</span> <span class=k>require</span> <span class=no>__DIR__</span> <span class=o>.</span> <span class=s1>&#39;/autoload_namespaces.php&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>foreach</span> <span class=p>(</span><span class=nv>$map</span> <span class=k>as</span> <span class=nv>$namespace</span> <span class=o>=&gt;</span> <span class=nv>$path</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nv>$loader</span><span class=o>-&gt;</span><span class=na>set</span><span class=p>(</span><span class=nv>$namespace</span><span class=p>,</span> <span class=nv>$path</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>PSR4 如果没有顶级命名空间，就直接保存目录。
</span></span></span><span class=line><span class=cl><span class=cm>如果有命名空间的话，要保证顶级命名空间最后是 \，然后分别保存
</span></span></span><span class=line><span class=cl><span class=cm>( 前缀 -&gt; 顶级命名空间，顶级命名空间 -&gt; 顶级命名空间长度 )
</span></span></span><span class=line><span class=cl><span class=cm>( 顶级命名空间 -&gt; 目录 )
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>这两个映射数组。具体形式可以查看上面我们讲的 autoload_static 的 prefixLengthsPsr4、$prefixDirsPsr4 。
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl><span class=nv>$map</span> <span class=o>=</span> <span class=k>require</span> <span class=no>__DIR__</span> <span class=o>.</span> <span class=s1>&#39;/autoload_psr4.php&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>foreach</span> <span class=p>(</span><span class=nv>$map</span> <span class=k>as</span> <span class=nv>$namespace</span> <span class=o>=&gt;</span> <span class=nv>$path</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nv>$loader</span><span class=o>-&gt;</span><span class=na>setPsr4</span><span class=p>(</span><span class=nv>$namespace</span><span class=p>,</span> <span class=nv>$path</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>整个命名空间与目录之间的映射
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl><span class=nv>$classMap</span> <span class=o>=</span> <span class=k>require</span> <span class=no>__DIR__</span> <span class=o>.</span> <span class=s1>&#39;/autoload_classmap.php&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=nv>$classMap</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nv>$loader</span><span class=o>-&gt;</span><span class=na>addClassMap</span><span class=p>(</span><span class=nv>$classMap</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=注册核心类对象-4>注册核心类对象 4<a hidden class=anchor aria-hidden=true href=#注册核心类对象-4>#</a></h2><p>Composer 自动加载功能的启动与初始化，经过启动与初始化，自动加载核心类对象已经获得了顶级命名空间与相应目录的映射，换句话说，如果有命名空间 <code>App\Console\Kernel</code>，我们已经知道了 <code>App\</code> 对应的目录，接下来我们就要解决下面的就是 <code>\Console\Kernel</code> 这一段。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-php data-lang=php><span class=line><span class=cl><span class=sd>/**
</span></span></span><span class=line><span class=cl><span class=sd> * Registers this instance as an autoloader.
</span></span></span><span class=line><span class=cl><span class=sd> *
</span></span></span><span class=line><span class=cl><span class=sd> * @param bool $prepend Whether to prepend the autoloader or not
</span></span></span><span class=line><span class=cl><span class=sd>*/</span>
</span></span><span class=line><span class=cl><span class=k>public</span> <span class=k>function</span> <span class=nf>register</span><span class=p>(</span><span class=nv>$prepend</span> <span class=o>=</span> <span class=k>false</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>spl_autoload_register</span><span class=p>(</span><span class=k>array</span><span class=p>(</span><span class=nv>$this</span><span class=p>,</span> <span class=s1>&#39;loadClass&#39;</span><span class=p>),</span> <span class=k>true</span><span class=p>,</span> <span class=nv>$prepend</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>一行代码实现自动加载。核心在 <code>ClassLoader</code> 的 <code>loadClass()</code> 函数上，这个函数负责按照 <code>PSR</code> 标准将顶层命名空间以下的内容转为对应的目录，也就是上面所说的将 <code>App\Console\Kernel</code> 中 <code>Console\Kernel</code> 这一段转为目录。</p><h2 id=自动加载全局函数-5>自动加载全局函数 5<a hidden class=anchor aria-hidden=true href=#自动加载全局函数-5>#</a></h2><p><code>Composer</code> 不止可以自动加载命名空间，还可以加载全局函数。就是把全局函数写到特定的文件里面去，在程序运行前挨个 <code>require</code> 就行了。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-php data-lang=php><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=nv>$useStaticLoader</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 静态初始化
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nv>$includeFiles</span> <span class=o>=</span> <span class=nx>Composer\Autoload\ComposerStaticInit76e88f0b305cd64c7c84b90b278c31db</span><span class=o>::</span><span class=nv>$files</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 普通初始化
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nv>$includeFiles</span> <span class=o>=</span> <span class=k>require</span> <span class=no>__DIR__</span> <span class=o>.</span> <span class=s1>&#39;/autoload_files.php&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>foreach</span> <span class=p>(</span><span class=nv>$includeFiles</span> <span class=k>as</span> <span class=nv>$fileIdentifier</span> <span class=o>=&gt;</span> <span class=nv>$file</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>composerRequire76e88f0b305cd64c7c84b90b278c31db</span><span class=p>(</span><span class=nv>$fileIdentifier</span><span class=p>,</span> <span class=nv>$file</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-php data-lang=php><span class=line><span class=cl><span class=k>function</span> <span class=nf>composerRequire76e88f0b305cd64c7c84b90b278c31db</span><span class=p>(</span><span class=nv>$fileIdentifier</span><span class=p>,</span> <span class=nv>$file</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=k>empty</span><span class=p>(</span><span class=nv>$GLOBALS</span><span class=p>[</span><span class=s1>&#39;__composer_autoload_files&#39;</span><span class=p>][</span><span class=nv>$fileIdentifier</span><span class=p>]))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>require</span> <span class=nv>$file</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=nv>$GLOBALS</span><span class=p>[</span><span class=s1>&#39;__composer_autoload_files&#39;</span><span class=p>][</span><span class=nv>$fileIdentifier</span><span class=p>]</span> <span class=o>=</span> <span class=k>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=问题-1>问题 1<a hidden class=anchor aria-hidden=true href=#问题-1>#</a></h3><p>为什么不直接 <code>require</code> <code>$includeFiles</code> 里面的每个文件名，而要用类外面的函数 <code>composerRequire...</code> ？</p><ul><li>避免和用户定义函数冲突</li><li>防止有人在全局函数所在的文件写 <code>$this</code> 或者 <code>self</code></li></ul><p>假如 <code>$includeFiles</code> 有个 <code>app/helper.php</code> 文件，这个 <code>helper.php</code> 文件的函数外有一行代码： <code>$this->foo()</code>，如果引导类在 <code>getLoader()</code> 函数直接 <code>require($file)</code>，那么引导类就会运行这句代码，调用自己的 <code>foo()</code> 函数，这显然是错的。</p><p>事实上 <code>helper.php</code> 就不应该出现 <code>$this</code> 或 <code>self</code> 这样的代码，这样写一般都是用户写错了的，一旦这样的事情发生：</p><ul><li>第一种情况：引导类恰好有 <code>foo()</code> 函数，那么就会莫名其妙执行了引导类的 <code>foo()</code>。</li><li>第二种情况：引导类没有 <code>foo()</code> 函数，但是却甩出来引导类没有 <code>foo()</code> 方法这样的错误提示，用户不知道自己哪里错了。把 <code>require</code> 语句放到 <strong>引导类的外面</strong>，遇到 <code>$this</code> 或者 <code>self</code> ，程序就会告诉用户根本没有类， <code>$this</code> 或 <code>self</code> 无效，错误信息更加明朗。</li></ul><h3 id=问题-2>问题 2<a hidden class=anchor aria-hidden=true href=#问题-2>#</a></h3><p>为什么要用 <code>hash</code> 作为 <code>$fileIdentifier</code>？</p><p>这个变量是用来控制全局函数只被 <code>require</code> 一次的，那为什么不用 <code>require_once</code> 呢？事实上 <code>require_once</code> 比 <code>require</code> 效率低很多，使用全局变量 <code>$GLOBALS</code> 这样控制加载会更快。猜测另一个原因应该是 <code>require_once</code> 对相对路径的支持并不理想，所以 <code>composer</code> 尽量少用 <code>require_once</code>。</p><h2 id=运行>运行<a hidden class=anchor aria-hidden=true href=#运行>#</a></h2><p><code>ClassLoader</code> 将 <code>loadClass()</code> 函数注册到 <code>PHP SPL</code> 中的 <code>spl_autoload_register()</code> 里面去。这样，每当 PHP 遇到一个不认识的命名空间的时候，PHP 会自动调用注册到 <code>spl_autoload_register()</code> 里面的函数堆栈，运行其中的每个函数，直到找到命名空间对应的文件。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-php data-lang=php><span class=line><span class=cl><span class=sd>/**
</span></span></span><span class=line><span class=cl><span class=sd> * Loads the given class or interface.
</span></span></span><span class=line><span class=cl><span class=sd> *
</span></span></span><span class=line><span class=cl><span class=sd> * @param  string    $class The name of the class
</span></span></span><span class=line><span class=cl><span class=sd>    * @return bool|null True if loaded, null otherwise
</span></span></span><span class=line><span class=cl><span class=sd>    */</span>
</span></span><span class=line><span class=cl><span class=k>public</span> <span class=k>function</span> <span class=nf>loadClass</span><span class=p>(</span><span class=nv>$class</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nv>$file</span> <span class=o>=</span> <span class=nv>$this</span><span class=o>-&gt;</span><span class=na>findFile</span><span class=p>(</span><span class=nv>$class</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>includeFile</span><span class=p>(</span><span class=nv>$file</span><span class=p>);</span> <span class=c1>// include $file; Prevents access to $this/self from included files.
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=k>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=sd>/**
</span></span></span><span class=line><span class=cl><span class=sd> * Finds the path to the file where the class is defined.
</span></span></span><span class=line><span class=cl><span class=sd> *
</span></span></span><span class=line><span class=cl><span class=sd> * @param string $class The name of the class
</span></span></span><span class=line><span class=cl><span class=sd>    *
</span></span></span><span class=line><span class=cl><span class=sd>    * @return string|false The path if found, false otherwise
</span></span></span><span class=line><span class=cl><span class=sd>    */</span>
</span></span><span class=line><span class=cl><span class=k>public</span> <span class=k>function</span> <span class=nf>findFile</span><span class=p>(</span><span class=nv>$class</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// class map lookup
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=nx>isset</span><span class=p>(</span><span class=nv>$this</span><span class=o>-&gt;</span><span class=na>classMap</span><span class=p>[</span><span class=nv>$class</span><span class=p>]))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nv>$this</span><span class=o>-&gt;</span><span class=na>classMap</span><span class=p>[</span><span class=nv>$class</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// classMapAuthoritative 关闭搜索未在类映射中注册的类的 prefix and fallback directories。- 不清楚干啥的 暂没研究
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=nv>$this</span><span class=o>-&gt;</span><span class=na>classMapAuthoritative</span> <span class=o>||</span> <span class=nx>isset</span><span class=p>(</span><span class=nv>$this</span><span class=o>-&gt;</span><span class=na>missingClasses</span><span class=p>[</span><span class=nv>$class</span><span class=p>]))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=k>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 如果启用扩展名，则使用 APCu 前缀来缓存已找到/未找到的类。 - 不清楚干啥的 暂没研究
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=k>null</span> <span class=o>!==</span> <span class=nv>$this</span><span class=o>-&gt;</span><span class=na>apcuPrefix</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nv>$file</span> <span class=o>=</span> <span class=nx>apcu_fetch</span><span class=p>(</span><span class=nv>$this</span><span class=o>-&gt;</span><span class=na>apcuPrefix</span><span class=o>.</span><span class=nv>$class</span><span class=p>,</span> <span class=nv>$hit</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=nv>$hit</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=nv>$file</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nv>$file</span> <span class=o>=</span> <span class=nv>$this</span><span class=o>-&gt;</span><span class=na>findFileWithExtension</span><span class=p>(</span><span class=nv>$class</span><span class=p>,</span> <span class=s1>&#39;.php&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Search for Hack files if we are running on HHVM
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=k>false</span> <span class=o>===</span> <span class=nv>$file</span> <span class=o>&amp;&amp;</span> <span class=nx>defined</span><span class=p>(</span><span class=s1>&#39;HHVM_VERSION&#39;</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nv>$file</span> <span class=o>=</span> <span class=nv>$this</span><span class=o>-&gt;</span><span class=na>findFileWithExtension</span><span class=p>(</span><span class=nv>$class</span><span class=p>,</span> <span class=s1>&#39;.hh&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=k>null</span> <span class=o>!==</span> <span class=nv>$this</span><span class=o>-&gt;</span><span class=na>apcuPrefix</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>apcu_add</span><span class=p>(</span><span class=nv>$this</span><span class=o>-&gt;</span><span class=na>apcuPrefix</span><span class=o>.</span><span class=nv>$class</span><span class=p>,</span> <span class=nv>$file</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=k>false</span> <span class=o>===</span> <span class=nv>$file</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Remember that this class does not exist.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nv>$this</span><span class=o>-&gt;</span><span class=na>missingClasses</span><span class=p>[</span><span class=nv>$class</span><span class=p>]</span> <span class=o>=</span> <span class=k>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nv>$file</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><code>loadClass()</code> 主要调用 <code>findFile()</code> 函数。<code>findFile()</code> 在解析命名空间的时候主要分为两部分：</p><ul><li><code>classMap</code> 直接看命名空间是否在映射数组</li><li><code>findFileWithExtension()</code> 包含了 <code>PSR0</code>、<code>PSR4</code></li></ul><p>如果我们在代码中写 <code>'phpDocumentor\Reflection\example</code>，PHP 会通过 SPL 调用 <code>loadClass</code> -> <code>findFile</code> -> <code>findFileWithExtension</code>。</p><ul><li>首先默认用 <code>.php</code> 后缀名调用 <code>findFileWithExtension</code> 函数里，利用 <code>PSR4</code> 标准尝试解析目录文件，如果文件不存在则继续用 <code>PSR0</code> 标准解析</li><li>如果解析出来的目录文件仍然不存在，但是环境是 <code>HHVM</code> 虚拟机，继续用后缀名 <code>.hh</code> 再次调用 <code>findFileWithExtension</code> 函数，如果不存在，说明此命名空间无法加载，放到 <code>classMap</code> 中设为 <code>false</code>，以便以后更快地加载</li></ul><h3 id=psr4>PSR4<a hidden class=anchor aria-hidden=true href=#psr4>#</a></h3><p>对于 <code>phpDocumentor\Reflection\example</code>，当尝试利用 <code>PSR4</code> 标准映射目录时，步骤如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-php data-lang=php><span class=line><span class=cl><span class=c1>// $class: phpDocumentor\Reflection\example
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// PSR-4 lookup
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nv>$logicalPathPsr4</span> <span class=o>=</span> <span class=nx>strtr</span><span class=p>(</span><span class=nv>$class</span><span class=p>,</span> <span class=s1>&#39;\\&#39;</span><span class=p>,</span> <span class=nx>DIRECTORY_SEPARATOR</span><span class=p>)</span> <span class=o>.</span> <span class=nv>$ext</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>// $logicalPathPsr4: phpDocumentor/Reflection/example.php(hh)`
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=nv>$first</span> <span class=o>=</span> <span class=nv>$class</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=c1>// $first: p
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=nx>isset</span><span class=p>(</span><span class=nv>$this</span><span class=o>-&gt;</span><span class=na>prefixLengthsPsr4</span><span class=p>[</span><span class=nv>$first</span><span class=p>]))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* &#39;p&#39; =&gt;
</span></span></span><span class=line><span class=cl><span class=cm>    array (
</span></span></span><span class=line><span class=cl><span class=cm>        &#39;phpDocumentor\\Reflection\\&#39; =&gt; 25,
</span></span></span><span class=line><span class=cl><span class=cm>    ),
</span></span></span><span class=line><span class=cl><span class=cm>    */</span>
</span></span><span class=line><span class=cl>    <span class=nv>$subPath</span> <span class=o>=</span> <span class=nv>$class</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// $subPath: phpDocumentor\Reflection\example
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>while</span> <span class=p>(</span><span class=k>false</span> <span class=o>!==</span> <span class=nv>$lastPos</span> <span class=o>=</span> <span class=nx>strrpos</span><span class=p>(</span><span class=nv>$subPath</span><span class=p>,</span> <span class=s1>&#39;\\&#39;</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// $lastPos 13
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nv>$subPath</span> <span class=o>=</span> <span class=nx>substr</span><span class=p>(</span><span class=nv>$subPath</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=nv>$lastPos</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nv>$search</span> <span class=o>=</span> <span class=nv>$subPath</span><span class=o>.</span><span class=s1>&#39;\\&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=nx>isset</span><span class=p>(</span><span class=nv>$this</span><span class=o>-&gt;</span><span class=na>prefixDirsPsr4</span><span class=p>[</span><span class=nv>$search</span><span class=p>]))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// search phpDocumentor\\Reflection\\
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=c1>// $lastPos 25
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>            <span class=cm>/* &#39;phpDocumentor\\Reflection\\&#39; =&gt;
</span></span></span><span class=line><span class=cl><span class=cm>                array (
</span></span></span><span class=line><span class=cl><span class=cm>                    0 =&gt; __DIR__ . &#39;/..&#39; . &#39;/phpdocumentor/reflection-common/src&#39;,
</span></span></span><span class=line><span class=cl><span class=cm>                    1 =&gt; __DIR__ . &#39;/..&#39; . &#39;/phpdocumentor/reflection-docblock/src&#39;,
</span></span></span><span class=line><span class=cl><span class=cm>                    2 =&gt; __DIR__ . &#39;/..&#39; . &#39;/phpdocumentor/type-resolver/src&#39;,
</span></span></span><span class=line><span class=cl><span class=cm>                ),
</span></span></span><span class=line><span class=cl><span class=cm>            */</span>
</span></span><span class=line><span class=cl>            <span class=nv>$pathEnd</span> <span class=o>=</span> <span class=nx>DIRECTORY_SEPARATOR</span> <span class=o>.</span> <span class=nx>substr</span><span class=p>(</span><span class=nv>$logicalPathPsr4</span><span class=p>,</span> <span class=nv>$lastPos</span> <span class=o>+</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=c1>// $pathEnd /example.php(hh)
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>            <span class=k>foreach</span> <span class=p>(</span><span class=nv>$this</span><span class=o>-&gt;</span><span class=na>prefixDirsPsr4</span><span class=p>[</span><span class=nv>$search</span><span class=p>]</span> <span class=k>as</span> <span class=nv>$dir</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=c1>// 遍历 3 个
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=k>if</span> <span class=p>(</span><span class=nx>file_exists</span><span class=p>(</span><span class=nv>$file</span> <span class=o>=</span> <span class=nv>$dir</span> <span class=o>.</span> <span class=nv>$pathEnd</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=c1>// $file __DIR__ . &#39;/..&#39; . /phpdocumentor/type-resolver/src/example.php(hh)`
</span></span></span><span class=line><span class=cl><span class=c1></span>                    <span class=k>return</span> <span class=nv>$file</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=psr0>PSR0<a hidden class=anchor aria-hidden=true href=#psr0>#</a></h3><p>如果 <code>PSR4</code> 标准加载失败，则要进行 <code>PSR0</code> 标准加载。对于 <code>phpDocumentor\Reflection\example</code>，当尝试利用 <code>PSR0</code> 标准映射目录时，步骤如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-php data-lang=php><span class=line><span class=cl><span class=c1>// $class: phpDocumentor\Reflection\example
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// PSR-0 lookup
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=k>false</span> <span class=o>!==</span> <span class=nv>$pos</span> <span class=o>=</span> <span class=nx>strrpos</span><span class=p>(</span><span class=nv>$class</span><span class=p>,</span> <span class=s1>&#39;\\&#39;</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// namespaced class name
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nv>$logicalPathPsr0</span> <span class=o>=</span> <span class=nx>substr</span><span class=p>(</span><span class=nv>$logicalPathPsr4</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=nv>$pos</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=o>.</span> <span class=nx>strtr</span><span class=p>(</span><span class=nx>substr</span><span class=p>(</span><span class=nv>$logicalPathPsr4</span><span class=p>,</span> <span class=nv>$pos</span> <span class=o>+</span> <span class=mi>1</span><span class=p>),</span> <span class=s1>&#39;_&#39;</span><span class=p>,</span> <span class=nx>DIRECTORY_SEPARATOR</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// PEAR-like class name
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nv>$logicalPathPsr0</span> <span class=o>=</span> <span class=nx>strtr</span><span class=p>(</span><span class=nv>$class</span><span class=p>,</span> <span class=s1>&#39;_&#39;</span><span class=p>,</span> <span class=nx>DIRECTORY_SEPARATOR</span><span class=p>)</span> <span class=o>.</span> <span class=nv>$ext</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// $logicalPathPsr0: phpDocumentor/Reflection/example.php(hh)`
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=nx>isset</span><span class=p>(</span><span class=nv>$this</span><span class=o>-&gt;</span><span class=na>prefixesPsr0</span><span class=p>[</span><span class=nv>$first</span><span class=p>]))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>foreach</span> <span class=p>(</span><span class=nv>$this</span><span class=o>-&gt;</span><span class=na>prefixesPsr0</span><span class=p>[</span><span class=nv>$first</span><span class=p>]</span> <span class=k>as</span> <span class=nv>$prefix</span> <span class=o>=&gt;</span> <span class=nv>$dirs</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* &#39;P&#39; =&gt;
</span></span></span><span class=line><span class=cl><span class=cm>        array (
</span></span></span><span class=line><span class=cl><span class=cm>            &#39;Prophecy\\&#39; =&gt;
</span></span></span><span class=line><span class=cl><span class=cm>            array (
</span></span></span><span class=line><span class=cl><span class=cm>                0 =&gt; __DIR__ . &#39;/..&#39; . &#39;/phpspec/prophecy/src&#39;,
</span></span></span><span class=line><span class=cl><span class=cm>            ),
</span></span></span><span class=line><span class=cl><span class=cm>            &#39;Parsedown&#39; =&gt;
</span></span></span><span class=line><span class=cl><span class=cm>            array (
</span></span></span><span class=line><span class=cl><span class=cm>                0 =&gt; __DIR__ . &#39;/..&#39; . &#39;/erusev/parsedown&#39;,
</span></span></span><span class=line><span class=cl><span class=cm>            ),
</span></span></span><span class=line><span class=cl><span class=cm>        ), */</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=mi>0</span> <span class=o>===</span> <span class=nx>strpos</span><span class=p>(</span><span class=nv>$class</span><span class=p>,</span> <span class=nv>$prefix</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>foreach</span> <span class=p>(</span><span class=nv>$dirs</span> <span class=k>as</span> <span class=nv>$dir</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=p>(</span><span class=nx>file_exists</span><span class=p>(</span><span class=nv>$file</span> <span class=o>=</span> <span class=nv>$dir</span> <span class=o>.</span> <span class=nx>DIRECTORY_SEPARATOR</span> <span class=o>.</span> <span class=nv>$logicalPathPsr0</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=c1>// $file __DIR__ . &#39;/..&#39; . &#39;/phpspec/prophecy/src&#39; . phpDocumentor/Reflection/example.php(hh)
</span></span></span><span class=line><span class=cl><span class=c1></span>                    <span class=k>return</span> <span class=nv>$file</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=qa>Q&amp;A<a hidden class=anchor aria-hidden=true href=#qa>#</a></h2><p>个人一些疑问：</p><h3 id=防止用户自定义与-classloader-命名空间冲突>防止用户自定义与 ClassLoader 命名空间冲突<a hidden class=anchor aria-hidden=true href=#防止用户自定义与-classloader-命名空间冲突>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-php data-lang=php><span class=line><span class=cl><span class=nx>spl_autoload_register</span><span class=p>(</span><span class=k>array</span><span class=p>(</span><span class=s1>&#39;ComposerAutoloaderInit76e88f0b305cd64c7c84b90b278c31db&#39;</span><span class=p>,</span> <span class=s1>&#39;loadClassLoader&#39;</span><span class=p>),</span> <span class=k>true</span><span class=p>,</span> <span class=k>true</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>self</span><span class=o>::</span><span class=nv>$loader</span> <span class=o>=</span> <span class=nv>$loader</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>\Composer\Autoload\ClassLoader</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=nx>spl_autoload_unregister</span><span class=p>(</span><span class=k>array</span><span class=p>(</span><span class=s1>&#39;ComposerAutoloaderInit76e88f0b305cd64c7c84b90b278c31db&#39;</span><span class=p>,</span> <span class=s1>&#39;loadClassLoader&#39;</span><span class=p>));</span>
</span></span></code></pre></div><p>为什么这样可以解决：与用户也定义了个 <code>\Composer\Autoload\ClassLoader</code> 命名空间，导致自动加载错误文件。</p><p>与第四个参数 <code>$prepend</code> <code>true</code> 有关吗？</p><h3 id=composer-staticloader-有什么优势>composer StaticLoader 有什么优势<a hidden class=anchor aria-hidden=true href=#composer-staticloader-有什么优势>#</a></h3><p><code>composer</code> 在加载类和加载全局方法时，都有两种方式。</p><pre tabindex=0><code>$useStaticLoader = PHP_VERSION_ID &gt;= 50600 &amp;&amp; !defined(&#39;HHVM_VERSION&#39;) &amp;&amp; (!function_exists(&#39;zend_loader_file_encoded&#39;) || !zend_loader_file_encoded());
</code></pre><p>以 <code>$useStaticLoader</code> 的值进行选择，为什么一定分两种，静态方法是有什么优势吗？</p><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><ul><li><a href=https://github.com/LeoYang90/laravel-source-analysis/blob/master/PHP%20Composer%E2%80%94%E2%80%94%20%E5%88%9D%E5%A7%8B%E5%8C%96%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.md>PHP Composer - 初始化源码分析</a></li></ul><p>&ndash; EOF &ndash;</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://zyf.im/tags/php/>Php</a></li><li><a href=https://zyf.im/tags/composer/>Composer</a></li></ul><nav class=paginav><a class=prev href=https://zyf.im/2019/05/20/my-macbook/><span class=title>« Prev</span><br><span>My MacBook</span>
</a><a class=next href=https://zyf.im/2019/04/10/php-strpos-warning/><span class=title>Next »</span><br><span>PHP 请小心判断 strpos</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://zyf.im/>ZYF.IM BLOG</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>