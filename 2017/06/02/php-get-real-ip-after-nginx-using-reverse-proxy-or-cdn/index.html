<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>PHP 中获取 Nginx 使用反向代理或 CDN 后的客户端真实 IP | ZYF.IM BLOG</title>
<meta name=keywords content="nginx,php"><meta name=description content="获取 Nginx 反向代理后的客户端 IP，基本是按一定顺序检测以下参数中的信息：

HTTP_CLIENT_IP
HTTP_X_REAL_FORWARDED_FOR
HTTP_X_FORWARDED_FOR
REMOTE_ADDR

在未使用 CDN 和反向代理情况下
当业务服务器直接暴露在公网上，并且未使用 CDN 和反向代理服务器时，可以直接使用 remote_addr：
$_SERVER['REMOTE_ADDR']
这时候 HTTP_X_FORWARDED_FOR 和 HTTP_X_REAL_IP 都是可以被伪造的，但 REMOTE_ADDR 是客户端和服务器的握手 IP，即 client 的出口 IP，伪造不了。

在使用 CDN 和反向代理情况下
铁律
当多层代理或使用 CDN 时，如果代理服务器不把用户的真实 IP 传递下去，那么业务服务器将永远不可能获取到用户的真实 IP。
如果 WEB 服务器上层也是使用 Nginx 做代理或负载均衡，则需要在代理层的 Nginx 配置中明确 XFF 参数，累加传递上一个请求方的 IP 到 header 请求中。以下是代理层的 Nginx 配置参数。
proxy_set_header X-Real-IP $remote_addr;
proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
proxy_set_header Host $http_host;
proxy_set_header X-NginX-Proxy true;
只有一层代理的情况
我们按上面的配置发起一个伪造请求，10.100.11.25 是我电脑的 IP，链路为："><meta name=author content="Me"><link rel=canonical href=https://zyf.im/2017/06/02/php-get-real-ip-after-nginx-using-reverse-proxy-or-cdn/><link crossorigin=anonymous href=/assets/css/stylesheet.4997c86cdc3165a43745858554a5b14aaf4d3769db9f06a36b0c69ef98eb2927.css integrity="sha256-SZfIbNwxZaQ3RYWFVKWxSq9NN2nbnwajawxp75jrKSc=" rel="preload stylesheet" as=style><link rel=icon href=https://zyf.im/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zyf.im/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://zyf.im/favicon-32x32.png><link rel=apple-touch-icon href=https://zyf.im/apple-touch-icon.png><link rel=mask-icon href=https://zyf.im/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://zyf.im/2017/06/02/php-get-real-ip-after-nginx-using-reverse-proxy-or-cdn/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-6DVZ6E58DG"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-6DVZ6E58DG")}</script><meta property="og:url" content="https://zyf.im/2017/06/02/php-get-real-ip-after-nginx-using-reverse-proxy-or-cdn/"><meta property="og:site_name" content="ZYF.IM BLOG"><meta property="og:title" content="PHP 中获取 Nginx 使用反向代理或 CDN 后的客户端真实 IP"><meta property="og:description" content="获取 Nginx 反向代理后的客户端 IP，基本是按一定顺序检测以下参数中的信息：
HTTP_CLIENT_IP HTTP_X_REAL_FORWARDED_FOR HTTP_X_FORWARDED_FOR REMOTE_ADDR 在未使用 CDN 和反向代理情况下 当业务服务器直接暴露在公网上，并且未使用 CDN 和反向代理服务器时，可以直接使用 remote_addr：
$_SERVER['REMOTE_ADDR'] 这时候 HTTP_X_FORWARDED_FOR 和 HTTP_X_REAL_IP 都是可以被伪造的，但 REMOTE_ADDR 是客户端和服务器的握手 IP，即 client 的出口 IP，伪造不了。
在使用 CDN 和反向代理情况下 铁律 当多层代理或使用 CDN 时，如果代理服务器不把用户的真实 IP 传递下去，那么业务服务器将永远不可能获取到用户的真实 IP。
如果 WEB 服务器上层也是使用 Nginx 做代理或负载均衡，则需要在代理层的 Nginx 配置中明确 XFF 参数，累加传递上一个请求方的 IP 到 header 请求中。以下是代理层的 Nginx 配置参数。
proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_set_header X-NginX-Proxy true; 只有一层代理的情况 我们按上面的配置发起一个伪造请求，10.100.11.25 是我电脑的 IP，链路为："><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2017-06-02T16:00:00+00:00"><meta property="article:modified_time" content="2017-06-02T16:00:00+00:00"><meta property="article:tag" content="Nginx"><meta property="article:tag" content="Php"><meta name=twitter:card content="summary"><meta name=twitter:title content="PHP 中获取 Nginx 使用反向代理或 CDN 后的客户端真实 IP"><meta name=twitter:description content="获取 Nginx 反向代理后的客户端 IP，基本是按一定顺序检测以下参数中的信息：

HTTP_CLIENT_IP
HTTP_X_REAL_FORWARDED_FOR
HTTP_X_FORWARDED_FOR
REMOTE_ADDR

在未使用 CDN 和反向代理情况下
当业务服务器直接暴露在公网上，并且未使用 CDN 和反向代理服务器时，可以直接使用 remote_addr：
$_SERVER['REMOTE_ADDR']
这时候 HTTP_X_FORWARDED_FOR 和 HTTP_X_REAL_IP 都是可以被伪造的，但 REMOTE_ADDR 是客户端和服务器的握手 IP，即 client 的出口 IP，伪造不了。

在使用 CDN 和反向代理情况下
铁律
当多层代理或使用 CDN 时，如果代理服务器不把用户的真实 IP 传递下去，那么业务服务器将永远不可能获取到用户的真实 IP。
如果 WEB 服务器上层也是使用 Nginx 做代理或负载均衡，则需要在代理层的 Nginx 配置中明确 XFF 参数，累加传递上一个请求方的 IP 到 header 请求中。以下是代理层的 Nginx 配置参数。
proxy_set_header X-Real-IP $remote_addr;
proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
proxy_set_header Host $http_host;
proxy_set_header X-NginX-Proxy true;
只有一层代理的情况
我们按上面的配置发起一个伪造请求，10.100.11.25 是我电脑的 IP，链路为："><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zyf.im/posts/"},{"@type":"ListItem","position":2,"name":"PHP 中获取 Nginx 使用反向代理或 CDN 后的客户端真实 IP","item":"https://zyf.im/2017/06/02/php-get-real-ip-after-nginx-using-reverse-proxy-or-cdn/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"PHP 中获取 Nginx 使用反向代理或 CDN 后的客户端真实 IP","name":"PHP 中获取 Nginx 使用反向代理或 CDN 后的客户端真实 IP","description":"获取 Nginx 反向代理后的客户端 IP，基本是按一定顺序检测以下参数中的信息：\nHTTP_CLIENT_IP HTTP_X_REAL_FORWARDED_FOR HTTP_X_FORWARDED_FOR REMOTE_ADDR 在未使用 CDN 和反向代理情况下 当业务服务器直接暴露在公网上，并且未使用 CDN 和反向代理服务器时，可以直接使用 remote_addr：\n$_SERVER[\u0026#39;REMOTE_ADDR\u0026#39;] 这时候 HTTP_X_FORWARDED_FOR 和 HTTP_X_REAL_IP 都是可以被伪造的，但 REMOTE_ADDR 是客户端和服务器的握手 IP，即 client 的出口 IP，伪造不了。\n在使用 CDN 和反向代理情况下 铁律 当多层代理或使用 CDN 时，如果代理服务器不把用户的真实 IP 传递下去，那么业务服务器将永远不可能获取到用户的真实 IP。\n如果 WEB 服务器上层也是使用 Nginx 做代理或负载均衡，则需要在代理层的 Nginx 配置中明确 XFF 参数，累加传递上一个请求方的 IP 到 header 请求中。以下是代理层的 Nginx 配置参数。\nproxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_set_header X-NginX-Proxy true; 只有一层代理的情况 我们按上面的配置发起一个伪造请求，10.100.11.25 是我电脑的 IP，链路为：\n","keywords":["nginx","php"],"articleBody":"获取 Nginx 反向代理后的客户端 IP，基本是按一定顺序检测以下参数中的信息：\nHTTP_CLIENT_IP HTTP_X_REAL_FORWARDED_FOR HTTP_X_FORWARDED_FOR REMOTE_ADDR 在未使用 CDN 和反向代理情况下 当业务服务器直接暴露在公网上，并且未使用 CDN 和反向代理服务器时，可以直接使用 remote_addr：\n$_SERVER['REMOTE_ADDR'] 这时候 HTTP_X_FORWARDED_FOR 和 HTTP_X_REAL_IP 都是可以被伪造的，但 REMOTE_ADDR 是客户端和服务器的握手 IP，即 client 的出口 IP，伪造不了。\n在使用 CDN 和反向代理情况下 铁律 当多层代理或使用 CDN 时，如果代理服务器不把用户的真实 IP 传递下去，那么业务服务器将永远不可能获取到用户的真实 IP。\n如果 WEB 服务器上层也是使用 Nginx 做代理或负载均衡，则需要在代理层的 Nginx 配置中明确 XFF 参数，累加传递上一个请求方的 IP 到 header 请求中。以下是代理层的 Nginx 配置参数。\nproxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_set_header X-NginX-Proxy true; 只有一层代理的情况 我们按上面的配置发起一个伪造请求，10.100.11.25 是我电脑的 IP，链路为：\n10.100.11.25(client)-\u003e10.200.21.33(Proxy)-\u003e10.200.21.32(Web Server) curl 请求：\ncurl http://10.200.21.33:88/test.php -H 'X-Forwarded-For: unkonw, \u003c8.8.8.8\u003e 1.1.1.1' -H 'X-Real-IP: 2.2.2.2' 结果为：\n[HTTP_X_FORWARDED_FOR] =\u003e unkonw, \u003c8.8.8.8\u003e 1.1.1.1, 10.100.11.25 [REMOTE_ADDR] =\u003e 10.200.21.33 [HTTP_X_REAL_IP] =\u003e 10.100.11.25 我们可以看到，XFF 被附加上了我的 IP，但前面的一系列伪造内容，可以轻易骗过很多规则，而 HTTP_X_REAL_IP 则传递了我电脑的 IP。因为在上面的配置中，X-Real-IP 已经被设置为握手 IP。\n但多层代理之后，以上面的规则，显然 HTTP_X_REAL_IP 也不会是真实的用户 IP 了。而 HTTP_X_FORWARDED_FOR 则在原有信息（我们伪造的信息）之后附上了握手 IP 一起传递过来了。\n两层或更多代理的情况 我们这里只测试两层，实际链路为：\n10.100.11.25(client)-\u003e10.200.21.34(Proxy)-\u003e10.200.21.33(Proxy)-\u003e10.200.21.32(Web Server) curl 请求：\ncurl http://10.200.21.34:88/test.php -H 'X-Forwarded-For: unkonw, \u003c8.8.8.8\u003e 1.1.1.1' -H 'X-Real-IP: 2.2.2.2' 两层代理的情况下结果为：\n[HTTP_X_FORWARDED_FOR] =\u003e unkonw, \u003c8.8.8.8\u003e 1.1.1.1, 10.100.11.25, 10.200.21.34 [REMOTE_ADDR] =\u003e 10.200.21.33 [HTTP_X_REAL_IP] =\u003e 10.200.21.34 根据上面的情况，怎么挑出真正的用户 IP 呢？设想三种方案：\n1、第一层代理将用户的真实 IP 放在 X-Real-IP 中传递下去，后面的每一层都使用 X-Real-IP 继续往下传递。配置为：\nproxy_set_header X-Real-IP $remote_addr; # 针对首层代理，拿到真实IP proxy_set_header X-Real-IP $http_x_real_ip; # 针对非首层代理，一直传下去 2、从首层开始，将用户的真实 IP 放在 X-Forwarded-For 中，而不是累加各层服务器的 IP，但这样也不够合理，因为丢掉了整个链路信息。配置为：\nproxy_set_header X-Forwarded-For $remote_addr; # 针对首层代理 proxy_set_header X-Forwarded-For $http_x_forwarded_for; # 针对非首层代理 3、从 X-Forwarded-For 中获取的用户真实 IP，排除掉所有代理 IP，取最后一个符合 IP 规则的，注意不是第一个，因为第一个可能是被伪造的（除非首层代理使用了握手会话 IP 做为值向下传递）。\n一般 CDN 都会将用户的真实 IP 在 XFF 中传递下去。我们可以做几个简单的测试就能知道我们该怎么做。\n注意：Nginx 配置的这两个变量：\n$proxy_add_x_forwarded_for 会累加代理层的 IP 向后传递 $http_x_forwarded_for 仅仅是上层传过来的值 Nginx realip 模块获取真实 IP 秉承一个原则：能通过配置让事情变的更简单和通用的事儿，就不要用程序去解决。即环境对程序透明。 这当然少不了系统运维人员的辛苦。\n如果能在配置中理清，就不必用复杂的程序去解决，因为 Server 上可能有各种应用都要来获取用户 IP，如果规则不统一，结果会不一致。\n程序不知道链路到底经过了几层才转到 WEB Server 上，所以让程序去做兼容并不是个好主意。索性就让程序把所有的代理都当成透明的好了。\n上面介绍的三种方法中，如果不能保证前面的代理层使用我们指定的规则，这时候怎么办呢？只能使用第三种方法。然后我们将各层代理的 IP 排除在外，就取到了真实的用户 IP。这个可以使用 Nginx 的一个模块儿 Module ngx_http_realip_module 来实现。\n原理是从 XFF 中抛弃指定的代理层 IP，那么最后一个符合规则的就是用户 IP。也可以配合第一起方法一起使用。但无论如何，首层代理的规则最重要，直接影响后面的代理层和 WEB Server 的接收结果。\n然后在 Nginx 配置中增加以下配置（可以在 http、server 或 location 段中增加）：\n# set user real ip to remote addr set_real_ip_from 10.200.21.0/24; set_real_ip_from 10.100.23.0/24; real_ip_header X-Forwarded-For; real_ip_recursive on; set_real_ip_from 后面是可信 IP 规则，可以有多条。如果启用 CDN，知道 CDN 的溯源 IP，也要加进来，除排掉可信的，就是用户的真实 IP，会写入 remote_addr 这个变量中。\n在 PHP 中可以使用 $_SERVER['REMOTE_ADDR'] 来获取。而 WEB Server 不使用任何反向代理时，也是取这个值，这就达到了我们之前所说的原则。\nreal_ip_recursive 是递归的去除所配置中的可信 IP。如果只有一层代理，也可以不写这个参数。\nThinkPHP 中的获取 IP 方法 ThinkPHP 的 function 中提供了一个工具方法，在对获取 IP 地址不严格的情况下，可以启用高级模式\n/** * 获取客户端IP地址 * @param integer $type 返回类型 0 返回IP地址 1 返回IPV4地址数字 * @param boolean $adv 是否进行高级模式获取（有可能被伪装） * @return mixed */ function get_client_ip($type = 0, $adv = false) { $type = $type ? 1 : 0; static $ip = NULL; if ($ip !== NULL) return $ip[$type]; if($adv){ if (isset($_SERVER['HTTP_X_FORWARDED_FOR'])) { $arr = explode(',', $_SERVER['HTTP_X_FORWARDED_FOR']); $pos = array_search('unknown',$arr); if(false !== $pos) unset($arr[$pos]); $ip = trim($arr[0]); }elseif (isset($_SERVER['HTTP_CLIENT_IP'])) { $ip = $_SERVER['HTTP_CLIENT_IP']; }elseif (isset($_SERVER['REMOTE_ADDR'])) { $ip = $_SERVER['REMOTE_ADDR']; } }elseif (isset($_SERVER['REMOTE_ADDR'])) { $ip = $_SERVER['REMOTE_ADDR']; } // IP地址合法验证 $long = sprintf(\"%u\",ip2long($ip)); $ip = $long ? array($ip, $long) : array('0.0.0.0', 0); return $ip[$type]; } Nginx LOG 记录真实 IP log_format porxy '$http_x_forwarded_for - $remote_user [$time_local] ' ' \"$request\" $status $body_bytes_sent ' ' \"$http_referer\" \"$http_user_agent\" '; access_log /usr/local/nginx/logs/access.log porxy; 文章称 nginx reload 配置并不生效，需要 restart。\nReferences 使用 PHP 获取客户端真实 IP 地址？——不可能！ - 也就这样 NGINX 多层转发或使用 CDN 之后如何获取用户真实 IP | Snow Blog Nginx 日志配置详情解析 – EOF –\n","wordCount":"438","inLanguage":"en","datePublished":"2017-06-02T16:00:00Z","dateModified":"2017-06-02T16:00:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zyf.im/2017/06/02/php-get-real-ip-after-nginx-using-reverse-proxy-or-cdn/"},"publisher":{"@type":"Organization","name":"ZYF.IM BLOG","logo":{"@type":"ImageObject","url":"https://zyf.im/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://zyf.im/ accesskey=h title="ZYF.IM (Alt + H)"><img src=https://zyf.im/apple-touch-icon.png alt aria-label=logo height=35>ZYF.IM</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://zyf.im/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://zyf.im/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://zyf.im/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://zyf.im/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://zyf.im/>Home</a>&nbsp;»&nbsp;<a href=https://zyf.im/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">PHP 中获取 Nginx 使用反向代理或 CDN 后的客户端真实 IP</h1><div class=post-meta><span title='2017-06-02 16:00:00 +0000 UTC'>June 2, 2017</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;438 words&nbsp;·&nbsp;Me</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#在未使用-cdn-和反向代理情况下>在未使用 CDN 和反向代理情况下</a></li><li><a href=#在使用-cdn-和反向代理情况下>在使用 CDN 和反向代理情况下</a><ul><li><a href=#铁律>铁律</a></li><li><a href=#只有一层代理的情况>只有一层代理的情况</a></li><li><a href=#两层或更多代理的情况>两层或更多代理的情况</a></li></ul></li><li><a href=#nginx-realip-模块获取真实-ip>Nginx realip 模块获取真实 IP</a></li><li><a href=#thinkphp-中的获取-ip-方法>ThinkPHP 中的获取 IP 方法</a></li><li><a href=#nginx-log-记录真实-ip>Nginx LOG 记录真实 IP</a></li><li><a href=#references>References</a></li></ul></nav></div></details></div><div class=post-content><p>获取 Nginx 反向代理后的客户端 IP，基本是按一定顺序检测以下参数中的信息：</p><ul><li>HTTP_CLIENT_IP</li><li>HTTP_X_REAL_FORWARDED_FOR</li><li>HTTP_X_FORWARDED_FOR</li><li>REMOTE_ADDR</li></ul><h2 id=在未使用-cdn-和反向代理情况下>在未使用 CDN 和反向代理情况下<a hidden class=anchor aria-hidden=true href=#在未使用-cdn-和反向代理情况下>#</a></h2><p>当业务服务器直接暴露在公网上，并且未使用 CDN 和反向代理服务器时，可以直接使用 <code>remote_addr</code>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-php data-lang=php><span class=line><span class=cl><span class=nv>$_SERVER</span><span class=p>[</span><span class=s1>&#39;REMOTE_ADDR&#39;</span><span class=p>]</span>
</span></span></code></pre></div><p>这时候 <code>HTTP_X_FORWARDED_FOR</code> 和 <code>HTTP_X_REAL_IP</code> 都是可以被伪造的，但 <code>REMOTE_ADDR</code> 是客户端和服务器的握手 IP，即 client 的出口 IP，伪造不了。</p><h2 id=在使用-cdn-和反向代理情况下>在使用 CDN 和反向代理情况下<a hidden class=anchor aria-hidden=true href=#在使用-cdn-和反向代理情况下>#</a></h2><h3 id=铁律>铁律<a hidden class=anchor aria-hidden=true href=#铁律>#</a></h3><p>当多层代理或使用 CDN 时，如果代理服务器不把用户的真实 IP 传递下去，那么业务服务器将永远不可能获取到用户的真实 IP。</p><p>如果 WEB 服务器上层也是使用 Nginx 做代理或负载均衡，则需要在代理层的 Nginx 配置中明确 XFF 参数，累加传递上一个请求方的 IP 到 header 请求中。以下是代理层的 Nginx 配置参数。</p><pre tabindex=0><code class=language-conf data-lang=conf>proxy_set_header X-Real-IP $remote_addr;
proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
proxy_set_header Host $http_host;
proxy_set_header X-NginX-Proxy true;
</code></pre><h3 id=只有一层代理的情况>只有一层代理的情况<a hidden class=anchor aria-hidden=true href=#只有一层代理的情况>#</a></h3><p>我们按上面的配置发起一个伪造请求，10.100.11.25 是我电脑的 IP，链路为：</p><pre tabindex=0><code>10.100.11.25(client)-&gt;10.200.21.33(Proxy)-&gt;10.200.21.32(Web Server)
</code></pre><p>curl 请求：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>curl http://10.200.21.33:88/test.php -H <span class=s1>&#39;X-Forwarded-For: unkonw, &lt;8.8.8.8&gt; 1.1.1.1&#39;</span> -H <span class=s1>&#39;X-Real-IP: 2.2.2.2&#39;</span>
</span></span></code></pre></div><p>结果为：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=o>[</span>HTTP_X_FORWARDED_FOR<span class=o>]</span> <span class=o>=</span>&gt; unkonw, &lt;8.8.8.8&gt; 1.1.1.1, 10.100.11.25
</span></span><span class=line><span class=cl><span class=o>[</span>REMOTE_ADDR<span class=o>]</span> <span class=o>=</span>&gt; 10.200.21.33
</span></span><span class=line><span class=cl><span class=o>[</span>HTTP_X_REAL_IP<span class=o>]</span> <span class=o>=</span>&gt; 10.100.11.25
</span></span></code></pre></div><p>我们可以看到，XFF 被附加上了我的 IP，但前面的一系列伪造内容，可以轻易骗过很多规则，而 <code>HTTP_X_REAL_IP</code> 则传递了我电脑的 IP。因为在上面的配置中，<code>X-Real-IP</code> 已经被设置为握手 IP。</p><p>但多层代理之后，以上面的规则，显然 <code>HTTP_X_REAL_IP</code> 也不会是真实的用户 IP 了。而 <code>HTTP_X_FORWARDED_FOR</code> 则在原有信息（我们伪造的信息）之后附上了握手 IP 一起传递过来了。</p><h3 id=两层或更多代理的情况>两层或更多代理的情况<a hidden class=anchor aria-hidden=true href=#两层或更多代理的情况>#</a></h3><p>我们这里只测试两层，实际链路为：</p><pre tabindex=0><code>10.100.11.25(client)-&gt;10.200.21.34(Proxy)-&gt;10.200.21.33(Proxy)-&gt;10.200.21.32(Web Server)
</code></pre><p>curl 请求：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>curl http://10.200.21.34:88/test.php -H <span class=s1>&#39;X-Forwarded-For: unkonw, &lt;8.8.8.8&gt; 1.1.1.1&#39;</span> -H <span class=s1>&#39;X-Real-IP: 2.2.2.2&#39;</span>
</span></span></code></pre></div><p>两层代理的情况下结果为：</p><pre tabindex=0><code>[HTTP_X_FORWARDED_FOR] =&gt; unkonw, &lt;8.8.8.8&gt; 1.1.1.1, 10.100.11.25, 10.200.21.34
[REMOTE_ADDR] =&gt; 10.200.21.33
[HTTP_X_REAL_IP] =&gt; 10.200.21.34
</code></pre><p>根据上面的情况，怎么挑出真正的用户 IP 呢？设想三种方案：</p><p>1、第一层代理将用户的真实 IP 放在 <code>X-Real-IP</code> 中传递下去，后面的每一层都使用 <code>X-Real-IP</code> 继续往下传递。配置为：</p><pre tabindex=0><code>proxy_set_header X-Real-IP $remote_addr;    # 针对首层代理，拿到真实IP
proxy_set_header X-Real-IP $http_x_real_ip; # 针对非首层代理，一直传下去
</code></pre><p>2、从首层开始，将用户的真实 IP 放在 X-Forwarded-For 中，而不是累加各层服务器的 IP，但这样也不够合理，因为丢掉了整个链路信息。配置为：</p><pre tabindex=0><code>proxy_set_header X-Forwarded-For $remote_addr; # 针对首层代理
proxy_set_header X-Forwarded-For $http_x_forwarded_for; # 针对非首层代理
</code></pre><p>3、从 <code>X-Forwarded-For</code> 中获取的用户真实 IP，排除掉所有代理 IP，取最后一个符合 IP 规则的，注意不是第一个，因为第一个可能是被伪造的（除非首层代理使用了握手会话 IP 做为值向下传递）。</p><p>一般 CDN 都会将用户的真实 IP 在 XFF 中传递下去。我们可以做几个简单的测试就能知道我们该怎么做。</p><p>注意：Nginx 配置的这两个变量：</p><ul><li><code>$proxy_add_x_forwarded_for</code> 会累加代理层的 IP 向后传递</li><li><code>$http_x_forwarded_for</code> 仅仅是上层传过来的值</li></ul><h2 id=nginx-realip-模块获取真实-ip>Nginx realip 模块获取真实 IP<a hidden class=anchor aria-hidden=true href=#nginx-realip-模块获取真实-ip>#</a></h2><p>秉承一个原则：<em>能通过配置让事情变的更简单和通用的事儿，就不要用程序去解决。即环境对程序透明。</em> 这当然少不了系统运维人员的辛苦。</p><p>如果能在配置中理清，就不必用复杂的程序去解决，因为 Server 上可能有各种应用都要来获取用户 IP，如果规则不统一，结果会不一致。</p><p>程序不知道链路到底经过了几层才转到 WEB Server 上，所以让程序去做兼容并不是个好主意。索性就让程序把所有的代理都当成透明的好了。</p><p>上面介绍的三种方法中，如果不能保证前面的代理层使用我们指定的规则，这时候怎么办呢？只能使用第三种方法。然后我们将各层代理的 IP 排除在外，就取到了真实的用户 IP。这个可以使用 Nginx 的一个模块儿 <a href=http://nginx.org/en/docs/http/ngx_http_realip_module.html>Module ngx_http_realip_module</a> 来实现。</p><p>原理是从 XFF 中抛弃指定的代理层 IP，那么最后一个符合规则的就是用户 IP。也可以配合第一起方法一起使用。但无论如何，首层代理的规则最重要，直接影响后面的代理层和 WEB Server 的接收结果。</p><p>然后在 Nginx 配置中增加以下配置（可以在 http、server 或 location 段中增加）：</p><pre tabindex=0><code># set user real ip to remote addr
set_real_ip_from   10.200.21.0/24;
set_real_ip_from   10.100.23.0/24;
real_ip_header     X-Forwarded-For;
real_ip_recursive on;
</code></pre><p><code>set_real_ip_from</code> 后面是可信 IP 规则，可以有多条。如果启用 CDN，知道 CDN 的溯源 IP，也要加进来，除排掉可信的，就是用户的真实 IP，会写入 <code>remote_addr</code> 这个变量中。</p><p>在 PHP 中可以使用 <code>$_SERVER['REMOTE_ADDR']</code> 来获取。而 WEB Server 不使用任何反向代理时，也是取这个值，这就达到了我们之前所说的原则。</p><p><code>real_ip_recursive</code> 是递归的去除所配置中的可信 IP。如果只有一层代理，也可以不写这个参数。</p><h2 id=thinkphp-中的获取-ip-方法>ThinkPHP 中的获取 IP 方法<a hidden class=anchor aria-hidden=true href=#thinkphp-中的获取-ip-方法>#</a></h2><p>ThinkPHP 的 function 中提供了一个工具方法，在对获取 IP 地址不严格的情况下，可以启用高级模式</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-php data-lang=php><span class=line><span class=cl><span class=sd>/**
</span></span></span><span class=line><span class=cl><span class=sd> * 获取客户端IP地址
</span></span></span><span class=line><span class=cl><span class=sd> * @param integer $type 返回类型 0 返回IP地址 1 返回IPV4地址数字
</span></span></span><span class=line><span class=cl><span class=sd> * @param boolean $adv 是否进行高级模式获取（有可能被伪装）
</span></span></span><span class=line><span class=cl><span class=sd> * @return mixed
</span></span></span><span class=line><span class=cl><span class=sd> */</span>
</span></span><span class=line><span class=cl><span class=k>function</span> <span class=nf>get_client_ip</span><span class=p>(</span><span class=nv>$type</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=nv>$adv</span> <span class=o>=</span> <span class=k>false</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nv>$type</span>       <span class=o>=</span>  <span class=nv>$type</span> <span class=o>?</span> <span class=mi>1</span> <span class=o>:</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=nv>$ip</span>  <span class=o>=</span>   <span class=k>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nv>$ip</span> <span class=o>!==</span> <span class=k>NULL</span><span class=p>)</span> <span class=k>return</span> <span class=nv>$ip</span><span class=p>[</span><span class=nv>$type</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=nv>$adv</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=nx>isset</span><span class=p>(</span><span class=nv>$_SERVER</span><span class=p>[</span><span class=s1>&#39;HTTP_X_FORWARDED_FOR&#39;</span><span class=p>]))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nv>$arr</span>    <span class=o>=</span>   <span class=nx>explode</span><span class=p>(</span><span class=s1>&#39;,&#39;</span><span class=p>,</span> <span class=nv>$_SERVER</span><span class=p>[</span><span class=s1>&#39;HTTP_X_FORWARDED_FOR&#39;</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>            <span class=nv>$pos</span>    <span class=o>=</span>   <span class=nx>array_search</span><span class=p>(</span><span class=s1>&#39;unknown&#39;</span><span class=p>,</span><span class=nv>$arr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span><span class=p>(</span><span class=k>false</span> <span class=o>!==</span> <span class=nv>$pos</span><span class=p>)</span> <span class=nx>unset</span><span class=p>(</span><span class=nv>$arr</span><span class=p>[</span><span class=nv>$pos</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>            <span class=nv>$ip</span>     <span class=o>=</span>   <span class=nx>trim</span><span class=p>(</span><span class=nv>$arr</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span><span class=k>elseif</span> <span class=p>(</span><span class=nx>isset</span><span class=p>(</span><span class=nv>$_SERVER</span><span class=p>[</span><span class=s1>&#39;HTTP_CLIENT_IP&#39;</span><span class=p>]))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nv>$ip</span>     <span class=o>=</span>   <span class=nv>$_SERVER</span><span class=p>[</span><span class=s1>&#39;HTTP_CLIENT_IP&#39;</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span><span class=k>elseif</span> <span class=p>(</span><span class=nx>isset</span><span class=p>(</span><span class=nv>$_SERVER</span><span class=p>[</span><span class=s1>&#39;REMOTE_ADDR&#39;</span><span class=p>]))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nv>$ip</span>     <span class=o>=</span>   <span class=nv>$_SERVER</span><span class=p>[</span><span class=s1>&#39;REMOTE_ADDR&#39;</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span><span class=k>elseif</span> <span class=p>(</span><span class=nx>isset</span><span class=p>(</span><span class=nv>$_SERVER</span><span class=p>[</span><span class=s1>&#39;REMOTE_ADDR&#39;</span><span class=p>]))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nv>$ip</span>     <span class=o>=</span>   <span class=nv>$_SERVER</span><span class=p>[</span><span class=s1>&#39;REMOTE_ADDR&#39;</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// IP地址合法验证
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nv>$long</span> <span class=o>=</span> <span class=nx>sprintf</span><span class=p>(</span><span class=s2>&#34;%u&#34;</span><span class=p>,</span><span class=nx>ip2long</span><span class=p>(</span><span class=nv>$ip</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=nv>$ip</span>   <span class=o>=</span> <span class=nv>$long</span> <span class=o>?</span> <span class=k>array</span><span class=p>(</span><span class=nv>$ip</span><span class=p>,</span> <span class=nv>$long</span><span class=p>)</span> <span class=o>:</span> <span class=k>array</span><span class=p>(</span><span class=s1>&#39;0.0.0.0&#39;</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nv>$ip</span><span class=p>[</span><span class=nv>$type</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=nginx-log-记录真实-ip>Nginx LOG 记录真实 IP<a hidden class=anchor aria-hidden=true href=#nginx-log-记录真实-ip>#</a></h2><pre tabindex=0><code>log_format porxy &#39;$http_x_forwarded_for - $remote_user [$time_local] &#39;
                 &#39; &#34;$request&#34;  $status $body_bytes_sent &#39;
                 &#39; &#34;$http_referer&#34;  &#34;$http_user_agent&#34; &#39;;

access_log /usr/local/nginx/logs/access.log porxy;
</code></pre><p>文章称 <code>nginx reload</code> 配置并不生效，需要 <code>restart</code>。</p><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><ul><li><a href=http://blog.zhengshuiguang.com/php/php-ip.html>使用 PHP 获取客户端真实 IP 地址？——不可能！ - 也就这样</a></li><li><a href=http://www.wkii.org/nginx-cdn-get-user-real-ip.html>NGINX 多层转发或使用 CDN 之后如何获取用户真实 IP | Snow Blog</a></li><li><a href=https://juejin.im/post/59f94f626fb9a045023af34c>Nginx 日志配置详情解析</a></li></ul><p>&ndash; EOF &ndash;</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://zyf.im/tags/nginx/>Nginx</a></li><li><a href=https://zyf.im/tags/php/>Php</a></li></ul><nav class=paginav><a class=prev href=https://zyf.im/2017/06/06/nginx-enable-http2/><span class=title>« Prev</span><br><span>NGINX 启用 HTTP/2</span>
</a><a class=next href=https://zyf.im/2017/05/25/how-to-use-this-self-parent-in-php/><span class=title>Next »</span><br><span>PHP 中 this self parent 用法</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://zyf.im/>ZYF.IM BLOG</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>