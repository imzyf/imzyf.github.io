<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>【Git 权威指南】读书笔记 - 独奏 - Part 4 | ZYF.IM BLOG</title><meta name=keywords content="git"><meta name=description content='主要内容：【历史穿梭】、【改变历史】、【Git 克隆】
历史穿梭
查看条件个数：
git rev-list HEAD | wc -l
版本表示法：git rev-parse
git rev-parse pick out and massage parameters for other git commands.

--git-dir 可以显示 Git 版本库的位置
--show-cdup 当前工作区目录的深度
--parseopt 可以用于被 Git 无关应用用于解析命令行参数

# 显示分支，tag
git rev-parse --symbolic --branches

git rev-parse --symbolic --branches

# 显示定义的所有引用
git rev-parse --symbolic --glob=refs/*

# 显示多个表达式的 SHA1 哈希值：

git rev-parse  master  refs/heads/master
6652a0dce6a5067732c00ef0a220810a7230655e
6652a0dce6a5067732c00ef0a220810a7230655e

^后面的数字代表该提交的第几个父提交，~<n>就相当于连续<n>个符号^

git rev-parse  A~3  A^^^
e80aa7481beda65ae00e35afc4bc4b171f9b0ebf
e80aa7481beda65ae00e35afc4bc4b171f9b0ebf

# 暂存区里的文件和HEAD中的文件相同

git rev-parse  :gitg.png  HEAD:gitg.png
fc58966ccc1e5af24c2c9746196550241bc01c50
fc58966ccc1e5af24c2c9746196550241bc01c50

# 在提交日志中查找字串的方式显示提交
git rev-parse :/"Commit A"
81993234fc12a325d303eccea20f6fd629412712
版本范围表示法：git rev-list
git rev-list 可以帮助研究 Git 的各种版本范围语法。'><meta name=author content="Me"><link rel=canonical href=https://zyf.im/2017/12/25/got-git-reading-notes-solo-part4/><link crossorigin=anonymous href=/assets/css/stylesheet.63618a0fd0c7dd946ad6f368012c097fc6e5a8464cefd289c140dd28c01ec58d.css integrity="sha256-Y2GKD9DH3ZRq1vNoASwJf8blqEZM79KJwUDdKMAexY0=" rel="preload stylesheet" as=style><link rel=icon href=https://zyf.im/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zyf.im/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://zyf.im/favicon-32x32.png><link rel=apple-touch-icon href=https://zyf.im/apple-touch-icon.png><link rel=mask-icon href=https://zyf.im/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://zyf.im/2017/12/25/got-git-reading-notes-solo-part4/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-6DVZ6E58DG"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-6DVZ6E58DG")}</script><meta property="og:url" content="https://zyf.im/2017/12/25/got-git-reading-notes-solo-part4/"><meta property="og:site_name" content="ZYF.IM BLOG"><meta property="og:title" content="【Git 权威指南】读书笔记 - 独奏 - Part 4"><meta property="og:description" content='主要内容：【历史穿梭】、【改变历史】、【Git 克隆】
历史穿梭 查看条件个数：
git rev-list HEAD | wc -l 版本表示法：git rev-parse git rev-parse pick out and massage parameters for other git commands.
--git-dir 可以显示 Git 版本库的位置 --show-cdup 当前工作区目录的深度 --parseopt 可以用于被 Git 无关应用用于解析命令行参数 # 显示分支，tag git rev-parse --symbolic --branches git rev-parse --symbolic --branches # 显示定义的所有引用 git rev-parse --symbolic --glob=refs/* # 显示多个表达式的 SHA1 哈希值： git rev-parse master refs/heads/master 6652a0dce6a5067732c00ef0a220810a7230655e 6652a0dce6a5067732c00ef0a220810a7230655e ^后面的数字代表该提交的第几个父提交，~<n>就相当于连续<n>个符号^ git rev-parse A~3 A^^^ e80aa7481beda65ae00e35afc4bc4b171f9b0ebf e80aa7481beda65ae00e35afc4bc4b171f9b0ebf # 暂存区里的文件和HEAD中的文件相同 git rev-parse :gitg.png HEAD:gitg.png fc58966ccc1e5af24c2c9746196550241bc01c50 fc58966ccc1e5af24c2c9746196550241bc01c50 # 在提交日志中查找字串的方式显示提交 git rev-parse :/"Commit A" 81993234fc12a325d303eccea20f6fd629412712 版本范围表示法：git rev-list git rev-list 可以帮助研究 Git 的各种版本范围语法。'><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2017-12-25T16:00:00+08:00"><meta property="article:modified_time" content="2017-12-25T16:00:00+08:00"><meta property="article:tag" content="Git"><meta name=twitter:card content="summary"><meta name=twitter:title content="【Git 权威指南】读书笔记 - 独奏 - Part 4"><meta name=twitter:description content='主要内容：【历史穿梭】、【改变历史】、【Git 克隆】
历史穿梭
查看条件个数：
git rev-list HEAD | wc -l
版本表示法：git rev-parse
git rev-parse pick out and massage parameters for other git commands.

--git-dir 可以显示 Git 版本库的位置
--show-cdup 当前工作区目录的深度
--parseopt 可以用于被 Git 无关应用用于解析命令行参数

# 显示分支，tag
git rev-parse --symbolic --branches

git rev-parse --symbolic --branches

# 显示定义的所有引用
git rev-parse --symbolic --glob=refs/*

# 显示多个表达式的 SHA1 哈希值：

git rev-parse  master  refs/heads/master
6652a0dce6a5067732c00ef0a220810a7230655e
6652a0dce6a5067732c00ef0a220810a7230655e

^后面的数字代表该提交的第几个父提交，~<n>就相当于连续<n>个符号^

git rev-parse  A~3  A^^^
e80aa7481beda65ae00e35afc4bc4b171f9b0ebf
e80aa7481beda65ae00e35afc4bc4b171f9b0ebf

# 暂存区里的文件和HEAD中的文件相同

git rev-parse  :gitg.png  HEAD:gitg.png
fc58966ccc1e5af24c2c9746196550241bc01c50
fc58966ccc1e5af24c2c9746196550241bc01c50

# 在提交日志中查找字串的方式显示提交
git rev-parse :/"Commit A"
81993234fc12a325d303eccea20f6fd629412712
版本范围表示法：git rev-list
git rev-list 可以帮助研究 Git 的各种版本范围语法。'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zyf.im/posts/"},{"@type":"ListItem","position":2,"name":"【Git 权威指南】读书笔记 - 独奏 - Part 4","item":"https://zyf.im/2017/12/25/got-git-reading-notes-solo-part4/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"【Git 权威指南】读书笔记 - 独奏 - Part 4","name":"【Git 权威指南】读书笔记 - 独奏 - Part 4","description":"主要内容：【历史穿梭】、【改变历史】、【Git 克隆】\n历史穿梭 查看条件个数：\ngit rev-list HEAD | wc -l 版本表示法：git rev-parse git rev-parse pick out and massage parameters for other git commands.\n--git-dir 可以显示 Git 版本库的位置 --show-cdup 当前工作区目录的深度 --parseopt 可以用于被 Git 无关应用用于解析命令行参数 # 显示分支，tag git rev-parse --symbolic --branches git rev-parse --symbolic --branches # 显示定义的所有引用 git rev-parse --symbolic --glob=refs/* # 显示多个表达式的 SHA1 哈希值： git rev-parse master refs/heads/master 6652a0dce6a5067732c00ef0a220810a7230655e 6652a0dce6a5067732c00ef0a220810a7230655e ^后面的数字代表该提交的第几个父提交，~\u0026lt;n\u0026gt;就相当于连续\u0026lt;n\u0026gt;个符号^ git rev-parse A~3 A^^^ e80aa7481beda65ae00e35afc4bc4b171f9b0ebf e80aa7481beda65ae00e35afc4bc4b171f9b0ebf # 暂存区里的文件和HEAD中的文件相同 git rev-parse :gitg.png HEAD:gitg.png fc58966ccc1e5af24c2c9746196550241bc01c50 fc58966ccc1e5af24c2c9746196550241bc01c50 # 在提交日志中查找字串的方式显示提交 git rev-parse :/\u0026#34;Commit A\u0026#34; 81993234fc12a325d303eccea20f6fd629412712 版本范围表示法：git rev-list git rev-list 可以帮助研究 Git 的各种版本范围语法。\n","keywords":["git"],"articleBody":"主要内容：【历史穿梭】、【改变历史】、【Git 克隆】\n历史穿梭 查看条件个数：\ngit rev-list HEAD | wc -l 版本表示法：git rev-parse git rev-parse pick out and massage parameters for other git commands.\n--git-dir 可以显示 Git 版本库的位置 --show-cdup 当前工作区目录的深度 --parseopt 可以用于被 Git 无关应用用于解析命令行参数 # 显示分支，tag git rev-parse --symbolic --branches git rev-parse --symbolic --branches # 显示定义的所有引用 git rev-parse --symbolic --glob=refs/* # 显示多个表达式的 SHA1 哈希值： git rev-parse master refs/heads/master 6652a0dce6a5067732c00ef0a220810a7230655e 6652a0dce6a5067732c00ef0a220810a7230655e ^后面的数字代表该提交的第几个父提交，~就相当于连续个符号^ git rev-parse A~3 A^^^ e80aa7481beda65ae00e35afc4bc4b171f9b0ebf e80aa7481beda65ae00e35afc4bc4b171f9b0ebf # 暂存区里的文件和HEAD中的文件相同 git rev-parse :gitg.png HEAD:gitg.png fc58966ccc1e5af24c2c9746196550241bc01c50 fc58966ccc1e5af24c2c9746196550241bc01c50 # 在提交日志中查找字串的方式显示提交 git rev-parse :/\"Commit A\" 81993234fc12a325d303eccea20f6fd629412712 版本范围表示法：git rev-list git rev-list 可以帮助研究 Git 的各种版本范围语法。\n# 从开始到 tag：A 的所有历史提交 git rev-list --oneline A # 每个 tag 历史提交的并集 git rev-list --oneline D F # ^ 排除这个版本及其历史版本 git rev-list --oneline ^G D # ^G D 等价于 G..D git rev-list --oneline G..D # 含 ^ 的参数顺序不重要，.. # ^B C 相当于 B..C # C ^B 相当于 B..C # C..B 相当于 ^C B 浏览日志：git --graph 参数调用 git log 可以显示字符界面的提交关系图。\ngit config --global alias.glog \"log --graph\" --oneline 单行显示 - 显示最近的 条日志 -p 显示变动 --stat 显示变动摘要 查看、分析某一个提交：\ngit show D --stat tag D ... git cat-file -p D^0 差异比较：git diff 比较里程碑 B 和里程碑 A，用命令：git diff B A 比较工作区和里程碑 A，用命令：git diff A 比较暂存区和里程碑 A，用命令：git diff -cached A 比较工作区和暂存区，用命令：git diff 比较暂存区和 HEAD，用命令：git diff -cached 比较工作区和 HEAD，用命令：git diff HEAD 显示不同版本下的文件差异：\ngit diff -- 非 Git 目录/文件的差异比较，可在版本库之外使用：\ngit diff --word-diff 差异逐 词 比较，而非缺省的逐 行 比较 文件追溯：git blame 逐行显示文件，在每一行的行首显示此行最早是在什么版本引入的，由谁引入。\n只想查看某几行，使用 -L n,m 参数：\ngit blame -L 6,+5 README 二分查找：git bisect 定位问题代码。\n改变历史 作为分布式版本控制系统，一旦版本库被多人共享，改变历史就可能是无法完成的任务。\n悔棋 git commit –amend 单步悔棋，修补式提交。\n检出文件到前一版：\ngit checkout HEAD^ -- src/hello.h 多步悔棋 git reset --soft HEAD^^ 回到未来 拣选指令 git cherry-pick 从众多的提交中挑选出一个提交应用在当前的工作分支中。\n该命令需要提供一个提交 ID 作为参数，操作过程相当于将该提交导出为补丁文件，然后在当前 HEAD 上重放形成无论内容还是提交说明都一致的提交。\n操作例子：A B C D E F 6 次提交。\n例子 1.1：出掉 D：\n# 将 HEAD 指针切换到 C git checkout C # 拣选将 E 提交在当前 HEAD 上 git cherry-pick E # 拣选操作将 F 提交在当前 HEAD 上 git cherry-pick master # 将 master 分支指向新的提交 ID（f677821）上 git checkout master git reset --hard HEAD@{1} 例子 1.2：D 融入 C：\ngit checkout D # 将 C 和 D 融合 git reset --soft HEAD^^ # 提交说明重用C提交的提交说明 git commit -C C git cherry-pick E git cherry-pick F git rebase 对提交执行变基操作，即可以实现将指定范围的提交“嫁接”到另外一个提交之上。\ngit rebase --onto 变基操作的过程：\n首先执行 git checkout ，如果 till 不是一个分支，则变基操作是在 detached HEAD 分离头指针 状态的，当变基结束后，对 master 分支执行重置以实现把变基结果记录在分支中。 将..所标识的提交范围写到一个临时文件中。（..是指包括的所有历史提交排除以及的历史提交后形成的版本范围） 当前分支强制重置（git reset –hard）到。 从保存在临时文件中的提交列表中，一个一个将提交按照顺序重新提交到重置之后的分支上。 如果遇到提交已经在分支中包含，跳过该提交。 如果在提交过程遇到冲突，变基过程暂停。用户解决冲突后，执行 git rebase –continue 继续变基操作。或者执行 git rebase –skip 跳过此提交。或者执行 git rebase –abort 就此终止变基操作切换到变基前的分支上。 例子 2.1：出掉 D：\ngit rebase --onto C D F # or git rebase --onto C E^ F 例子 2.2：D 融入 C：\ngit checkout D # C和D融合 git reset --soft HEAD^^ git add . # 复用 C 的提交信息 git commit -C C # 记住这个提交 ID，可以用 tag 的方法 git tag newbase git rebase --onto newbase E^ master -i 交互式变基方法。\n例子 3.1：出掉 D：\ngit rebase -i D^ # d, drop = remove commit # 提交 D 标示修改为 d 例子 3.2：D 融入 C：\ngit rebase -i C^ # 提交 D 标示修改为 s 丢弃历史 重点内容第一次 Get\n历史有的时候会成为负担。只保留最近的 100 次提交，抛弃之前的历史提交。那么应该如何操作呢？\n例：清除 tag A 之前的提交历史：\n# 查看里程碑A指向的目录树 git cat-file -p A^{tree} # 使用git commit-tree命令直接从该目录树创建提交 echo \"Commit from tree of tag A.\" | git commit-tree A^{tree} 8f7f94ba6a9d94ecc1c223aa4b311670599e1f86 # 命令git commit-tree的输出是一个提交的SHA1哈希值。 # 会发现这个提交没有历史提交，可以称之为孤儿提交。 git log 8f7f94ba6a9d94ecc1c223aa4b311670599e1f86 # 将master分支从里程碑到最新的提交全部迁移到刚刚生成的孤儿提交上。 git rebase --onto 8f7f94ba6a9d94ecc1c223aa4b311670599e1f86 A master 反转提交 git revert HEAD Git 克隆 鸡蛋不装在一个篮子里 1. git clone 2. git clone --bare 3. git clone --mirror 一般约定俗成裸版本库的目录名以 .git 为后缀。\n用法 3 区别于用法 2 之处在于用法 3 克隆出来的裸版本对上游版本库进行了注册，这样可以在裸版本库中使用 git fetch 命令和上游版本库进行持续同步。\n克隆生成裸版本库 git clone --bare /path/to/my/workspace/demo /path/to/repos/demo.git demo.git 目录就是版本库目录，不含工作区。\ngit --git-dir=/path/to/repos/demo.git config core.bare true # 向其 push git push /path/to/repos/demo.git 创建生成裸版本库 git init --bare /path/to/repos/demo-init.git References 2. Git 独奏 — GotGit ","wordCount":"586","inLanguage":"en","datePublished":"2017-12-25T16:00:00+08:00","dateModified":"2017-12-25T16:00:00+08:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zyf.im/2017/12/25/got-git-reading-notes-solo-part4/"},"publisher":{"@type":"Organization","name":"ZYF.IM BLOG","logo":{"@type":"ImageObject","url":"https://zyf.im/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://zyf.im/ accesskey=h title="ZYF.IM (Alt + H)"><img src=https://zyf.im/apple-touch-icon.png alt aria-label=logo height=35>ZYF.IM</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://zyf.im/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://zyf.im/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://zyf.im/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://zyf.im/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://zyf.im/>Home</a>&nbsp;»&nbsp;<a href=https://zyf.im/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">【Git 权威指南】读书笔记 - 独奏 - Part 4</h1><div class=post-meta><span title='2017-12-25 16:00:00 +0800 CST'>December 25, 2017</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;586 words&nbsp;·&nbsp;Me</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#历史穿梭>历史穿梭</a><ul><li><a href=#版本表示法git-rev-parse>版本表示法：git rev-parse</a></li><li><a href=#版本范围表示法git-rev-list>版本范围表示法：git rev-list</a></li><li><a href=#浏览日志git>浏览日志：git</a></li><li><a href=#差异比较git-diff>差异比较：git diff</a></li><li><a href=#文件追溯git-blame>文件追溯：git blame</a></li><li><a href=#二分查找git-bisect>二分查找：git bisect</a></li></ul></li><li><a href=#改变历史>改变历史</a><ul><li><a href=#悔棋>悔棋</a></li><li><a href=#多步悔棋>多步悔棋</a></li><li><a href=#回到未来>回到未来</a></li><li><a href=#丢弃历史>丢弃历史</a></li><li><a href=#反转提交>反转提交</a></li></ul></li><li><a href=#git-克隆>Git 克隆</a><ul><li><a href=#鸡蛋不装在一个篮子里>鸡蛋不装在一个篮子里</a></li><li><a href=#克隆生成裸版本库>克隆生成裸版本库</a></li><li><a href=#创建生成裸版本库>创建生成裸版本库</a></li></ul></li><li><a href=#references>References</a></li></ul></nav></div></details></div><div class=post-content><p>主要内容：【历史穿梭】、【改变历史】、【Git 克隆】</p><h2 id=历史穿梭>历史穿梭<a hidden class=anchor aria-hidden=true href=#历史穿梭>#</a></h2><p>查看条件个数：</p><pre tabindex=0><code>git rev-list HEAD | wc -l
</code></pre><h3 id=版本表示法git-rev-parse>版本表示法：git rev-parse<a hidden class=anchor aria-hidden=true href=#版本表示法git-rev-parse>#</a></h3><p><code>git rev-parse</code> pick out and massage parameters for other git commands.</p><ul><li><code>--git-dir</code> 可以显示 Git 版本库的位置</li><li><code>--show-cdup</code> 当前工作区目录的深度</li><li><code>--parseopt</code> 可以用于被 Git 无关应用用于解析命令行参数</li></ul><pre tabindex=0><code># 显示分支，tag
git rev-parse --symbolic --branches

git rev-parse --symbolic --branches

# 显示定义的所有引用
git rev-parse --symbolic --glob=refs/*
</code></pre><pre tabindex=0><code># 显示多个表达式的 SHA1 哈希值：

git rev-parse  master  refs/heads/master
6652a0dce6a5067732c00ef0a220810a7230655e
6652a0dce6a5067732c00ef0a220810a7230655e

^后面的数字代表该提交的第几个父提交，~&lt;n&gt;就相当于连续&lt;n&gt;个符号^

git rev-parse  A~3  A^^^
e80aa7481beda65ae00e35afc4bc4b171f9b0ebf
e80aa7481beda65ae00e35afc4bc4b171f9b0ebf

# 暂存区里的文件和HEAD中的文件相同

git rev-parse  :gitg.png  HEAD:gitg.png
fc58966ccc1e5af24c2c9746196550241bc01c50
fc58966ccc1e5af24c2c9746196550241bc01c50

# 在提交日志中查找字串的方式显示提交
git rev-parse :/&#34;Commit A&#34;
81993234fc12a325d303eccea20f6fd629412712
</code></pre><h3 id=版本范围表示法git-rev-list>版本范围表示法：git rev-list<a hidden class=anchor aria-hidden=true href=#版本范围表示法git-rev-list>#</a></h3><p><code>git rev-list</code> 可以帮助研究 Git 的各种版本范围语法。</p><pre tabindex=0><code># 从开始到 tag：A 的所有历史提交
git rev-list --oneline  A

# 每个 tag 历史提交的并集
git rev-list --oneline  D  F

# ^ 排除这个版本及其历史版本
git rev-list --oneline  ^G D

# ^G D 等价于 G..D
git rev-list --oneline  G..D

# 含 ^ 的参数顺序不重要，..
# ^B C 相当于 B..C
# C ^B 相当于 B..C
# C..B 相当于 ^C B
</code></pre><h3 id=浏览日志git>浏览日志：git<a hidden class=anchor aria-hidden=true href=#浏览日志git>#</a></h3><p><code>--graph</code> 参数调用 <code>git log</code> 可以显示字符界面的提交关系图。</p><pre tabindex=0><code>git config --global alias.glog &#34;log --graph&#34;
</code></pre><ul><li><code>--oneline</code> 单行显示</li><li><code>-&lt;n></code> 显示最近的 <n>条日志</li><li><code>-p</code> 显示变动</li><li><code>--stat</code> 显示变动摘要</li></ul><p>查看、分析某一个提交：</p><pre tabindex=0><code>git show D --stat
tag D
...

git cat-file -p D^0
</code></pre><h3 id=差异比较git-diff>差异比较：git diff<a hidden class=anchor aria-hidden=true href=#差异比较git-diff>#</a></h3><ul><li>比较里程碑 B 和里程碑 A，用命令：git diff B A</li><li>比较工作区和里程碑 A，用命令：git diff A</li><li>比较暂存区和里程碑 A，用命令：git diff -cached A</li><li>比较工作区和暂存区，用命令：git diff</li><li>比较暂存区和 HEAD，用命令：git diff -cached</li><li>比较工作区和 HEAD，用命令：git diff HEAD</li></ul><p>显示不同版本下的文件差异：</p><pre tabindex=0><code>git diff &lt;commit1&gt; &lt;commit2&gt; -- &lt;paths&gt;
</code></pre><p>非 Git 目录/文件的差异比较，可在版本库之外使用：</p><pre tabindex=0><code>git diff &lt;path1&gt; &lt;path2&gt;
</code></pre><ul><li><code>--word-diff</code> 差异逐 <em>词</em> 比较，而非缺省的逐 <em>行</em> 比较</li></ul><h3 id=文件追溯git-blame>文件追溯：git blame<a hidden class=anchor aria-hidden=true href=#文件追溯git-blame>#</a></h3><p>逐行显示文件，在每一行的行首显示此行最早是在什么版本引入的，由谁引入。</p><p>只想查看某几行，使用 -L n,m 参数：</p><pre tabindex=0><code>git blame -L 6,+5 README
</code></pre><h3 id=二分查找git-bisect>二分查找：git bisect<a hidden class=anchor aria-hidden=true href=#二分查找git-bisect>#</a></h3><p>定位问题代码。</p><h2 id=改变历史>改变历史<a hidden class=anchor aria-hidden=true href=#改变历史>#</a></h2><p>作为分布式版本控制系统，一旦版本库被多人共享，改变历史就可能是无法完成的任务。</p><h3 id=悔棋>悔棋<a hidden class=anchor aria-hidden=true href=#悔棋>#</a></h3><p><code>git commit –amend</code> 单步悔棋，修补式提交。</p><p>检出文件到前一版：</p><pre tabindex=0><code>git checkout HEAD^ -- src/hello.h
</code></pre><h3 id=多步悔棋>多步悔棋<a hidden class=anchor aria-hidden=true href=#多步悔棋>#</a></h3><pre tabindex=0><code>git reset --soft HEAD^^
</code></pre><h3 id=回到未来>回到未来<a hidden class=anchor aria-hidden=true href=#回到未来>#</a></h3><p>拣选指令 <code>git cherry-pick</code> 从众多的提交中挑选出一个提交应用在当前的工作分支中。</p><p>该命令需要提供一个提交 ID 作为参数，操作过程相当于将该提交导出为补丁文件，然后在当前 HEAD 上重放形成无论内容还是提交说明都一致的提交。</p><p>操作例子：<code>A B C D E F</code> 6 次提交。</p><p>例子 1.1：出掉 <code>D</code>：</p><pre tabindex=0><code># 将 HEAD 指针切换到 C
git checkout C

# 拣选将 E 提交在当前 HEAD 上
git cherry-pick E

# 拣选操作将 F 提交在当前 HEAD 上
git cherry-pick master

# 将 master 分支指向新的提交 ID（f677821）上
git checkout master
git reset --hard HEAD@{1}
</code></pre><p>例子 1.2：D 融入 C：</p><pre tabindex=0><code>git checkout D

# 将 C 和 D 融合
git reset --soft HEAD^^

# 提交说明重用C提交的提交说明
git commit -C C

git cherry-pick E
git cherry-pick F
</code></pre><p>git rebase 对提交执行变基操作，即可以实现将指定范围的提交“嫁接”到另外一个提交之上。</p><pre tabindex=0><code>git rebase --onto &lt;newbase&gt; &lt;since&gt; &lt;till&gt;
</code></pre><p>变基操作的过程：</p><ol><li>首先执行 git checkout <till>，如果 till 不是一个分支，则变基操作是在 detached HEAD 分离头指针 状态的，当变基结束后，对 master 分支执行重置以实现把变基结果记录在分支中。</li><li>将<since>..<till>所标识的提交范围写到一个临时文件中。（<since>..<till>是指包括<till>的所有历史提交排除<since>以及<since>的历史提交后形成的版本范围）</li><li>当前分支强制重置（git reset &ndash;hard）到<newbase>。</li><li>从保存在临时文件中的提交列表中，一个一个将提交按照顺序重新提交到重置之后的分支上。</li><li>如果遇到提交已经在分支中包含，跳过该提交。</li><li>如果在提交过程遇到冲突，变基过程暂停。用户解决冲突后，执行 git rebase –continue 继续变基操作。或者执行 git rebase –skip 跳过此提交。或者执行 git rebase –abort 就此终止变基操作切换到变基前的分支上。</li></ol><p>例子 2.1：出掉 <code>D</code>：</p><pre tabindex=0><code>git rebase --onto C D F
# or
git rebase --onto C E^ F
</code></pre><p>例子 2.2：D 融入 C：</p><pre tabindex=0><code>git checkout D

# C和D融合
git reset --soft HEAD^^

git add .

# 复用 C 的提交信息
git commit -C C

# 记住这个提交 ID，可以用 tag 的方法
git tag newbase

git rebase --onto newbase E^ master
</code></pre><p><code>-i</code> 交互式变基方法。</p><p>例子 3.1：出掉 <code>D</code>：</p><pre tabindex=0><code>git rebase -i D^

# d, drop = remove commit
# 提交 D 标示修改为 d
</code></pre><p>例子 3.2：D 融入 C：</p><pre tabindex=0><code>git rebase -i C^

# 提交 D 标示修改为 s
</code></pre><h3 id=丢弃历史>丢弃历史<a hidden class=anchor aria-hidden=true href=#丢弃历史>#</a></h3><p><strong>重点内容第一次 Get</strong></p><p>历史有的时候会成为负担。只保留最近的 100 次提交，抛弃之前的历史提交。那么应该如何操作呢？</p><p>例：清除 tag A 之前的提交历史：</p><pre tabindex=0><code># 查看里程碑A指向的目录树
git cat-file -p A^{tree}

# 使用git commit-tree命令直接从该目录树创建提交
echo &#34;Commit from tree of tag A.&#34; | git commit-tree A^{tree}
8f7f94ba6a9d94ecc1c223aa4b311670599e1f86

# 命令git commit-tree的输出是一个提交的SHA1哈希值。
# 会发现这个提交没有历史提交，可以称之为孤儿提交。
git log 8f7f94ba6a9d94ecc1c223aa4b311670599e1f86

# 将master分支从里程碑到最新的提交全部迁移到刚刚生成的孤儿提交上。
git rebase --onto 8f7f94ba6a9d94ecc1c223aa4b311670599e1f86 A master
</code></pre><h3 id=反转提交>反转提交<a hidden class=anchor aria-hidden=true href=#反转提交>#</a></h3><pre tabindex=0><code>git revert HEAD
</code></pre><h2 id=git-克隆>Git 克隆<a hidden class=anchor aria-hidden=true href=#git-克隆>#</a></h2><h3 id=鸡蛋不装在一个篮子里>鸡蛋不装在一个篮子里<a hidden class=anchor aria-hidden=true href=#鸡蛋不装在一个篮子里>#</a></h3><pre tabindex=0><code>1. git clone &lt;repository&gt; &lt;directory&gt;
2. git clone --bare   &lt;repository&gt; &lt;directory.git&gt;
3. git clone --mirror &lt;repository&gt; &lt;directory.git&gt;
</code></pre><p>一般约定俗成裸版本库的目录名以 <code>.git</code> 为后缀。</p><p>用法 3 区别于用法 2 之处在于用法 3 克隆出来的裸版本对上游版本库进行了注册，这样可以在裸版本库中使用 git fetch 命令和上游版本库进行持续同步。</p><h3 id=克隆生成裸版本库>克隆生成裸版本库<a hidden class=anchor aria-hidden=true href=#克隆生成裸版本库>#</a></h3><pre tabindex=0><code>git clone --bare /path/to/my/workspace/demo /path/to/repos/demo.git
</code></pre><p>demo.git 目录就是版本库目录，不含工作区。</p><pre tabindex=0><code>git --git-dir=/path/to/repos/demo.git config core.bare
true

# 向其 push
git push /path/to/repos/demo.git
</code></pre><h3 id=创建生成裸版本库>创建生成裸版本库<a hidden class=anchor aria-hidden=true href=#创建生成裸版本库>#</a></h3><pre tabindex=0><code>git init --bare /path/to/repos/demo-init.git
</code></pre><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><ul><li><a href=http://www.worldhello.net/gotgit/02-git-solo/index.html>2. Git 独奏 — GotGit</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://zyf.im/tags/git/>Git</a></li></ul><nav class=paginav><a class=prev href=https://zyf.im/2017/12/31/review-2017/><span class=title>« Prev</span><br><span>回顾 2017</span>
</a><a class=next href=https://zyf.im/2017/11/25/ios-recruitment-summary/><span class=title>Next »</span><br><span>iOS 招聘总结</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://zyf.im/>ZYF.IM BLOG</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>