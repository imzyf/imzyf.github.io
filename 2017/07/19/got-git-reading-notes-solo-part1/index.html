<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><link rel="preconnect" href="//www.googletagmanager.com"><link rel="preconnect" href="//zz.bdstatic.com"><link rel="preconnect" href="//sp0.baidu.com"><link rel="preconnect" href="//www.google-analytics.com"><link rel="preconnect" href="//cdn1.lncld.net"><link rel="preconnect" href="//unpkg.com"><link rel="preconnect" href="//app-router.leancloud.cn"><link rel="preconnect" href="//9qpuwspm.api.lncld.net"><link rel="preconnect" href="//gravatar.loli.net"><title>【Git 权威指南】读书笔记 - 独奏 - Part 1 | 全力以赴</title><meta name="HandheldFriendly" content="True"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="generator" content="hexo"><meta name="author" content="Yifans_Z"><meta name="description" content=""><meta name="keywords" content=""><meta name="theme-color" content="#3c484e"><meta name="msapplication-TileColor" content="#3c484e"><meta property="og:site_name" content="全力以赴"><meta property="og:type" content="article"><meta property="og:title" content="【Git 权威指南】读书笔记 - 独奏 - Part 1 | 全力以赴"><meta property="og:description" content=""><meta property="og:url" content="https://zyf.im/2017/07/19/got-git-reading-notes-solo-part1/"><meta property="article:published_time" content="2017-07-19T16:07:00+08:00"><meta property="article:author" content="Yifans_Z"><meta property="article:published_first" content="全力以赴, /2017/07/19/got-git-reading-notes-solo-part1/"><link rel="stylesheet" href="/css/allinonecss.min.css"><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-84666938-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-84666938-1")</script></head><body class="post-template"><div class="site-wrapper"><header class="site-header post-site-header outer"><div class="inner"><nav class="site-nav"><div class="site-nav-left"><ul class="nav"><li><a href="/" title="Home">HOME</a></li><li><a href="/archives" title="ARCHIVES">ARCHIVES</a></li><li><a href="/links" title="LINKS">LINKS</a></li><li><a href="/about" title="ABOUT">ABOUT</a></li></ul></div><div class="search-button-area"><a href="#search" class="search-button">Search ...</a></div><div class="site-nav-right"><a href="#search" class="search-button">Search ...</a><div class="social-links"><a class="social-link" title="github" href="https://github.com/imzyf" target="_blank" rel="noopener"><svg viewBox="0 0 1049 1024" xmlns="http://www.w3.org/2000/svg"><path d="M524.979332 0C234.676191 0 0 234.676191 0 524.979332c0 232.068678 150.366597 428.501342 358.967656 498.035028 26.075132 5.215026 35.636014-11.299224 35.636014-25.205961 0-12.168395-0.869171-53.888607-0.869171-97.347161-146.020741 31.290159-176.441729-62.580318-176.441729-62.580318-23.467619-60.841976-58.234462-76.487055-58.234463-76.487055-47.804409-32.15933 3.476684-32.15933 3.476685-32.15933 53.019436 3.476684 80.83291 53.888607 80.83291 53.888607 46.935238 79.963739 122.553122 57.365291 152.97411 43.458554 4.345855-33.897672 18.252593-57.365291 33.028501-70.402857-116.468925-12.168395-239.022047-57.365291-239.022047-259.012982 0-57.365291 20.860106-104.300529 53.888607-140.805715-5.215026-13.037566-23.467619-66.926173 5.215027-139.067372 0 0 44.327725-13.906737 144.282399 53.888607 41.720212-11.299224 86.917108-17.383422 131.244833-17.383422s89.524621 6.084198 131.244833 17.383422C756.178839 203.386032 800.506564 217.29277 800.506564 217.29277c28.682646 72.1412 10.430053 126.029806 5.215026 139.067372 33.897672 36.505185 53.888607 83.440424 53.888607 140.805715 0 201.64769-122.553122 245.975415-239.891218 259.012982 19.121764 16.514251 35.636014 47.804409 35.636015 97.347161 0 70.402857-0.869171 126.898978-0.869172 144.282399 0 13.906737 9.560882 30.420988 35.636015 25.205961 208.601059-69.533686 358.967656-265.96635 358.967655-498.035028C1049.958663 234.676191 814.413301 0 524.979332 0z"></path></svg></a></div></div></nav></div></header><div id="site-main" class="site-main outer" role="main"><div class="inner"><header class="post-full-header"><div class="post-full-meta"><time class="post-full-meta-date" datetime="2017-07-19T08:00:00.000Z">2017-07-19 </time><span class="date-divider">/</span></div><h1 class="post-full-title">【Git 权威指南】读书笔记 - 独奏 - Part 1</h1></header><div class="post-full no-image"><div class="post-full-content"><article id="photoswipe" class="markdown-body"><p>主要内容：【Git 初始化】、【Git 暂存区】、【Git 对象】</p><h2 id="Git-初始化"><a href="#Git-初始化" class="headerlink" title="Git 初始化"></a>Git 初始化</h2><p>设置一下 Git 的环境变量，这个设置是一次性的工作。即这些设置会在全局文件（用户主目录下的 <code>~/.gitconfig</code>）或系统文件（<code>/etc/gitconfig</code>）中做永久的记录。</p><p>配置的用户名和邮件地址将在版本库提交时作为提交者的用户名和邮件地址。</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">"Jiang Xin"</span></span><br><span class="line">$ git config --global user.email jiangxin@ossxp.com</span><br></pre></td></tr></tbody></table></figure><h3 id="设置一些-Git-别名，以便可以使用更为简洁的子命令"><a href="#设置一些-Git-别名，以便可以使用更为简洁的子命令" class="headerlink" title="设置一些 Git 别名，以便可以使用更为简洁的子命令"></a>设置一些 Git 别名，以便可以使用更为简洁的子命令</h3><p>只在本用户的全局配置中添加 Git 命令别名：</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git config --global alias.br branch</span><br><span class="line">$ git config --global alias.ci <span class="string">"commit -s"</span></span><br><span class="line">$ git config --global alias.co checkout</span><br><span class="line">$ git config --global alias.st <span class="string">"-p status"</span></span><br></pre></td></tr></tbody></table></figure><a id="more"></a><h3 id="版本库的初始化"><a href="#版本库的初始化" class="headerlink" title="版本库的初始化"></a>版本库的初始化</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ mkdir demo</span><br><span class="line">$ <span class="built_in">cd</span> demo</span><br><span class="line">$ git init</span><br></pre></td></tr></tbody></table></figure><p>初始化空的 Git 版本库于 <code>/path/to/my/workspace/demo/.git/</code></p><p>git init 命令的后面直接输入目录名称</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /path/to/my/workspace</span><br><span class="line">$ git init demo</span><br></pre></td></tr></tbody></table></figure><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ ls -aF</span><br><span class="line">./  ../  .git/</span><br></pre></td></tr></tbody></table></figure><p>这个隐藏的 <code>.git</code> 目录就是 Git 版本库（又叫仓库，repository）。</p><p><code>.git</code> 版本库目录所在的目录，即 <code>/path/to/my/workspace/demo</code> 目录称为 <strong>工作区</strong>。</p><p>将新建立的文件添加到版本库</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git add welcome.txt</span><br></pre></td></tr></tbody></table></figure><p>再执行一次提交操作，使用 <code>-m</code> 参数直接给出了提交说明。</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git ci -m <span class="string">"initialized"</span></span><br><span class="line">[master (root-commit) 7f0b2be] init</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 welcome.txt</span><br></pre></td></tr></tbody></table></figure><p><code>git ci</code> 是上面配置的别名，我个人觉得 <code>-s</code> 这个参数比较冗余。</p><h3 id="思考：为什么工作区下有一个-git-目录？"><a href="#思考：为什么工作区下有一个-git-目录？" class="headerlink" title="思考：为什么工作区下有一个 .git 目录？"></a>思考：为什么工作区下有一个 <code>.git</code> 目录？</h3><p>Git 的这种设计，将版本库放在工作区根目录下，所有的版本控制操作（除了和其他远程版本库之间的互操作）都在本地即可完成，不像 Subversion 只有寥寥无几的几个命令才能脱离网络执行。而且 Git 也没有 CVS 和 Subversion 的安全泄漏问题（只要保护好 .git 目录），也没有 Subversion 在本地文件搜索时出现搜索结果混乱的问题，甚至 Git 还提供了一条 <code>git grep</code> 命令来更好地搜索工作区的文件内容。</p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">$ git grep "工作区文件内容搜索"</span><br></pre></td></tr></tbody></table></figure><h3 id="当工作区中包含了子目录，在子目录中执行-Git-命令时，如何定位版本库呢？"><a href="#当工作区中包含了子目录，在子目录中执行-Git-命令时，如何定位版本库呢？" class="headerlink" title="当工作区中包含了子目录，在子目录中执行 Git 命令时，如何定位版本库呢？"></a>当工作区中包含了子目录，在子目录中执行 Git 命令时，如何定位版本库呢？</h3><p>当在 Git 工作区目录下执行操作的时候，会对目录依次向上递归查找 <code>.git</code> 目录，找到的 <code>.git</code> 目录就是工作区对应的版本库，<code>.git</code> 所在的目录就是工作区的根目录，文件 <code>.git/index</code> 记录了工作区文件的状态（实际上是 <strong>暂存区</strong> 的状态）。</p><p>如果跟踪一下执行 <code>git status</code> 命令时的磁盘访问，会看到沿目录依次向上递归的过程。</p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">$ strace -e 'trace=file' git status</span><br></pre></td></tr></tbody></table></figure><h3 id="那么有什么办法知道-Git-版本库的位置，以及工作区的根目录在哪里呢？"><a href="#那么有什么办法知道-Git-版本库的位置，以及工作区的根目录在哪里呢？" class="headerlink" title="那么有什么办法知道 Git 版本库的位置，以及工作区的根目录在哪里呢？"></a>那么有什么办法知道 Git 版本库的位置，以及工作区的根目录在哪里呢？</h3><p>显示版本库 <code>.git</code> 目录所在的位置。</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git rev-parse --git-dir</span><br><span class="line">/path/to/my/workspace/demo/.git</span><br></pre></td></tr></tbody></table></figure><p>显示工作区根目录。</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git rev-parse --show-toplevel</span><br><span class="line">/path/to/my/workspace/demo</span><br></pre></td></tr></tbody></table></figure><h3 id="把版本库-git-目录放在工作区，是不是太不安全了？"><a href="#把版本库-git-目录放在工作区，是不是太不安全了？" class="headerlink" title="把版本库 .git 目录放在工作区，是不是太不安全了？"></a>把版本库 <code>.git</code> 目录放在工作区，是不是太不安全了？</h3><p>Git 克隆可以降低因为版本库和工作区混杂在一起导致的版本库被破坏的风险。在本机另外的磁盘/目录中建立 Git 克隆，并在工作区有改动提交时，手动或自动地执行向克隆版本库的推送 <code>git push</code> 操作。如果使用网络协议，还可以实现在其他机器上建立克隆，这样就更安全了（双机备份）。</p><h3 id="思考：git-config-命令参数的区别？"><a href="#思考：git-config-命令参数的区别？" class="headerlink" title="思考：git config 命令参数的区别？"></a>思考：<code>git config</code> 命令参数的区别？</h3><p>将打开 /path/to/my/workspace/demo/.git/config 文件进行编辑：</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /path/to/my/workspace/demo/</span><br><span class="line">$ git config -e</span><br></pre></td></tr></tbody></table></figure><p>将打开 /home/jiangxin/.gitconfig（用户主目录下的 .gitconfig 文件）全局配置文件进行编辑：</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git config -e --global</span><br></pre></td></tr></tbody></table></figure><p>将打开 /etc/gitconfig 系统级配置文件进行编辑：</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git config -e --system</span><br></pre></td></tr></tbody></table></figure><p>Git 的三个配置文件分别是 <code>版本库级别的配置文件</code>、<code>全局配置文件</code>（用户主目录下）和 <code>系统级配置文件</code>（/etc 目录下）。</p><p>其中 <code>版本库级别配置文件</code> 的优先级最高，<code>全局配置文件</code> 其次，<code>系统级配置文件</code> 优先级最低。</p><p>Git 配置文件采用的是 INI 文件格式。</p><figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line">$ cat /path/to/my/workspace/demo/.git/config</span><br><span class="line"><span class="section">[core]</span></span><br><span class="line">        repositoryformatversion = 0</span><br><span class="line">        filemode = true</span><br><span class="line">        bare = false</span><br><span class="line">        logallrefupdates = true</span><br></pre></td></tr></tbody></table></figure><p>例如读取 <code>[core]</code> 小节的 <code>bare</code> 的属性值</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">git config &lt;section&gt;.&lt;key&gt;</span><br><span class="line"></span><br><span class="line">$ git config core.bare</span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></tbody></table></figure><p>更改或设置 INI 文件中某个属性</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">git config &lt;section&gt;.&lt;key&gt; &lt;value&gt;</span><br><span class="line"></span><br><span class="line">$ git config a.b something</span><br><span class="line">$ git config x.y.z others</span><br></pre></td></tr></tbody></table></figure><p>打开 <code>.git/config</code> 文件</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">[a]</span><br><span class="line">        b = something</span><br><span class="line">[x <span class="string">"y"</span>]</span><br><span class="line">        z = others</span><br></pre></td></tr></tbody></table></figure><p>可以用 <code>git config</code> 命令操作任何其他的 INI 文件</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ GIT_CONFIG=test.ini git config a.b.c.d <span class="string">"hello, world"</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ GIT_CONFIG=test.ini git config a.b.c.d</span><br><span class="line">hello, world</span><br></pre></td></tr></tbody></table></figure><h3 id="思考：是谁完成的提交？"><a href="#思考：是谁完成的提交？" class="headerlink" title="思考：是谁完成的提交？"></a>思考：是谁完成的提交？</h3><p>当最新的提交删除了 <code>user.name</code> 和 <code>user.email</code>，提交时 Git 对提交者的用户名和邮件地址做了大胆的猜测，这个猜测可能是错的。</p><p>重新设置 <code>user.name</code> 和 <code>user.email</code>，然后执行下面的命令，重新修改最新的提交，改正作者和提交者的错误信息。</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git commit --amend --allow-empty --reset-author</span><br></pre></td></tr></tbody></table></figure><ul><li>参数 <code>--amend</code> 是对刚刚的提交进行修补，这样就可以改正前面错误的提交（用户信息错误），而不会产生另外的新提交。</li><li>参数 <code>--allow-empty</code> 是因为要进行修补的提交实际上是一个空白提交，Git 默认不允许空白提交。</li><li>参数 <code>--reset-author</code> 的含义是将 Author（提交者）的 ID 重置，否则只会影响最新的 Commit（提交者）的 ID。这条命令也会重置 AuthorDate 信息。</li></ul><h3 id="思考：随意设置提交者姓名，是否太不安全？"><a href="#思考：随意设置提交者姓名，是否太不安全？" class="headerlink" title="思考：随意设置提交者姓名，是否太不安全？"></a>思考：随意设置提交者姓名，是否太不安全？</h3><p>Git 可以随意设置提交的用户名和邮件地址信息，这是分布式版本控制系统的特性使然，每个人都是自己版本库的主人，很难也没有必要进行身份认证从而使用经过认证的用户名作为提交的用户名。</p><p>但是可以使用 GitLab 等服务管理权限。</p><h3 id="思考：命令别名是干什么的？"><a href="#思考：命令别名是干什么的？" class="headerlink" title="思考：命令别名是干什么的？"></a>思考：命令别名是干什么的？</h3><p>命令别名可以帮助用户解决从其他版本控制系统迁移到 Git 后的使用习惯问题。</p><h3 id="备份本章的工作成果"><a href="#备份本章的工作成果" class="headerlink" title="备份本章的工作成果"></a>备份本章的工作成果</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /path/to/my/workspace</span><br><span class="line">$ git <span class="built_in">clone</span> demo demo-step-1</span><br><span class="line">Cloning into demo-step-1...</span><br><span class="line"><span class="keyword">done</span>.</span><br></pre></td></tr></tbody></table></figure><h2 id="Git-暂存区"><a href="#Git-暂存区" class="headerlink" title="Git 暂存区"></a>Git 暂存区</h2><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --<span class="built_in">stat</span></span><br></pre></td></tr></tbody></table></figure><p>可以用 <code>git log</code> 查看提交日志，附加的 <code>--stat</code> 参数看到每次提交的文件变更统计。</p><h3 id="修改不能直接提交？"><a href="#修改不能直接提交？" class="headerlink" title="修改不能直接提交？"></a>修改不能直接提交？</h3><p>现在就将修改的文件“添加”到提交暂存区：</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git add welcome.txt</span><br></pre></td></tr></tbody></table></figure><p>这时如果和 HEAD（当前版本库的头指针）或者 master 分支（当前工作分支）进行比较，会发现有差异。这个差异才是正常的，因为尚未真正提交么。</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git diff HEAD</span><br></pre></td></tr></tbody></table></figure><p>用简洁方式显示状态</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git status -s</span><br><span class="line">M  welcome.txt</span><br></pre></td></tr></tbody></table></figure><p>通过参数 <code>--cached</code> 或者 <code>--staged</code> 参数调用 git diff 命令，看到的是提交暂存区 <code>stage</code> 和版本库中文件的差异。不然看到的是工作区的变动。</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git diff --cached</span><br></pre></td></tr></tbody></table></figure><p>现在执行 git commit 命令进行提交。</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git commit -m <span class="string">"which version checked in?"</span></span><br></pre></td></tr></tbody></table></figure><p>如何证明提交成功了呢？通过查看提交日志，看到了新的提交。</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --pretty=oneline</span><br></pre></td></tr></tbody></table></figure><h3 id="理解-Git-暂存区-stage"><a href="#理解-Git-暂存区-stage" class="headerlink" title="理解 Git 暂存区 stage"></a>理解 Git 暂存区 stage</h3><p>当执行 <code>git status</code> 命令（或者 <code>git diff</code> 命令）扫描工作区改动的时候，先依据 <code>.git/index</code> 文件中记录的（工作区跟踪文件的）时间戳、长度等信息判断工作区文件是否改变。</p><p>文件 <code>.git/index</code> 实际上就是一个包含文件索引的目录树，像是一个虚拟的工作区。在这个虚拟工作区的目录树中，记录了文件名、文件的状态信息（时间戳、文件长度等）。文件的内容并不存储其中，而是保存在 Git 对象库 <code>.git/objects</code> 目录中，文件索引建立了文件和对象库中对象实体之间的对应。</p><p><img alt="got-git-reading-notes-solo-git-stage" class="post-img b-lazy" data-img="https://user-images.githubusercontent.com/9289792/80202431-33a64480-8658-11ea-8771-07b2bf81f657.png" data-index="0" data-src="https://user-images.githubusercontent.com/9289792/80202431-33a64480-8658-11ea-8771-07b2bf81f657.png"></p><ul><li>图中可以看出此时 HEAD 实际是指向 master 分支的一个“游标”。所以图示的命令中出现 HEAD 的地方可以用 master 来替换。</li><li>图中的 objects 标识的区域为 Git 的对象库，实际位于 <code>.git/objects</code> 目录下，会在后面的章节重点介绍。</li><li>当执行 <code>git reset HEAD</code> 命令时，暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响。</li><li>当执行 <code>git rm --cached &lt;file&gt;</code> 命令时，会直接从暂存区删除文件，工作区则不做出改变。</li><li>当执行 <code>git checkout .</code> 或者 <code>git checkout -- &lt;file&gt;</code> 命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区的改动。</li><li>当执行 <code>git checkout HEAD .</code> 或者 <code>git checkout HEAD &lt;file&gt;</code> 命令时，会用 HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。</li></ul><h3 id="Git-diff-魔法"><a href="#Git-diff-魔法" class="headerlink" title="Git diff 魔法"></a>Git diff 魔法</h3><p>有什么办法能够像查看工作区一样的，直观的查看暂存区以及 HEAD 当中的目录树么？</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git ls-tree -l HEAD</span><br><span class="line">100644 blob fd3c069c1de4f4bc9b15940f490aeb48852f3c42      25    welcome.txt</span><br></pre></td></tr></tbody></table></figure><p>要显示暂存区的目录树，可以使用 <code>git ls-files</code> 命令。</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git ls-files -s</span><br><span class="line">100644 18832d35117ef2f013c4009f5b2128dfaeff354f 0       a/b/c/hello.txt</span><br></pre></td></tr></tbody></table></figure><p><img alt="got-git-reading-notes-solo-git-diff" class="post-img b-lazy" data-img="https://user-images.githubusercontent.com/9289792/80202327-06599680-8658-11ea-8329-93b424bc3726.png" data-index="1" data-src="https://user-images.githubusercontent.com/9289792/80202327-06599680-8658-11ea-8329-93b424bc3726.png"></p><h3 id="不要使用-git-commit-a"><a href="#不要使用-git-commit-a" class="headerlink" title="不要使用 git commit -a"></a>不要使用 git commit -a</h3><p>提交命令 <code>git commit</code> 可以带上 <code>-a</code> 参数，对本地所有变更的文件执行提交操作，包括本地修改的文件，删除的文件，但不包括未被版本库跟踪的文件。</p><p>这个“偷懒”的提交命令，就会丢掉 Git 暂存区带给用户最大的好处：对提交内容进行控制的能力。</p><h2 id="Git-对象"><a href="#Git-对象" class="headerlink" title="Git 对象"></a>Git 对象</h2><p>什么是 <code>HEAD</code>？什么是 <code>master</code>？为什么它们二者可以相互替换使用？为什么 Git 中的很多对象像提交、树、文件内容等都用 40 位的 <code>SHA1</code> 哈希值来表示？</p><h3 id="Git-对象库探秘"><a href="#Git-对象库探秘" class="headerlink" title="Git 对象库探秘"></a>Git 对象库探秘</h3><p>40 位十六进制数字组成的 <code>SHA1</code> 哈希值</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> -1 --pretty=raw</span><br><span class="line"><span class="comment"># 这是本次提交的唯一标识。</span></span><br><span class="line">commit e695606fc5e31b2ff9038a48a3d363f4c21a3d86</span><br><span class="line"><span class="comment"># 这是本次提交所对应的目录树。</span></span><br><span class="line">tree f58da9a820e3fd9d84ab2ca2f1b467ac265038f9</span><br><span class="line"><span class="comment"># 这是本地提交的父提交（上一次提交）。</span></span><br><span class="line">parent a0c641e92b10d8bcca1ed1bf84ca80340fdefee6</span><br><span class="line"></span><br><span class="line">    <span class="built_in">which</span> version checked <span class="keyword">in</span>?</span><br></pre></td></tr></tbody></table></figure><p>研究 Git 对象 ID 的命令是 <code>git cat-file</code>，用下面的命令可以查看一下这三个 ID 的类型。</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git cat-file -t e695606</span><br><span class="line">commit</span><br><span class="line">$ git cat-file -t f58d</span><br><span class="line">tree</span><br><span class="line">$ git cat-file -t fd3c06</span><br><span class="line">blob</span><br></pre></td></tr></tbody></table></figure><!-- more --><p>再用 <code>git cat-file</code> 命令查看一下这几个对象的内容。对于 <code>blob</code> 对象，这个对象保存着文件 welcome.txt 的内容。</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git cat-file -p fd3c06</span><br><span class="line">Hello.</span><br><span class="line">Nice to meet you.</span><br></pre></td></tr></tbody></table></figure><p>这个写对象都存在 Git 库中的 <code>objects</code> 目录下，ID 的前两位作为目录名，后 38 位作为文件名。</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="keyword">for</span> id <span class="keyword">in</span> e695606 f58da9a a0c641e fd3c069; <span class="keyword">do</span> \</span><br><span class="line">  ls .git/objects/<span class="variable">${id:0:2}</span>/<span class="variable">${id:2}</span>*; <span class="keyword">done</span></span><br><span class="line">.git/objects/e6/95606fc5e31b2ff9038a48a3d363f4c21a3d86</span><br><span class="line">.git/objects/f5/8da9a820e3fd9d84ab2ca2f1b467ac265038f9</span><br><span class="line">.git/objects/a0/c641e92b10d8bcca1ed1bf84ca80340fdefee6</span><br><span class="line">.git/objects/fd/3c069c1de4f4bc9b15940f490aeb48852f3c42</span><br></pre></td></tr></tbody></table></figure><p><img alt="got-git-reading-notes-solo-git-objects" class="post-img b-lazy" data-img="https://user-images.githubusercontent.com/9289792/80202330-08235a00-8658-11ea-9040-b280b00b7e43.png" data-index="2" data-src="https://user-images.githubusercontent.com/9289792/80202330-08235a00-8658-11ea-9040-b280b00b7e43.png"></p><h3 id="HEAD-和-master-的奥秘"><a href="#HEAD-和-master-的奥秘" class="headerlink" title="HEAD 和 master 的奥秘"></a>HEAD 和 master 的奥秘</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> -1 HEAD</span><br><span class="line">$ git <span class="built_in">log</span> -1 master</span><br><span class="line">$ git <span class="built_in">log</span> -1 refs/heads/master</span><br></pre></td></tr></tbody></table></figure><p>在当前版本库中，<code>HEAD</code>、<code>master</code> 和 <code>refs/heads/master</code> 具有相同的指向。现在到版本库 <code>.git</code> 中一探它们的究竟：</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ find .git -name HEAD -o -name master</span><br><span class="line">.git/HEAD</span><br><span class="line">.git/logs/HEAD</span><br><span class="line">.git/logs/refs/heads/master</span><br><span class="line">.git/refs/heads/master</span><br></pre></td></tr></tbody></table></figure><p>显示一下 <code>.git/HEAD</code></p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ cat .git/HEAD</span><br><span class="line">ref: refs/heads/master</span><br></pre></td></tr></tbody></table></figure><p>指向一个引用：<code>refs/heads/master</code></p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ cat .git/refs/heads/master</span><br><span class="line">e695606fc5e31b2ff9038a48a3d363f4c21a3d86</span><br></pre></td></tr></tbody></table></figure><p>显示该提交的内容</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git cat-file -p e695606fc5e31b2ff9038a48a3d363f4c21a3d86</span><br><span class="line">tree f58da9a820e3fd9d84ab2ca2f1b467ac265038f9</span><br><span class="line">parent a0c641e92b10d8bcca1ed1bf84ca80340fdefee6</span><br><span class="line"></span><br><span class="line"><span class="built_in">which</span> version checked <span class="keyword">in</span>?</span><br></pre></td></tr></tbody></table></figure><p>原来分支 <code>master</code> 指向的是一个提交 ID（最新提交）。</p><p>这样的分支实现是多么的巧妙啊：既然可以从任何提交开始建立一条历史跟踪链，那么用一个文件指向这个链条的最新提交，那么这个文件就可以用于追踪整个提交历史了。</p><p>这个文件就是 <code>.git/refs/heads/master</code> 文件。</p><p><img alt="got-git-reading-notes-solo-git-repos-detail" class="post-img b-lazy" data-img="https://user-images.githubusercontent.com/9289792/80202610-78ca7680-8658-11ea-9b85-651555b8f005.png" data-index="3" data-src="https://user-images.githubusercontent.com/9289792/80202610-78ca7680-8658-11ea-9b85-651555b8f005.png"></p><p>目录 <code>.git/refs</code> 是保存引用的命名空间，其中 <code>.git/refs/heads</code> 目录下的引用又称为分支。对于分支既可以使用正规的长格式的表示法，如 <code>refs/heads/master</code>，也可以去掉前面的两级目录用 <code>master</code> 来表示。Git 有一个底层命令 <code>git rev-parse</code> 可以用于显示引用对应的提交 ID。</p><h3 id="问题：SHA1-哈希值到底是什么，如何生成的？"><a href="#问题：SHA1-哈希值到底是什么，如何生成的？" class="headerlink" title="问题：SHA1 哈希值到底是什么，如何生成的？"></a>问题：SHA1 哈希值到底是什么，如何生成的？</h3><p>哈希(hash)是一种数据摘要算法（或称散列算法），是信息安全领域当中重要的理论基石。该算法将任意长度的输入经过散列运算转换为固定长度的输出。固定长度的输出可以称为对应的输入的数字摘要或哈希值。</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> -n Git |sha1sum</span><br><span class="line">5819778898df55e3a762f0c5728b457970d72cae  -</span><br></pre></td></tr></tbody></table></figure><p>提交的 SHA1 哈希值生成方法：</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git cat-file commit HEAD | wc -c</span><br><span class="line">234</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在提交信息的前面加上内容 `commit 234&lt;null&gt;`（`&lt;null&gt;`为空字符），然后执行 SHA1 哈希算法。</span></span><br><span class="line">$ ( <span class="built_in">printf</span> <span class="string">"commit 234\000"</span>; git cat-file commit HEAD ) | sha1sum</span><br><span class="line">e695606fc5e31b2ff9038a48a3d363f4c21a3d86  -</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面命令得到的哈希值和用 `git rev-parse` 看到的是一样的。</span></span><br><span class="line">$ git rev-parse HEAD</span><br><span class="line">e695606fc5e31b2ff9038a48a3d363f4c21a3d86</span><br></pre></td></tr></tbody></table></figure><p>文件内容的 SHA1 哈希值生成方法：</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 文件总共包含 25 字节的内容。</span></span><br><span class="line">$ git cat-file blob HEAD:welcome.txt | wc -c</span><br><span class="line">25</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在文件内容的前面加上blob 25&lt;null&gt;的内容，然后执行SHA1哈希算法。</span></span><br><span class="line">$ ( <span class="built_in">printf</span> <span class="string">"blob 25\000"</span>; git cat-file blob HEAD:welcome.txt ) | sha1sum</span><br><span class="line">fd3c069c1de4f4bc9b15940f490aeb48852f3c42  -</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面命令得到的哈希值和用git rev-parse看到的是一样的。</span></span><br><span class="line">$ git rev-parse HEAD:welcome.txt</span><br><span class="line">fd3c069c1de4f4bc9b15940f490aeb48852f3c42</span><br></pre></td></tr></tbody></table></figure><p>树的 SHA1 哈希值的形成方法：</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># HEAD对应的树的内容共包含39个字节。</span></span><br><span class="line">$ git cat-file tree HEAD^{tree} | wc -c</span><br><span class="line">39</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在树的内容的前面加上tree 39&lt;null&gt;的内容，然后执行SHA1哈希算法。</span></span><br><span class="line">$ ( <span class="built_in">printf</span> <span class="string">"tree 39\000"</span>; git cat-file tree HEAD^{tree} ) | sha1sum</span><br><span class="line">f58da9a820e3fd9d84ab2ca2f1b467ac265038f9  -</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面命令得到的哈希值和用git rev-parse看到的是一样的。</span></span><br><span class="line">$ git rev-parse HEAD^{tree}</span><br><span class="line">f58da9a820e3fd9d84ab2ca2f1b467ac265038f9</span><br></pre></td></tr></tbody></table></figure><h3 id="问题：为什么不用顺序的数字来表示提交？"><a href="#问题：为什么不用顺序的数字来表示提交？" class="headerlink" title="问题：为什么不用顺序的数字来表示提交？"></a>问题：为什么不用顺序的数字来表示提交？</h3><p>集中式版本控制系统因为只有一个集中式的版本库，可以很容易的实现依次递增的全局唯一的提交号。Git 作为分布式版本控制系统，开发可以是非线性的。这就要求提交的编号不能仅仅是本地局部有效，而是要“全球唯一”。</p><p>采用部分的 SHA1 哈希值。不必写全 40 位的哈希值，只采用开头的部分，不和现有其他的冲突即可。</p><p>使用 <code>master</code> 代表分支 <code>master</code> 中最新的提交，使用全称 <code>refs/heads/master</code> 亦可。</p><p>使用 <code>HEAD</code> 代表版本库中最近的一次提交。</p><p>符号 <code>^</code> 可以用于指代父提交。例如：</p><ul><li><code>HEAD^</code> 代表版本库中上一次提交，即最近一次提交的父提交。</li><li><code>HEAD^^</code> 则代表 <code>HEAD^</code> 的父提交。</li></ul><p>对于一个提交有多个父提交，可以在符号 <code>^</code> 后面用数字表示是第几个父提交。例如：</p><ul><li><code>a573106^2</code> 含义是提交 <code>a573106</code> 的多个父提交中的第二个父提交。</li><li><code>HEAD^1</code> 相当于 <code>HEAD^</code> 含义是 HEAD 多个父提交中的第一个。</li><li><code>HEAD^^2</code> 含义是 <code>HEAD^</code>（HEAD 父提交）的多个父提交中的第二个。</li></ul><p>符号 <code>~&lt;n&gt;</code> 也可以用于指代祖先提交。效果等同：</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">a573106~5</span><br><span class="line">a573106^^^^^</span><br></pre></td></tr></tbody></table></figure><p>提交所对应的树对象：<code>a573106^{tree}</code></p><p>某一此提交对应的文件对象：<code>a573106:path/to/file</code></p><p>暂存区中的文件对象：<code>:path/to/file</code></p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">$ git rev-parse HEAD</span><br><span class="line">$ git cat-file -p e695</span><br><span class="line">$ git cat-file -p e695^</span><br><span class="line">$ git rev-parse e695^{tree}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Reference:</p><ul><li><a href="http://www.worldhello.net/gotgit/02-git-solo/index.html" target="_blank" rel="noopener">2. Git 独奏 — GotGit</a></li></ul></blockquote></article><ul class="tags-postTags"><li><a href="/tags/git/" rel="tag"># git</a></li></ul></div></div></div><nav id="gobottom" class="pagination"><a class="prev-post" title="【Git 权威指南】读书笔记 - 独奏 - Part 2" href="/2017/07/20/got-git-reading-notes-solo-part2/">← 【Git 权威指南】读书笔记 - 独奏 - Part 2 </a><span class="prev-next-post">·</span> <a class="next-post" title="【Git 权威指南】读书笔记 - 初识 Git" href="/2017/07/12/got-git-reading-notes-meet-git/">【Git 权威指南】读书笔记 - 初识 Git →</a></nav></div><div class="toc-bar"><div class="toc-btn-bar"><a href="#site-main" class="toc-btn"><svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg"><path d="M793.024 710.272a32 32 0 1 0 45.952-44.544l-310.304-320a32 32 0 0 0-46.4 0.48l-297.696 320a32 32 0 0 0 46.848 43.584l274.752-295.328 286.848 295.808z"></path></svg></a><div class="toc-btn toc-switch"><svg class="toc-open" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg"><path d="M779.776 480h-387.2a32 32 0 0 0 0 64h387.2a32 32 0 0 0 0-64M779.776 672h-387.2a32 32 0 0 0 0 64h387.2a32 32 0 0 0 0-64M256 288a32 32 0 1 0 0 64 32 32 0 0 0 0-64M392.576 352h387.2a32 32 0 0 0 0-64h-387.2a32 32 0 0 0 0 64M256 480a32 32 0 1 0 0 64 32 32 0 0 0 0-64M256 672a32 32 0 1 0 0 64 32 32 0 0 0 0-64"></path></svg> <svg class="toc-close hide" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg"><path d="M512 960c-247.039484 0-448-200.960516-448-448S264.960516 64 512 64 960 264.960516 960 512 759.039484 960 512 960zM512 128.287273c-211.584464 0-383.712727 172.128262-383.712727 383.712727 0 211.551781 172.128262 383.712727 383.712727 383.712727 211.551781 0 383.712727-172.159226 383.712727-383.712727C895.712727 300.415536 723.551781 128.287273 512 128.287273z"></path><path d="M557.05545 513.376159l138.367639-136.864185c12.576374-12.416396 12.672705-32.671738 0.25631-45.248112s-32.704421-12.672705-45.248112-0.25631l-138.560301 137.024163-136.447897-136.864185c-12.512727-12.512727-32.735385-12.576374-45.248112-0.063647-12.512727 12.480043-12.54369 32.735385-0.063647 45.248112l136.255235 136.671523-137.376804 135.904314c-12.576374 12.447359-12.672705 32.671738-0.25631 45.248112 6.271845 6.335493 14.496116 9.504099 22.751351 9.504099 8.12794 0 16.25588-3.103239 22.496761-9.247789l137.567746-136.064292 138.687596 139.136568c6.240882 6.271845 14.432469 9.407768 22.65674 9.407768 8.191587 0 16.352211-3.135923 22.591372-9.34412 12.512727-12.480043 12.54369-32.704421 0.063647-45.248112L557.05545 513.376159z"></path></svg></div><a href="#gobottom" class="toc-btn"><svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg"><path d="M231.424 346.208a32 32 0 0 0-46.848 43.584l297.696 320a32 32 0 0 0 46.4 0.48l310.304-320a32 32 0 1 0-45.952-44.544l-286.848 295.808-274.752-295.36z"></path></svg></a></div><div class="toc-main"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Git-初始化"><span class="toc-text">Git 初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#设置一些-Git-别名，以便可以使用更为简洁的子命令"><span class="toc-text">设置一些 Git 别名，以便可以使用更为简洁的子命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#版本库的初始化"><span class="toc-text">版本库的初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#思考：为什么工作区下有一个-git-目录？"><span class="toc-text">思考：为什么工作区下有一个 .git 目录？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#当工作区中包含了子目录，在子目录中执行-Git-命令时，如何定位版本库呢？"><span class="toc-text">当工作区中包含了子目录，在子目录中执行 Git 命令时，如何定位版本库呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#那么有什么办法知道-Git-版本库的位置，以及工作区的根目录在哪里呢？"><span class="toc-text">那么有什么办法知道 Git 版本库的位置，以及工作区的根目录在哪里呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#把版本库-git-目录放在工作区，是不是太不安全了？"><span class="toc-text">把版本库 .git 目录放在工作区，是不是太不安全了？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#思考：git-config-命令参数的区别？"><span class="toc-text">思考：git config 命令参数的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#思考：是谁完成的提交？"><span class="toc-text">思考：是谁完成的提交？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#思考：随意设置提交者姓名，是否太不安全？"><span class="toc-text">思考：随意设置提交者姓名，是否太不安全？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#思考：命令别名是干什么的？"><span class="toc-text">思考：命令别名是干什么的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#备份本章的工作成果"><span class="toc-text">备份本章的工作成果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Git-暂存区"><span class="toc-text">Git 暂存区</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#修改不能直接提交？"><span class="toc-text">修改不能直接提交？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#理解-Git-暂存区-stage"><span class="toc-text">理解 Git 暂存区 stage</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Git-diff-魔法"><span class="toc-text">Git diff 魔法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#不要使用-git-commit-a"><span class="toc-text">不要使用 git commit -a</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Git-对象"><span class="toc-text">Git 对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Git-对象库探秘"><span class="toc-text">Git 对象库探秘</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HEAD-和-master-的奥秘"><span class="toc-text">HEAD 和 master 的奥秘</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#问题：SHA1-哈希值到底是什么，如何生成的？"><span class="toc-text">问题：SHA1 哈希值到底是什么，如何生成的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#问题：为什么不用顺序的数字来表示提交？"><span class="toc-text">问题：为什么不用顺序的数字来表示提交？</span></a></li></ol></li></ol></div></div><div class="pswp" tabindex="-1" role="dialog" aria-hidden="true"><div class="pswp__bg"></div><div class="pswp__scroll-wrap"><div class="pswp__container"><div class="pswp__item"></div><div class="pswp__item"></div><div class="pswp__item"></div></div><div class="pswp__ui pswp__ui--hidden"><div class="pswp__top-bar"><div class="pswp__counter"></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button> <button class="pswp__button pswp__button--share" title="Share"></button> <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button> <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class="pswp__preloader"><div class="pswp__preloader__icn"><div class="pswp__preloader__cut"><div class="pswp__preloader__donut"></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class="pswp__share-tooltip"></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button> <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class="pswp__caption"><div class="pswp__caption__center"></div></div></div></div></div></div><aside class="read-next outer"><div class="inner"><div class="read-next-feed"><article class="read-next-card" style="background-image:url(https://i.loli.net/2017/11/26/5a19c56faa29f.jpg)"><header class="read-next-card-header"><small class="read-next-card-header-sitetitle">— 全力以赴 —</small><h3 class="read-next-card-header-title">Recent Posts</h3></header><div class="read-next-divider"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 14.5s2 3 5 3 5.5-2.463 5.5-5.5S21 6.5 18 6.5c-5 0-7 11-12 11C2.962 17.5.5 15.037.5 12S3 6.5 6 6.5s4.5 3.5 4.5 3.5"></path></svg></div><div class="read-next-card-content"><ul><li><a href="/2021/09/15/reading-yii2-source-code-04/">Yii2 源码阅读 04 - Application</a></li><li><a href="/2021/09/14/sql-over-partition-by/">分组聚合 OVER PARTITION BY</a></li><li><a href="/2021/07/28/reading-yii2-source-code-03/">Yii2 源码阅读 03 - ServiceLocator Module</a></li></ul></div><footer class="read-next-card-footer"><a href="/archives">MORE →</a></footer></article><article class="read-next-card" style="background-image:url(https://i.loli.net/2017/11/26/5a19c56faa29f.jpg)"><header class="read-next-card-header tagcloud-card"><h3 class="read-next-card-header-title">Categories</h3></header><div class="read-next-card-content"><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/report/">report</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/yii2/">yii2</a></li></ul></div></article><article class="read-next-card" style="background-image:url(https://i.loli.net/2017/11/26/5a19c56faa29f.jpg)"><header class="read-next-card-header tagcloud-card"><h3 class="read-next-card-header-title">Tag Cloud</h3></header><div class="read-next-card-content-ext"><a href="/tags/algorithm/" style="font-size:19px">algorithm</a> <a href="/tags/aws/" style="font-size:14px">aws</a> <a href="/tags/centos/" style="font-size:14.71px">centos</a> <a href="/tags/code-snippet/" style="font-size:15.43px">code-snippet</a> <a href="/tags/composer/" style="font-size:15.43px">composer</a> <a href="/tags/css/" style="font-size:16.86px">css</a> <a href="/tags/design-patterns/" style="font-size:14.71px">design-patterns</a> <a href="/tags/docker/" style="font-size:14px">docker</a> <a href="/tags/git/" style="font-size:23.29px">git</a> <a href="/tags/github/" style="font-size:15.43px">github</a> <a href="/tags/hexo/" style="font-size:15.43px">hexo</a> <a href="/tags/hive/" style="font-size:14px">hive</a> <a href="/tags/html/" style="font-size:16.14px">html</a> <a href="/tags/ios/" style="font-size:20.43px">ios</a> <a href="/tags/java/" style="font-size:21.14px">java</a> <a href="/tags/js/" style="font-size:14px">js</a> <a href="/tags/leetcode/" style="font-size:22.57px">leetcode</a> <a href="/tags/linux/" style="font-size:18.29px">linux</a> <a href="/tags/mac/" style="font-size:16.86px">mac</a> <a href="/tags/movie/" style="font-size:14px">movie</a> <a href="/tags/mysql/" style="font-size:21.86px">mysql</a> <a href="/tags/nginx/" style="font-size:18.29px">nginx</a> <a href="/tags/node-js/" style="font-size:15.43px">node-js</a> <a href="/tags/npm/" style="font-size:14px">npm</a> <a href="/tags/photoshop/" style="font-size:14px">photoshop</a> <a href="/tags/php/" style="font-size:24px">php</a> <a href="/tags/phpstorm/" style="font-size:14.71px">phpstorm</a> <a href="/tags/pr/" style="font-size:14px">pr</a> <a href="/tags/react/" style="font-size:16.14px">react</a> <a href="/tags/react-native/" style="font-size:14px">react-native</a> <a href="/tags/reading-notes/" style="font-size:17.57px">reading-notes</a> <a href="/tags/redis/" style="font-size:14px">redis</a> <a href="/tags/report/" style="font-size:17.57px">report</a> <a href="/tags/sql/" style="font-size:14px">sql</a> <a href="/tags/ssh/" style="font-size:14.71px">ssh</a> <a href="/tags/swift/" style="font-size:19.71px">swift</a> <a href="/tags/swoft/" style="font-size:14px">swoft</a> <a href="/tags/thinking/" style="font-size:14px">thinking</a> <a href="/tags/ubuntu/" style="font-size:20.43px">ubuntu</a> <a href="/tags/vim/" style="font-size:14.71px">vim</a> <a href="/tags/vscode/" style="font-size:14px">vscode</a> <a href="/tags/vue/" style="font-size:14.71px">vue</a> <a href="/tags/xcode/" style="font-size:14px">xcode</a> <a href="/tags/yii2/" style="font-size:17.57px">yii2</a></div></article></div></div></aside><div id="search" class="search-overlay"><div class="search-form"><input id="local-search-input" class="search-input" type="text" name="search" placeholder="Search ..."> <a class="search-overlay-close" href="#"></a></div><div id="local-search-result"></div></div><footer class="site-footer outer"><div class="site-footer-content inner"><div class="copyright"><a href="/" title="全力以赴">全力以赴 © 2021</a></div><nav class="site-footer-nav"><a href="https://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> <a href="https://github.com/xzhih/hexo-theme-casper" title="Casper" target="_blank" rel="noopener">Casper</a></nav></div></footer><script data-ad-client="ca-pub-2330747317815601" async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>window.navigator&&navigator.serviceWorker&&navigator.serviceWorker.getRegistrations().then(function(r){for(var e of r)e.unregister()})</script><script id="scriptLoad" src="/js/allinone.min.js" async=""></script><script>document.getElementById("scriptLoad").addEventListener("load",function(){new Blazy;searchFunc("/")})</script><link rel="stylesheet" href="/photoswipe/photoswipe.css"><link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css"><script src="/photoswipe/photoswipe.min.js"></script><script src="/photoswipe/photoswipe-ui-default.min.js"></script></body></html>