<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>【Git 权威指南】读书笔记 - 独奏 - Part 1 | ZYF.IM BLOG</title><meta name=keywords content="git"><meta name=description content='主要内容：【Git 初始化】、【Git 暂存区】、【Git 对象】
Git 初始化
设置一下 Git 的环境变量，这个设置是一次性的工作。即这些设置会在全局文件（用户主目录下的 ~/.gitconfig）或系统文件（/etc/gitconfig）中做永久的记录。
配置的用户名和邮件地址将在版本库提交时作为提交者的用户名和邮件地址。
git config --global user.name "Jiang Xin"
git config --global user.email jiangxin@ossxp.com
设置一些 Git 别名，以便可以使用更为简洁的子命令
只在本用户的全局配置中添加 Git 命令别名：
git config --global alias.br branch
git config --global alias.ci "commit -s"
git config --global alias.co checkout
git config --global alias.st "-p status"

版本库的初始化
mkdir demo
cd demo
git init
初始化空的 Git 版本库于 /path/to/my/workspace/demo/.git/
git init 命令的后面直接输入目录名称
cd /path/to/my/workspace
git init demo
ls -aF
./  ../  .git/
这个隐藏的 .git 目录就是 Git 版本库（又叫仓库，repository）。'><meta name=author content="Me"><link rel=canonical href=https://zyf.im/2017/07/19/got-git-reading-notes-solo-part1/><link crossorigin=anonymous href=/assets/css/stylesheet.63618a0fd0c7dd946ad6f368012c097fc6e5a8464cefd289c140dd28c01ec58d.css integrity="sha256-Y2GKD9DH3ZRq1vNoASwJf8blqEZM79KJwUDdKMAexY0=" rel="preload stylesheet" as=style><link rel=icon href=https://zyf.im/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zyf.im/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://zyf.im/favicon-32x32.png><link rel=apple-touch-icon href=https://zyf.im/apple-touch-icon.png><link rel=mask-icon href=https://zyf.im/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://zyf.im/2017/07/19/got-git-reading-notes-solo-part1/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-6DVZ6E58DG"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-6DVZ6E58DG")}</script><meta property="og:url" content="https://zyf.im/2017/07/19/got-git-reading-notes-solo-part1/"><meta property="og:site_name" content="ZYF.IM BLOG"><meta property="og:title" content="【Git 权威指南】读书笔记 - 独奏 - Part 1"><meta property="og:description" content='主要内容：【Git 初始化】、【Git 暂存区】、【Git 对象】
Git 初始化 设置一下 Git 的环境变量，这个设置是一次性的工作。即这些设置会在全局文件（用户主目录下的 ~/.gitconfig）或系统文件（/etc/gitconfig）中做永久的记录。
配置的用户名和邮件地址将在版本库提交时作为提交者的用户名和邮件地址。
git config --global user.name "Jiang Xin" git config --global user.email jiangxin@ossxp.com 设置一些 Git 别名，以便可以使用更为简洁的子命令 只在本用户的全局配置中添加 Git 命令别名：
git config --global alias.br branch git config --global alias.ci "commit -s" git config --global alias.co checkout git config --global alias.st "-p status" 版本库的初始化 mkdir demo cd demo git init 初始化空的 Git 版本库于 /path/to/my/workspace/demo/.git/
git init 命令的后面直接输入目录名称
cd /path/to/my/workspace git init demo ls -aF ./ ../ .git/ 这个隐藏的 .git 目录就是 Git 版本库（又叫仓库，repository）。'><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2017-07-19T16:00:00+00:00"><meta property="article:modified_time" content="2017-07-19T16:00:00+00:00"><meta property="article:tag" content="Git"><meta name=twitter:card content="summary"><meta name=twitter:title content="【Git 权威指南】读书笔记 - 独奏 - Part 1"><meta name=twitter:description content='主要内容：【Git 初始化】、【Git 暂存区】、【Git 对象】
Git 初始化
设置一下 Git 的环境变量，这个设置是一次性的工作。即这些设置会在全局文件（用户主目录下的 ~/.gitconfig）或系统文件（/etc/gitconfig）中做永久的记录。
配置的用户名和邮件地址将在版本库提交时作为提交者的用户名和邮件地址。
git config --global user.name "Jiang Xin"
git config --global user.email jiangxin@ossxp.com
设置一些 Git 别名，以便可以使用更为简洁的子命令
只在本用户的全局配置中添加 Git 命令别名：
git config --global alias.br branch
git config --global alias.ci "commit -s"
git config --global alias.co checkout
git config --global alias.st "-p status"

版本库的初始化
mkdir demo
cd demo
git init
初始化空的 Git 版本库于 /path/to/my/workspace/demo/.git/
git init 命令的后面直接输入目录名称
cd /path/to/my/workspace
git init demo
ls -aF
./  ../  .git/
这个隐藏的 .git 目录就是 Git 版本库（又叫仓库，repository）。'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zyf.im/posts/"},{"@type":"ListItem","position":2,"name":"【Git 权威指南】读书笔记 - 独奏 - Part 1","item":"https://zyf.im/2017/07/19/got-git-reading-notes-solo-part1/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"【Git 权威指南】读书笔记 - 独奏 - Part 1","name":"【Git 权威指南】读书笔记 - 独奏 - Part 1","description":"主要内容：【Git 初始化】、【Git 暂存区】、【Git 对象】\nGit 初始化 设置一下 Git 的环境变量，这个设置是一次性的工作。即这些设置会在全局文件（用户主目录下的 ~/.gitconfig）或系统文件（/etc/gitconfig）中做永久的记录。\n配置的用户名和邮件地址将在版本库提交时作为提交者的用户名和邮件地址。\ngit config --global user.name \u0026#34;Jiang Xin\u0026#34; git config --global user.email jiangxin@ossxp.com 设置一些 Git 别名，以便可以使用更为简洁的子命令 只在本用户的全局配置中添加 Git 命令别名：\ngit config --global alias.br branch git config --global alias.ci \u0026#34;commit -s\u0026#34; git config --global alias.co checkout git config --global alias.st \u0026#34;-p status\u0026#34; 版本库的初始化 mkdir demo cd demo git init 初始化空的 Git 版本库于 /path/to/my/workspace/demo/.git/\ngit init 命令的后面直接输入目录名称\ncd /path/to/my/workspace git init demo ls -aF ./ ../ .git/ 这个隐藏的 .git 目录就是 Git 版本库（又叫仓库，repository）。\n","keywords":["git"],"articleBody":"主要内容：【Git 初始化】、【Git 暂存区】、【Git 对象】\nGit 初始化 设置一下 Git 的环境变量，这个设置是一次性的工作。即这些设置会在全局文件（用户主目录下的 ~/.gitconfig）或系统文件（/etc/gitconfig）中做永久的记录。\n配置的用户名和邮件地址将在版本库提交时作为提交者的用户名和邮件地址。\ngit config --global user.name \"Jiang Xin\" git config --global user.email jiangxin@ossxp.com 设置一些 Git 别名，以便可以使用更为简洁的子命令 只在本用户的全局配置中添加 Git 命令别名：\ngit config --global alias.br branch git config --global alias.ci \"commit -s\" git config --global alias.co checkout git config --global alias.st \"-p status\" 版本库的初始化 mkdir demo cd demo git init 初始化空的 Git 版本库于 /path/to/my/workspace/demo/.git/\ngit init 命令的后面直接输入目录名称\ncd /path/to/my/workspace git init demo ls -aF ./ ../ .git/ 这个隐藏的 .git 目录就是 Git 版本库（又叫仓库，repository）。\n.git 版本库目录所在的目录，即 /path/to/my/workspace/demo 目录称为 工作区。\n将新建立的文件添加到版本库\ngit add welcome.txt 再执行一次提交操作，使用 -m 参数直接给出了提交说明。\ngit ci -m \"initialized\" [master (root-commit) 7f0b2be] init 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 welcome.txt git ci 是上面配置的别名，我个人觉得 -s 这个参数比较冗余。\n思考：为什么工作区下有一个 .git 目录？ Git 的这种设计，将版本库放在工作区根目录下，所有的版本控制操作（除了和其他远程版本库之间的互操作）都在本地即可完成，不像 Subversion 只有寥寥无几的几个命令才能脱离网络执行。而且 Git 也没有 CVS 和 Subversion 的安全泄漏问题（只要保护好 .git 目录），也没有 Subversion 在本地文件搜索时出现搜索结果混乱的问题，甚至 Git 还提供了一条 git grep 命令来更好地搜索工作区的文件内容。\ngit grep \"工作区文件内容搜索\" 当工作区中包含了子目录，在子目录中执行 Git 命令时，如何定位版本库呢？ 当在 Git 工作区目录下执行操作的时候，会对目录依次向上递归查找 .git 目录，找到的 .git 目录就是工作区对应的版本库，.git 所在的目录就是工作区的根目录，文件 .git/index 记录了工作区文件的状态（实际上是 暂存区 的状态）。\n如果跟踪一下执行 git status 命令时的磁盘访问，会看到沿目录依次向上递归的过程。\nstrace -e 'trace=file' git status 那么有什么办法知道 Git 版本库的位置，以及工作区的根目录在哪里呢？ 显示版本库 .git 目录所在的位置。\ngit rev-parse --git-dir /path/to/my/workspace/demo/.git 显示工作区根目录。\ngit rev-parse --show-toplevel /path/to/my/workspace/demo 把版本库 .git 目录放在工作区，是不是太不安全了？ Git 克隆可以降低因为版本库和工作区混杂在一起导致的版本库被破坏的风险。在本机另外的磁盘/目录中建立 Git 克隆，并在工作区有改动提交时，手动或自动地执行向克隆版本库的推送 git push 操作。如果使用网络协议，还可以实现在其他机器上建立克隆，这样就更安全了（双机备份）。\n思考：git config 命令参数的区别？ 将打开 /path/to/my/workspace/demo/.git/config 文件进行编辑：\ncd /path/to/my/workspace/demo/ git config -e 将打开 /home/jiangxin/.gitconfig（用户主目录下的 .gitconfig 文件）全局配置文件进行编辑：\ngit config -e --global 将打开 /etc/gitconfig 系统级配置文件进行编辑：\ngit config -e --system Git 的三个配置文件分别是 版本库级别的配置文件、全局配置文件（用户主目录下）和 系统级配置文件（/etc 目录下）。\n其中 版本库级别配置文件 的优先级最高，全局配置文件 其次，系统级配置文件 优先级最低。\nGit 配置文件采用的是 INI 文件格式。\ncat /path/to/my/workspace/demo/.git/config [core] repositoryformatversion = 0 filemode = true bare = false logallrefupdates = true 例如读取 [core] 小节的 bare 的属性值\ngit config . git config core.bare false 更改或设置 INI 文件中某个属性\ngit config . git config a.b something git config x.y.z others 打开 .git/config 文件\n[a] b = something [x \"y\"] z = others 可以用 git config 命令操作任何其他的 INI 文件\nGIT_CONFIG=test.ini git config a.b.c.d \"hello, world\" GIT_CONFIG=test.ini git config a.b.c.d hello, world 思考：是谁完成的提交？ 当最新的提交删除了 user.name 和 user.email，提交时 Git 对提交者的用户名和邮件地址做了大胆的猜测，这个猜测可能是错的。\n重新设置 user.name 和 user.email，然后执行下面的命令，重新修改最新的提交，改正作者和提交者的错误信息。\ngit commit --amend --allow-empty --reset-author 参数 --amend 是对刚刚的提交进行修补，这样就可以改正前面错误的提交（用户信息错误），而不会产生另外的新提交。 参数 --allow-empty 是因为要进行修补的提交实际上是一个空白提交，Git 默认不允许空白提交。 参数 --reset-author 的含义是将 Author（提交者）的 ID 重置，否则只会影响最新的 Commit（提交者）的 ID。这条命令也会重置 AuthorDate 信息。 思考：随意设置提交者姓名，是否太不安全？ Git 可以随意设置提交的用户名和邮件地址信息，这是分布式版本控制系统的特性使然，每个人都是自己版本库的主人，很难也没有必要进行身份认证从而使用经过认证的用户名作为提交的用户名。\n但是可以使用 GitLab 等服务管理权限。\n思考：命令别名是干什么的？ 命令别名可以帮助用户解决从其他版本控制系统迁移到 Git 后的使用习惯问题。\n备份本章的工作成果 cd /path/to/my/workspace git clone demo demo-step-1 Cloning into demo-step-1... done. Git 暂存区 git log --stat 可以用 git log 查看提交日志，附加的 --stat 参数看到每次提交的文件变更统计。\n修改不能直接提交？ 现在就将修改的文件“添加”到提交暂存区：\ngit add welcome.txt 这时如果和 HEAD（当前版本库的头指针）或者 master 分支（当前工作分支）进行比较，会发现有差异。这个差异才是正常的，因为尚未真正提交么。\ngit diff HEAD 用简洁方式显示状态\ngit status -s M welcome.txt 通过参数 --cached 或者 --staged 参数调用 git diff 命令，看到的是提交暂存区 stage 和版本库中文件的差异。不然看到的是工作区的变动。\ngit diff --cached 现在执行 git commit 命令进行提交。\ngit commit -m \"which version checked in?\" 如何证明提交成功了呢？通过查看提交日志，看到了新的提交。\ngit log --pretty=oneline 理解 Git 暂存区 stage 当执行 git status 命令（或者 git diff 命令）扫描工作区改动的时候，先依据 .git/index 文件中记录的（工作区跟踪文件的）时间戳、长度等信息判断工作区文件是否改变。\n文件 .git/index 实际上就是一个包含文件索引的目录树，像是一个虚拟的工作区。在这个虚拟工作区的目录树中，记录了文件名、文件的状态信息（时间戳、文件长度等）。文件的内容并不存储其中，而是保存在 Git 对象库 .git/objects 目录中，文件索引建立了文件和对象库中对象实体之间的对应。\n图中可以看出此时 HEAD 实际是指向 master 分支的一个“游标”。所以图示的命令中出现 HEAD 的地方可以用 master 来替换。 图中的 objects 标识的区域为 Git 的对象库，实际位于 .git/objects 目录下，会在后面的章节重点介绍。 当执行 git reset HEAD 命令时，暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响。 当执行 git rm --cached 命令时，会直接从暂存区删除文件，工作区则不做出改变。 当执行 git checkout . 或者 git checkout -- 命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区的改动。 当执行 git checkout HEAD . 或者 git checkout HEAD 命令时，会用 HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。 Git diff 魔法 有什么办法能够像查看工作区一样的，直观的查看暂存区以及 HEAD 当中的目录树么？\ngit ls-tree -l HEAD 100644 blob fd3c069c1de4f4bc9b15940f490aeb48852f3c42 25 welcome.txt 要显示暂存区的目录树，可以使用 git ls-files 命令。\ngit ls-files -s 100644 18832d35117ef2f013c4009f5b2128dfaeff354f 0 a/b/c/hello.txt 不要使用 git commit -a 提交命令 git commit 可以带上 -a 参数，对本地所有变更的文件执行提交操作，包括本地修改的文件，删除的文件，但不包括未被版本库跟踪的文件。\n这个“偷懒”的提交命令，就会丢掉 Git 暂存区带给用户最大的好处：对提交内容进行控制的能力。\nGit 对象 什么是 HEAD？什么是 master？为什么它们二者可以相互替换使用？为什么 Git 中的很多对象像提交、树、文件内容等都用 40 位的 SHA1 哈希值来表示？\nGit 对象库探秘 40 位十六进制数字组成的 SHA1 哈希值\ngit log -1 --pretty=raw # 这是本次提交的唯一标识。 commit e695606fc5e31b2ff9038a48a3d363f4c21a3d86 # 这是本次提交所对应的目录树。 tree f58da9a820e3fd9d84ab2ca2f1b467ac265038f9 # 这是本地提交的父提交（上一次提交）。 parent a0c641e92b10d8bcca1ed1bf84ca80340fdefee6 which version checked in? 研究 Git 对象 ID 的命令是 git cat-file，用下面的命令可以查看一下这三个 ID 的类型。\ngit cat-file -t e695606 commit git cat-file -t f58d tree git cat-file -t fd3c06 blob 再用 git cat-file 命令查看一下这几个对象的内容。对于 blob 对象，这个对象保存着文件 welcome.txt 的内容。\ngit cat-file -p fd3c06 Hello. Nice to meet you. 这个写对象都存在 Git 库中的 objects 目录下，ID 的前两位作为目录名，后 38 位作为文件名。\nfor id in e695606 f58da9a a0c641e fd3c069; do \\ ls .git/objects/${id:0:2}/${id:2}*; done .git/objects/e6/95606fc5e31b2ff9038a48a3d363f4c21a3d86 .git/objects/f5/8da9a820e3fd9d84ab2ca2f1b467ac265038f9 .git/objects/a0/c641e92b10d8bcca1ed1bf84ca80340fdefee6 .git/objects/fd/3c069c1de4f4bc9b15940f490aeb48852f3c42 HEAD 和 master 的奥秘 git log -1 HEAD git log -1 master git log -1 refs/heads/master 在当前版本库中，HEAD、master 和 refs/heads/master 具有相同的指向。现在到版本库 .git 中一探它们的究竟：\nfind .git -name HEAD -o -name master .git/HEAD .git/logs/HEAD .git/logs/refs/heads/master .git/refs/heads/master 显示一下 .git/HEAD\ncat .git/HEAD ref: refs/heads/master 指向一个引用：refs/heads/master\ncat .git/refs/heads/master e695606fc5e31b2ff9038a48a3d363f4c21a3d86 显示该提交的内容\ngit cat-file -p e695606fc5e31b2ff9038a48a3d363f4c21a3d86 tree f58da9a820e3fd9d84ab2ca2f1b467ac265038f9 parent a0c641e92b10d8bcca1ed1bf84ca80340fdefee6 which version checked in? 原来分支 master 指向的是一个提交 ID（最新提交）。\n这样的分支实现是多么的巧妙啊：既然可以从任何提交开始建立一条历史跟踪链，那么用一个文件指向这个链条的最新提交，那么这个文件就可以用于追踪整个提交历史了。\n这个文件就是 .git/refs/heads/master 文件。\n目录 .git/refs 是保存引用的命名空间，其中 .git/refs/heads 目录下的引用又称为分支。对于分支既可以使用正规的长格式的表示法，如 refs/heads/master，也可以去掉前面的两级目录用 master 来表示。Git 有一个底层命令 git rev-parse 可以用于显示引用对应的提交 ID。\n问题：SHA1 哈希值到底是什么，如何生成的？ 哈希(hash)是一种数据摘要算法（或称散列算法），是信息安全领域当中重要的理论基石。该算法将任意长度的输入经过散列运算转换为固定长度的输出。固定长度的输出可以称为对应的输入的数字摘要或哈希值。\necho -n Git |sha1sum 5819778898df55e3a762f0c5728b457970d72cae - 提交的 SHA1 哈希值生成方法：\ngit cat-file commit HEAD | wc -c 234 # 在提交信息的前面加上内容 `commit 234`（``为空字符），然后执行 SHA1 哈希算法。 ( printf \"commit 234\\000\"; git cat-file commit HEAD ) | sha1sum e695606fc5e31b2ff9038a48a3d363f4c21a3d86 - # 上面命令得到的哈希值和用 `git rev-parse` 看到的是一样的。 git rev-parse HEAD e695606fc5e31b2ff9038a48a3d363f4c21a3d86 文件内容的 SHA1 哈希值生成方法：\n# 文件总共包含 25 字节的内容。 git cat-file blob HEAD:welcome.txt | wc -c 25 # 在文件内容的前面加上blob 25的内容，然后执行SHA1哈希算法。 ( printf \"blob 25\\000\"; git cat-file blob HEAD:welcome.txt ) | sha1sum fd3c069c1de4f4bc9b15940f490aeb48852f3c42 - # 上面命令得到的哈希值和用git rev-parse看到的是一样的。 git rev-parse HEAD:welcome.txt fd3c069c1de4f4bc9b15940f490aeb48852f3c42 树的 SHA1 哈希值的形成方法：\n# HEAD对应的树的内容共包含39个字节。 git cat-file tree HEAD^{tree} | wc -c 39 # 在树的内容的前面加上tree 39的内容，然后执行SHA1哈希算法。 ( printf \"tree 39\\000\"; git cat-file tree HEAD^{tree} ) | sha1sum f58da9a820e3fd9d84ab2ca2f1b467ac265038f9 - # 上面命令得到的哈希值和用git rev-parse看到的是一样的。 git rev-parse HEAD^{tree} f58da9a820e3fd9d84ab2ca2f1b467ac265038f9 问题：为什么不用顺序的数字来表示提交？ 集中式版本控制系统因为只有一个集中式的版本库，可以很容易的实现依次递增的全局唯一的提交号。Git 作为分布式版本控制系统，开发可以是非线性的。这就要求提交的编号不能仅仅是本地局部有效，而是要“全球唯一”。\n采用部分的 SHA1 哈希值。不必写全 40 位的哈希值，只采用开头的部分，不和现有其他的冲突即可。\n使用 master 代表分支 master 中最新的提交，使用全称 refs/heads/master 亦可。\n使用 HEAD 代表版本库中最近的一次提交。\n符号 ^ 可以用于指代父提交。例如：\nHEAD^ 代表版本库中上一次提交，即最近一次提交的父提交。 HEAD^^ 则代表 HEAD^ 的父提交。 对于一个提交有多个父提交，可以在符号 ^ 后面用数字表示是第几个父提交。例如：\na573106^2 含义是提交 a573106 的多个父提交中的第二个父提交。 HEAD^1 相当于 HEAD^ 含义是 HEAD 多个父提交中的第一个。 HEAD^^2 含义是 HEAD^（HEAD 父提交）的多个父提交中的第二个。 符号 ~ 也可以用于指代祖先提交。效果等同：\na573106~5 a573106^^^^^ 提交所对应的树对象：a573106^{tree}\n某一此提交对应的文件对象：a573106:path/to/file\n暂存区中的文件对象：:path/to/file\ngit rev-parse HEAD git cat-file -p e695 git cat-file -p e695^ git rev-parse e695^{tree} References 2. Git 独奏 — GotGit ","wordCount":"898","inLanguage":"en","datePublished":"2017-07-19T16:00:00Z","dateModified":"2017-07-19T16:00:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zyf.im/2017/07/19/got-git-reading-notes-solo-part1/"},"publisher":{"@type":"Organization","name":"ZYF.IM BLOG","logo":{"@type":"ImageObject","url":"https://zyf.im/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://zyf.im/ accesskey=h title="ZYF.IM (Alt + H)"><img src=https://zyf.im/apple-touch-icon.png alt aria-label=logo height=35>ZYF.IM</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://zyf.im/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://zyf.im/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://zyf.im/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://zyf.im/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://zyf.im/>Home</a>&nbsp;»&nbsp;<a href=https://zyf.im/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">【Git 权威指南】读书笔记 - 独奏 - Part 1</h1><div class=post-meta><span title='2017-07-19 16:00:00 +0000 UTC'>July 19, 2017</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;898 words&nbsp;·&nbsp;Me</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#git-初始化>Git 初始化</a><ul><li><a href=#设置一些-git-别名以便可以使用更为简洁的子命令>设置一些 Git 别名，以便可以使用更为简洁的子命令</a></li><li><a href=#版本库的初始化>版本库的初始化</a></li><li><a href=#思考为什么工作区下有一个-git-目录>思考：为什么工作区下有一个 <code>.git</code> 目录？</a></li><li><a href=#当工作区中包含了子目录在子目录中执行-git-命令时如何定位版本库呢>当工作区中包含了子目录，在子目录中执行 Git 命令时，如何定位版本库呢？</a></li><li><a href=#那么有什么办法知道-git-版本库的位置以及工作区的根目录在哪里呢>那么有什么办法知道 Git 版本库的位置，以及工作区的根目录在哪里呢？</a></li><li><a href=#把版本库-git-目录放在工作区是不是太不安全了>把版本库 <code>.git</code> 目录放在工作区，是不是太不安全了？</a></li><li><a href=#思考git-config-命令参数的区别>思考：<code>git config</code> 命令参数的区别？</a></li><li><a href=#思考是谁完成的提交>思考：是谁完成的提交？</a></li><li><a href=#思考随意设置提交者姓名是否太不安全>思考：随意设置提交者姓名，是否太不安全？</a></li><li><a href=#思考命令别名是干什么的>思考：命令别名是干什么的？</a></li><li><a href=#备份本章的工作成果>备份本章的工作成果</a></li></ul></li><li><a href=#git-暂存区>Git 暂存区</a><ul><li><a href=#修改不能直接提交>修改不能直接提交？</a></li><li><a href=#理解-git-暂存区-stage>理解 Git 暂存区 stage</a></li><li><a href=#git-diff-魔法>Git diff 魔法</a></li><li><a href=#不要使用-git-commit--a>不要使用 git commit -a</a></li></ul></li><li><a href=#git-对象>Git 对象</a><ul><li><a href=#git-对象库探秘>Git 对象库探秘</a></li><li><a href=#head-和-master-的奥秘>HEAD 和 master 的奥秘</a></li><li><a href=#问题sha1-哈希值到底是什么如何生成的>问题：SHA1 哈希值到底是什么，如何生成的？</a></li><li><a href=#问题为什么不用顺序的数字来表示提交>问题：为什么不用顺序的数字来表示提交？</a></li></ul></li><li><a href=#references>References</a></li></ul></nav></div></details></div><div class=post-content><p>主要内容：【Git 初始化】、【Git 暂存区】、【Git 对象】</p><h2 id=git-初始化>Git 初始化<a hidden class=anchor aria-hidden=true href=#git-初始化>#</a></h2><p>设置一下 Git 的环境变量，这个设置是一次性的工作。即这些设置会在全局文件（用户主目录下的 <code>~/.gitconfig</code>）或系统文件（<code>/etc/gitconfig</code>）中做永久的记录。</p><p>配置的用户名和邮件地址将在版本库提交时作为提交者的用户名和邮件地址。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git config --global user.name <span class=s2>&#34;Jiang Xin&#34;</span>
</span></span><span class=line><span class=cl>git config --global user.email jiangxin@ossxp.com
</span></span></code></pre></div><h3 id=设置一些-git-别名以便可以使用更为简洁的子命令>设置一些 Git 别名，以便可以使用更为简洁的子命令<a hidden class=anchor aria-hidden=true href=#设置一些-git-别名以便可以使用更为简洁的子命令>#</a></h3><p>只在本用户的全局配置中添加 Git 命令别名：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git config --global alias.br branch
</span></span><span class=line><span class=cl>git config --global alias.ci <span class=s2>&#34;commit -s&#34;</span>
</span></span><span class=line><span class=cl>git config --global alias.co checkout
</span></span><span class=line><span class=cl>git config --global alias.st <span class=s2>&#34;-p status&#34;</span>
</span></span></code></pre></div><h3 id=版本库的初始化>版本库的初始化<a hidden class=anchor aria-hidden=true href=#版本库的初始化>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>mkdir demo
</span></span><span class=line><span class=cl><span class=nb>cd</span> demo
</span></span><span class=line><span class=cl>git init
</span></span></code></pre></div><p>初始化空的 Git 版本库于 <code>/path/to/my/workspace/demo/.git/</code></p><p>git init 命令的后面直接输入目录名称</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nb>cd</span> /path/to/my/workspace
</span></span><span class=line><span class=cl>git init demo
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>ls -aF
</span></span><span class=line><span class=cl>./  ../  .git/
</span></span></code></pre></div><p>这个隐藏的 <code>.git</code> 目录就是 Git 版本库（又叫仓库，repository）。</p><p><code>.git</code> 版本库目录所在的目录，即 <code>/path/to/my/workspace/demo</code> 目录称为 <strong>工作区</strong>。</p><p>将新建立的文件添加到版本库</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git add welcome.txt
</span></span></code></pre></div><p>再执行一次提交操作，使用 <code>-m</code> 参数直接给出了提交说明。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git ci -m <span class=s2>&#34;initialized&#34;</span>
</span></span><span class=line><span class=cl><span class=o>[</span>master <span class=o>(</span>root-commit<span class=o>)</span> 7f0b2be<span class=o>]</span> init
</span></span><span class=line><span class=cl> <span class=m>1</span> file changed, <span class=m>0</span> insertions<span class=o>(</span>+<span class=o>)</span>, <span class=m>0</span> deletions<span class=o>(</span>-<span class=o>)</span>
</span></span><span class=line><span class=cl> create mode <span class=m>100644</span> welcome.txt
</span></span></code></pre></div><p><code>git ci</code> 是上面配置的别名，我个人觉得 <code>-s</code> 这个参数比较冗余。</p><h3 id=思考为什么工作区下有一个-git-目录>思考：为什么工作区下有一个 <code>.git</code> 目录？<a hidden class=anchor aria-hidden=true href=#思考为什么工作区下有一个-git-目录>#</a></h3><p>Git 的这种设计，将版本库放在工作区根目录下，所有的版本控制操作（除了和其他远程版本库之间的互操作）都在本地即可完成，不像 Subversion 只有寥寥无几的几个命令才能脱离网络执行。而且 Git 也没有 CVS 和 Subversion 的安全泄漏问题（只要保护好 .git 目录），也没有 Subversion 在本地文件搜索时出现搜索结果混乱的问题，甚至 Git 还提供了一条 <code>git grep</code> 命令来更好地搜索工作区的文件内容。</p><pre tabindex=0><code>git grep &#34;工作区文件内容搜索&#34;
</code></pre><h3 id=当工作区中包含了子目录在子目录中执行-git-命令时如何定位版本库呢>当工作区中包含了子目录，在子目录中执行 Git 命令时，如何定位版本库呢？<a hidden class=anchor aria-hidden=true href=#当工作区中包含了子目录在子目录中执行-git-命令时如何定位版本库呢>#</a></h3><p>当在 Git 工作区目录下执行操作的时候，会对目录依次向上递归查找 <code>.git</code> 目录，找到的 <code>.git</code> 目录就是工作区对应的版本库，<code>.git</code> 所在的目录就是工作区的根目录，文件 <code>.git/index</code> 记录了工作区文件的状态（实际上是 <strong>暂存区</strong> 的状态）。</p><p>如果跟踪一下执行 <code>git status</code> 命令时的磁盘访问，会看到沿目录依次向上递归的过程。</p><pre tabindex=0><code>strace -e &#39;trace=file&#39; git status
</code></pre><h3 id=那么有什么办法知道-git-版本库的位置以及工作区的根目录在哪里呢>那么有什么办法知道 Git 版本库的位置，以及工作区的根目录在哪里呢？<a hidden class=anchor aria-hidden=true href=#那么有什么办法知道-git-版本库的位置以及工作区的根目录在哪里呢>#</a></h3><p>显示版本库 <code>.git</code> 目录所在的位置。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git rev-parse --git-dir
</span></span><span class=line><span class=cl>/path/to/my/workspace/demo/.git
</span></span></code></pre></div><p>显示工作区根目录。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git rev-parse --show-toplevel
</span></span><span class=line><span class=cl>/path/to/my/workspace/demo
</span></span></code></pre></div><h3 id=把版本库-git-目录放在工作区是不是太不安全了>把版本库 <code>.git</code> 目录放在工作区，是不是太不安全了？<a hidden class=anchor aria-hidden=true href=#把版本库-git-目录放在工作区是不是太不安全了>#</a></h3><p>Git 克隆可以降低因为版本库和工作区混杂在一起导致的版本库被破坏的风险。在本机另外的磁盘/目录中建立 Git 克隆，并在工作区有改动提交时，手动或自动地执行向克隆版本库的推送 <code>git push</code> 操作。如果使用网络协议，还可以实现在其他机器上建立克隆，这样就更安全了（双机备份）。</p><h3 id=思考git-config-命令参数的区别>思考：<code>git config</code> 命令参数的区别？<a hidden class=anchor aria-hidden=true href=#思考git-config-命令参数的区别>#</a></h3><p>将打开 /path/to/my/workspace/demo/.git/config 文件进行编辑：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nb>cd</span> /path/to/my/workspace/demo/
</span></span><span class=line><span class=cl>git config -e
</span></span></code></pre></div><p>将打开 /home/jiangxin/.gitconfig（用户主目录下的 .gitconfig 文件）全局配置文件进行编辑：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git config -e --global
</span></span></code></pre></div><p>将打开 /etc/gitconfig 系统级配置文件进行编辑：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git config -e --system
</span></span></code></pre></div><p>Git 的三个配置文件分别是 <code>版本库级别的配置文件</code>、<code>全局配置文件</code>（用户主目录下）和 <code>系统级配置文件</code>（/etc 目录下）。</p><p>其中 <code>版本库级别配置文件</code> 的优先级最高，<code>全局配置文件</code> 其次，<code>系统级配置文件</code> 优先级最低。</p><p>Git 配置文件采用的是 INI 文件格式。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ini data-lang=ini><span class=line><span class=cl><span class=na>cat /path/to/my/workspace/demo/.git/config</span>
</span></span><span class=line><span class=cl><span class=k>[core]</span>
</span></span><span class=line><span class=cl>        <span class=na>repositoryformatversion</span> <span class=o>=</span> <span class=s>0
</span></span></span><span class=line><span class=cl><span class=s>        filemode = true
</span></span></span><span class=line><span class=cl><span class=s>        bare = false
</span></span></span><span class=line><span class=cl><span class=s>        logallrefupdates = true</span>
</span></span></code></pre></div><p>例如读取 <code>[core]</code> 小节的 <code>bare</code> 的属性值</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git config &lt;section&gt;.&lt;key&gt;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>git config core.bare
</span></span><span class=line><span class=cl><span class=nb>false</span>
</span></span></code></pre></div><p>更改或设置 INI 文件中某个属性</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git config &lt;section&gt;.&lt;key&gt; &lt;value&gt;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>git config a.b something
</span></span><span class=line><span class=cl>git config x.y.z others
</span></span></code></pre></div><p>打开 <code>.git/config</code> 文件</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=o>[</span>a<span class=o>]</span>
</span></span><span class=line><span class=cl>        <span class=nv>b</span> <span class=o>=</span> something
</span></span><span class=line><span class=cl><span class=o>[</span>x <span class=s2>&#34;y&#34;</span><span class=o>]</span>
</span></span><span class=line><span class=cl>        <span class=nv>z</span> <span class=o>=</span> others
</span></span></code></pre></div><p>可以用 <code>git config</code> 命令操作任何其他的 INI 文件</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nv>GIT_CONFIG</span><span class=o>=</span>test.ini git config a.b.c.d <span class=s2>&#34;hello, world&#34;</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nv>GIT_CONFIG</span><span class=o>=</span>test.ini git config a.b.c.d
</span></span><span class=line><span class=cl>hello, world
</span></span></code></pre></div><h3 id=思考是谁完成的提交>思考：是谁完成的提交？<a hidden class=anchor aria-hidden=true href=#思考是谁完成的提交>#</a></h3><p>当最新的提交删除了 <code>user.name</code> 和 <code>user.email</code>，提交时 Git 对提交者的用户名和邮件地址做了大胆的猜测，这个猜测可能是错的。</p><p>重新设置 <code>user.name</code> 和 <code>user.email</code>，然后执行下面的命令，重新修改最新的提交，改正作者和提交者的错误信息。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git commit --amend --allow-empty --reset-author
</span></span></code></pre></div><ul><li>参数 <code>--amend</code> 是对刚刚的提交进行修补，这样就可以改正前面错误的提交（用户信息错误），而不会产生另外的新提交。</li><li>参数 <code>--allow-empty</code> 是因为要进行修补的提交实际上是一个空白提交，Git 默认不允许空白提交。</li><li>参数 <code>--reset-author</code> 的含义是将 Author（提交者）的 ID 重置，否则只会影响最新的 Commit（提交者）的 ID。这条命令也会重置 AuthorDate 信息。</li></ul><h3 id=思考随意设置提交者姓名是否太不安全>思考：随意设置提交者姓名，是否太不安全？<a hidden class=anchor aria-hidden=true href=#思考随意设置提交者姓名是否太不安全>#</a></h3><p>Git 可以随意设置提交的用户名和邮件地址信息，这是分布式版本控制系统的特性使然，每个人都是自己版本库的主人，很难也没有必要进行身份认证从而使用经过认证的用户名作为提交的用户名。</p><p>但是可以使用 GitLab 等服务管理权限。</p><h3 id=思考命令别名是干什么的>思考：命令别名是干什么的？<a hidden class=anchor aria-hidden=true href=#思考命令别名是干什么的>#</a></h3><p>命令别名可以帮助用户解决从其他版本控制系统迁移到 Git 后的使用习惯问题。</p><h3 id=备份本章的工作成果>备份本章的工作成果<a hidden class=anchor aria-hidden=true href=#备份本章的工作成果>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nb>cd</span> /path/to/my/workspace
</span></span><span class=line><span class=cl>git clone demo demo-step-1
</span></span><span class=line><span class=cl>Cloning into demo-step-1...
</span></span><span class=line><span class=cl><span class=k>done</span>.
</span></span></code></pre></div><h2 id=git-暂存区>Git 暂存区<a hidden class=anchor aria-hidden=true href=#git-暂存区>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git log --stat
</span></span></code></pre></div><p>可以用 <code>git log</code> 查看提交日志，附加的 <code>--stat</code> 参数看到每次提交的文件变更统计。</p><h3 id=修改不能直接提交>修改不能直接提交？<a hidden class=anchor aria-hidden=true href=#修改不能直接提交>#</a></h3><p>现在就将修改的文件“添加”到提交暂存区：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git add welcome.txt
</span></span></code></pre></div><p>这时如果和 HEAD（当前版本库的头指针）或者 master 分支（当前工作分支）进行比较，会发现有差异。这个差异才是正常的，因为尚未真正提交么。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git diff HEAD
</span></span></code></pre></div><p>用简洁方式显示状态</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git status -s
</span></span><span class=line><span class=cl>M  welcome.txt
</span></span></code></pre></div><p>通过参数 <code>--cached</code> 或者 <code>--staged</code> 参数调用 git diff 命令，看到的是提交暂存区 <code>stage</code> 和版本库中文件的差异。不然看到的是工作区的变动。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git diff --cached
</span></span></code></pre></div><p>现在执行 git commit 命令进行提交。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git commit -m <span class=s2>&#34;which version checked in?&#34;</span>
</span></span></code></pre></div><p>如何证明提交成功了呢？通过查看提交日志，看到了新的提交。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git log --pretty<span class=o>=</span>oneline
</span></span></code></pre></div><h3 id=理解-git-暂存区-stage>理解 Git 暂存区 stage<a hidden class=anchor aria-hidden=true href=#理解-git-暂存区-stage>#</a></h3><p>当执行 <code>git status</code> 命令（或者 <code>git diff</code> 命令）扫描工作区改动的时候，先依据 <code>.git/index</code> 文件中记录的（工作区跟踪文件的）时间戳、长度等信息判断工作区文件是否改变。</p><p>文件 <code>.git/index</code> 实际上就是一个包含文件索引的目录树，像是一个虚拟的工作区。在这个虚拟工作区的目录树中，记录了文件名、文件的状态信息（时间戳、文件长度等）。文件的内容并不存储其中，而是保存在 Git 对象库 <code>.git/objects</code> 目录中，文件索引建立了文件和对象库中对象实体之间的对应。</p><p><img alt=got-git-reading-notes-solo-git-stage loading=lazy src=https://user-images.githubusercontent.com/9289792/80202431-33a64480-8658-11ea-8771-07b2bf81f657.png></p><ul><li>图中可以看出此时 HEAD 实际是指向 master 分支的一个“游标”。所以图示的命令中出现 HEAD 的地方可以用 master 来替换。</li><li>图中的 objects 标识的区域为 Git 的对象库，实际位于 <code>.git/objects</code> 目录下，会在后面的章节重点介绍。</li><li>当执行 <code>git reset HEAD</code> 命令时，暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响。</li><li>当执行 <code>git rm --cached &lt;file></code> 命令时，会直接从暂存区删除文件，工作区则不做出改变。</li><li>当执行 <code>git checkout .</code> 或者 <code>git checkout -- &lt;file></code> 命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区的改动。</li><li>当执行 <code>git checkout HEAD .</code> 或者 <code>git checkout HEAD &lt;file></code> 命令时，会用 HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。</li></ul><h3 id=git-diff-魔法>Git diff 魔法<a hidden class=anchor aria-hidden=true href=#git-diff-魔法>#</a></h3><p>有什么办法能够像查看工作区一样的，直观的查看暂存区以及 HEAD 当中的目录树么？</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git ls-tree -l HEAD
</span></span><span class=line><span class=cl><span class=m>100644</span> blob fd3c069c1de4f4bc9b15940f490aeb48852f3c42      <span class=m>25</span>    welcome.txt
</span></span></code></pre></div><p>要显示暂存区的目录树，可以使用 <code>git ls-files</code> 命令。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git ls-files -s
</span></span><span class=line><span class=cl><span class=m>100644</span> 18832d35117ef2f013c4009f5b2128dfaeff354f <span class=m>0</span>       a/b/c/hello.txt
</span></span></code></pre></div><p><img alt=got-git-reading-notes-solo-git-diff loading=lazy src=https://user-images.githubusercontent.com/9289792/80202327-06599680-8658-11ea-8329-93b424bc3726.png></p><h3 id=不要使用-git-commit--a>不要使用 git commit -a<a hidden class=anchor aria-hidden=true href=#不要使用-git-commit--a>#</a></h3><p>提交命令 <code>git commit</code> 可以带上 <code>-a</code> 参数，对本地所有变更的文件执行提交操作，包括本地修改的文件，删除的文件，但不包括未被版本库跟踪的文件。</p><p>这个“偷懒”的提交命令，就会丢掉 Git 暂存区带给用户最大的好处：对提交内容进行控制的能力。</p><h2 id=git-对象>Git 对象<a hidden class=anchor aria-hidden=true href=#git-对象>#</a></h2><p>什么是 <code>HEAD</code>？什么是 <code>master</code>？为什么它们二者可以相互替换使用？为什么 Git 中的很多对象像提交、树、文件内容等都用 40 位的 <code>SHA1</code> 哈希值来表示？</p><h3 id=git-对象库探秘>Git 对象库探秘<a hidden class=anchor aria-hidden=true href=#git-对象库探秘>#</a></h3><p>40 位十六进制数字组成的 <code>SHA1</code> 哈希值</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git log -1 --pretty<span class=o>=</span>raw
</span></span><span class=line><span class=cl><span class=c1># 这是本次提交的唯一标识。</span>
</span></span><span class=line><span class=cl>commit e695606fc5e31b2ff9038a48a3d363f4c21a3d86
</span></span><span class=line><span class=cl><span class=c1># 这是本次提交所对应的目录树。</span>
</span></span><span class=line><span class=cl>tree f58da9a820e3fd9d84ab2ca2f1b467ac265038f9
</span></span><span class=line><span class=cl><span class=c1># 这是本地提交的父提交（上一次提交）。</span>
</span></span><span class=line><span class=cl>parent a0c641e92b10d8bcca1ed1bf84ca80340fdefee6
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    which version checked in?
</span></span></code></pre></div><p>研究 Git 对象 ID 的命令是 <code>git cat-file</code>，用下面的命令可以查看一下这三个 ID 的类型。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git cat-file -t e695606
</span></span><span class=line><span class=cl>commit
</span></span><span class=line><span class=cl>git cat-file -t f58d
</span></span><span class=line><span class=cl>tree
</span></span><span class=line><span class=cl>git cat-file -t fd3c06
</span></span><span class=line><span class=cl>blob
</span></span></code></pre></div><p>再用 <code>git cat-file</code> 命令查看一下这几个对象的内容。对于 <code>blob</code> 对象，这个对象保存着文件 welcome.txt 的内容。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git cat-file -p fd3c06
</span></span><span class=line><span class=cl>Hello.
</span></span><span class=line><span class=cl>Nice to meet you.
</span></span></code></pre></div><p>这个写对象都存在 Git 库中的 <code>objects</code> 目录下，ID 的前两位作为目录名，后 38 位作为文件名。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=k>for</span> id in e695606 f58da9a a0c641e fd3c069<span class=p>;</span> <span class=k>do</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  ls .git/objects/<span class=si>${</span><span class=nv>id</span><span class=p>:</span><span class=nv>0</span><span class=p>:</span><span class=nv>2</span><span class=si>}</span>/<span class=si>${</span><span class=nv>id</span><span class=p>:</span><span class=nv>2</span><span class=si>}</span>*<span class=p>;</span> <span class=k>done</span>
</span></span><span class=line><span class=cl>.git/objects/e6/95606fc5e31b2ff9038a48a3d363f4c21a3d86
</span></span><span class=line><span class=cl>.git/objects/f5/8da9a820e3fd9d84ab2ca2f1b467ac265038f9
</span></span><span class=line><span class=cl>.git/objects/a0/c641e92b10d8bcca1ed1bf84ca80340fdefee6
</span></span><span class=line><span class=cl>.git/objects/fd/3c069c1de4f4bc9b15940f490aeb48852f3c42
</span></span></code></pre></div><p><img alt=got-git-reading-notes-solo-git-objects loading=lazy src=https://user-images.githubusercontent.com/9289792/80202330-08235a00-8658-11ea-9040-b280b00b7e43.png></p><h3 id=head-和-master-的奥秘>HEAD 和 master 的奥秘<a hidden class=anchor aria-hidden=true href=#head-和-master-的奥秘>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git log -1 HEAD
</span></span><span class=line><span class=cl>git log -1 master
</span></span><span class=line><span class=cl>git log -1 refs/heads/master
</span></span></code></pre></div><p>在当前版本库中，<code>HEAD</code>、<code>master</code> 和 <code>refs/heads/master</code> 具有相同的指向。现在到版本库 <code>.git</code> 中一探它们的究竟：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>find .git -name HEAD -o -name master
</span></span><span class=line><span class=cl>.git/HEAD
</span></span><span class=line><span class=cl>.git/logs/HEAD
</span></span><span class=line><span class=cl>.git/logs/refs/heads/master
</span></span><span class=line><span class=cl>.git/refs/heads/master
</span></span></code></pre></div><p>显示一下 <code>.git/HEAD</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>cat .git/HEAD
</span></span><span class=line><span class=cl>ref: refs/heads/master
</span></span></code></pre></div><p>指向一个引用：<code>refs/heads/master</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>cat .git/refs/heads/master
</span></span><span class=line><span class=cl>e695606fc5e31b2ff9038a48a3d363f4c21a3d86
</span></span></code></pre></div><p>显示该提交的内容</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git cat-file -p e695606fc5e31b2ff9038a48a3d363f4c21a3d86
</span></span><span class=line><span class=cl>tree f58da9a820e3fd9d84ab2ca2f1b467ac265038f9
</span></span><span class=line><span class=cl>parent a0c641e92b10d8bcca1ed1bf84ca80340fdefee6
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>which version checked in?
</span></span></code></pre></div><p>原来分支 <code>master</code> 指向的是一个提交 ID（最新提交）。</p><p>这样的分支实现是多么的巧妙啊：既然可以从任何提交开始建立一条历史跟踪链，那么用一个文件指向这个链条的最新提交，那么这个文件就可以用于追踪整个提交历史了。</p><p>这个文件就是 <code>.git/refs/heads/master</code> 文件。</p><p><img alt=got-git-reading-notes-solo-git-repos-detail loading=lazy src=https://user-images.githubusercontent.com/9289792/80202610-78ca7680-8658-11ea-9b85-651555b8f005.png></p><p>目录 <code>.git/refs</code> 是保存引用的命名空间，其中 <code>.git/refs/heads</code> 目录下的引用又称为分支。对于分支既可以使用正规的长格式的表示法，如 <code>refs/heads/master</code>，也可以去掉前面的两级目录用 <code>master</code> 来表示。Git 有一个底层命令 <code>git rev-parse</code> 可以用于显示引用对应的提交 ID。</p><h3 id=问题sha1-哈希值到底是什么如何生成的>问题：SHA1 哈希值到底是什么，如何生成的？<a hidden class=anchor aria-hidden=true href=#问题sha1-哈希值到底是什么如何生成的>#</a></h3><p>哈希(hash)是一种数据摘要算法（或称散列算法），是信息安全领域当中重要的理论基石。该算法将任意长度的输入经过散列运算转换为固定长度的输出。固定长度的输出可以称为对应的输入的数字摘要或哈希值。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nb>echo</span> -n Git <span class=p>|</span>sha1sum
</span></span><span class=line><span class=cl>5819778898df55e3a762f0c5728b457970d72cae  -
</span></span></code></pre></div><p>提交的 SHA1 哈希值生成方法：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git cat-file commit HEAD <span class=p>|</span> wc -c
</span></span><span class=line><span class=cl><span class=m>234</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 在提交信息的前面加上内容 `commit 234&lt;null&gt;`（`&lt;null&gt;`为空字符），然后执行 SHA1 哈希算法。</span>
</span></span><span class=line><span class=cl><span class=o>(</span> <span class=nb>printf</span> <span class=s2>&#34;commit 234\000&#34;</span><span class=p>;</span> git cat-file commit HEAD <span class=o>)</span> <span class=p>|</span> sha1sum
</span></span><span class=line><span class=cl>e695606fc5e31b2ff9038a48a3d363f4c21a3d86  -
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 上面命令得到的哈希值和用 `git rev-parse` 看到的是一样的。</span>
</span></span><span class=line><span class=cl>git rev-parse HEAD
</span></span><span class=line><span class=cl>e695606fc5e31b2ff9038a48a3d363f4c21a3d86
</span></span></code></pre></div><p>文件内容的 SHA1 哈希值生成方法：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 文件总共包含 25 字节的内容。</span>
</span></span><span class=line><span class=cl>git cat-file blob HEAD:welcome.txt <span class=p>|</span> wc -c
</span></span><span class=line><span class=cl><span class=m>25</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 在文件内容的前面加上blob 25&lt;null&gt;的内容，然后执行SHA1哈希算法。</span>
</span></span><span class=line><span class=cl><span class=o>(</span> <span class=nb>printf</span> <span class=s2>&#34;blob 25\000&#34;</span><span class=p>;</span> git cat-file blob HEAD:welcome.txt <span class=o>)</span> <span class=p>|</span> sha1sum
</span></span><span class=line><span class=cl>fd3c069c1de4f4bc9b15940f490aeb48852f3c42  -
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 上面命令得到的哈希值和用git rev-parse看到的是一样的。</span>
</span></span><span class=line><span class=cl>git rev-parse HEAD:welcome.txt
</span></span><span class=line><span class=cl>fd3c069c1de4f4bc9b15940f490aeb48852f3c42
</span></span></code></pre></div><p>树的 SHA1 哈希值的形成方法：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># HEAD对应的树的内容共包含39个字节。</span>
</span></span><span class=line><span class=cl>git cat-file tree HEAD^<span class=o>{</span>tree<span class=o>}</span> <span class=p>|</span> wc -c
</span></span><span class=line><span class=cl><span class=m>39</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 在树的内容的前面加上tree 39&lt;null&gt;的内容，然后执行SHA1哈希算法。</span>
</span></span><span class=line><span class=cl><span class=o>(</span> <span class=nb>printf</span> <span class=s2>&#34;tree 39\000&#34;</span><span class=p>;</span> git cat-file tree HEAD^<span class=o>{</span>tree<span class=o>}</span> <span class=o>)</span> <span class=p>|</span> sha1sum
</span></span><span class=line><span class=cl>f58da9a820e3fd9d84ab2ca2f1b467ac265038f9  -
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 上面命令得到的哈希值和用git rev-parse看到的是一样的。</span>
</span></span><span class=line><span class=cl>git rev-parse HEAD^<span class=o>{</span>tree<span class=o>}</span>
</span></span><span class=line><span class=cl>f58da9a820e3fd9d84ab2ca2f1b467ac265038f9
</span></span></code></pre></div><h3 id=问题为什么不用顺序的数字来表示提交>问题：为什么不用顺序的数字来表示提交？<a hidden class=anchor aria-hidden=true href=#问题为什么不用顺序的数字来表示提交>#</a></h3><p>集中式版本控制系统因为只有一个集中式的版本库，可以很容易的实现依次递增的全局唯一的提交号。Git 作为分布式版本控制系统，开发可以是非线性的。这就要求提交的编号不能仅仅是本地局部有效，而是要“全球唯一”。</p><p>采用部分的 SHA1 哈希值。不必写全 40 位的哈希值，只采用开头的部分，不和现有其他的冲突即可。</p><p>使用 <code>master</code> 代表分支 <code>master</code> 中最新的提交，使用全称 <code>refs/heads/master</code> 亦可。</p><p>使用 <code>HEAD</code> 代表版本库中最近的一次提交。</p><p>符号 <code>^</code> 可以用于指代父提交。例如：</p><ul><li><code>HEAD^</code> 代表版本库中上一次提交，即最近一次提交的父提交。</li><li><code>HEAD^^</code> 则代表 <code>HEAD^</code> 的父提交。</li></ul><p>对于一个提交有多个父提交，可以在符号 <code>^</code> 后面用数字表示是第几个父提交。例如：</p><ul><li><code>a573106^2</code> 含义是提交 <code>a573106</code> 的多个父提交中的第二个父提交。</li><li><code>HEAD^1</code> 相当于 <code>HEAD^</code> 含义是 HEAD 多个父提交中的第一个。</li><li><code>HEAD^^2</code> 含义是 <code>HEAD^</code>（HEAD 父提交）的多个父提交中的第二个。</li></ul><p>符号 <code>~&lt;n></code> 也可以用于指代祖先提交。效果等同：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>a573106~5
</span></span><span class=line><span class=cl>a573106^^^^^
</span></span></code></pre></div><p>提交所对应的树对象：<code>a573106^{tree}</code></p><p>某一此提交对应的文件对象：<code>a573106:path/to/file</code></p><p>暂存区中的文件对象：<code>:path/to/file</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git rev-parse HEAD
</span></span><span class=line><span class=cl>git cat-file -p e695
</span></span><span class=line><span class=cl>git cat-file -p e695^
</span></span><span class=line><span class=cl>git rev-parse e695^<span class=o>{</span>tree<span class=o>}</span>
</span></span></code></pre></div><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><ul><li><a href=http://www.worldhello.net/gotgit/02-git-solo/index.html>2. Git 独奏 — GotGit</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://zyf.im/tags/git/>Git</a></li></ul><nav class=paginav><a class=prev href=https://zyf.im/2017/07/20/got-git-reading-notes-solo-part2/><span class=title>« Prev</span><br><span>【Git 权威指南】读书笔记 - 独奏 - Part 2</span>
</a><a class=next href=https://zyf.im/2017/07/12/got-git-reading-notes-meet-git/><span class=title>Next »</span><br><span>【Git 权威指南】读书笔记 - 初识 Git</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://zyf.im/>ZYF.IM BLOG</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>