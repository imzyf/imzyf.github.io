<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>MySQL 5.6 5.7 组内排序的区别 | ZYF.IM BLOG</title>
<meta name=keywords content="mysql"><meta name=description content="MySQL 5.7 对比 5.6 有很多的变化。一个常见的需求：按条件分组后，取出每组中某字段最大值的那条记录。其实就是组内排序的问题，我的做法是：子查询先进行倒序排序，外层查询分组。
示例
+----+----+-------+
| id | no | name |
+----+----+-------+
| 5 | 5 | Mike |
| 4 | 4 | Herry |
| 3 | 3 | wyett |
| 2 | 2 | John |
| 7 | 2 | John |
| 1 | 1 | Mike |
| 6 | 1 | John |
| 8 | 1 | Mike |
| 9 | 1 | Mike |
+----+----+-------+
要求：取出每人（按 name），最大 no 的记录。"><meta name=author content="Me"><link rel=canonical href=https://zyf.im/2017/04/20/mysql-group-by-and-order-by-difference-between-56-57/><link crossorigin=anonymous href=/assets/css/stylesheet.eb010ba19da259e1633d31a246087e3b0656d556c30406763ea24160333d238f.css integrity="sha256-6wELoZ2iWeFjPTGiRgh+OwZW1VbDBAZ2PqJBYDM9I48=" rel="preload stylesheet" as=style><link rel=icon href=https://zyf.im/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zyf.im/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://zyf.im/favicon-32x32.png><link rel=apple-touch-icon href=https://zyf.im/apple-touch-icon.png><link rel=mask-icon href=https://zyf.im/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://zyf.im/2017/04/20/mysql-group-by-and-order-by-difference-between-56-57/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-6DVZ6E58DG"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-6DVZ6E58DG")}</script><meta property="og:url" content="https://zyf.im/2017/04/20/mysql-group-by-and-order-by-difference-between-56-57/"><meta property="og:site_name" content="ZYF.IM BLOG"><meta property="og:title" content="MySQL 5.6 5.7 组内排序的区别"><meta property="og:description" content="MySQL 5.7 对比 5.6 有很多的变化。一个常见的需求：按条件分组后，取出每组中某字段最大值的那条记录。其实就是组内排序的问题，我的做法是：子查询先进行倒序排序，外层查询分组。
示例 +----+----+-------+ | id | no | name | +----+----+-------+ | 5 | 5 | Mike | | 4 | 4 | Herry | | 3 | 3 | wyett | | 2 | 2 | John | | 7 | 2 | John | | 1 | 1 | Mike | | 6 | 1 | John | | 8 | 1 | Mike | | 9 | 1 | Mike | +----+----+-------+ 要求：取出每人（按 name），最大 no 的记录。"><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2017-04-20T20:00:00+00:00"><meta property="article:modified_time" content="2017-04-20T20:00:00+00:00"><meta property="article:tag" content="Mysql"><meta name=twitter:card content="summary"><meta name=twitter:title content="MySQL 5.6 5.7 组内排序的区别"><meta name=twitter:description content="MySQL 5.7 对比 5.6 有很多的变化。一个常见的需求：按条件分组后，取出每组中某字段最大值的那条记录。其实就是组内排序的问题，我的做法是：子查询先进行倒序排序，外层查询分组。
示例
+----+----+-------+
| id | no | name |
+----+----+-------+
| 5 | 5 | Mike |
| 4 | 4 | Herry |
| 3 | 3 | wyett |
| 2 | 2 | John |
| 7 | 2 | John |
| 1 | 1 | Mike |
| 6 | 1 | John |
| 8 | 1 | Mike |
| 9 | 1 | Mike |
+----+----+-------+
要求：取出每人（按 name），最大 no 的记录。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zyf.im/posts/"},{"@type":"ListItem","position":2,"name":"MySQL 5.6 5.7 组内排序的区别","item":"https://zyf.im/2017/04/20/mysql-group-by-and-order-by-difference-between-56-57/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"MySQL 5.6 5.7 组内排序的区别","name":"MySQL 5.6 5.7 组内排序的区别","description":"MySQL 5.7 对比 5.6 有很多的变化。一个常见的需求：按条件分组后，取出每组中某字段最大值的那条记录。其实就是组内排序的问题，我的做法是：子查询先进行倒序排序，外层查询分组。\n示例 +----+----+-------+ | id | no | name | +----+----+-------+ | 5 | 5 | Mike | | 4 | 4 | Herry | | 3 | 3 | wyett | | 2 | 2 | John | | 7 | 2 | John | | 1 | 1 | Mike | | 6 | 1 | John | | 8 | 1 | Mike | | 9 | 1 | Mike | +----+----+-------+ 要求：取出每人（按 name），最大 no 的记录。\n","keywords":["mysql"],"articleBody":"MySQL 5.7 对比 5.6 有很多的变化。一个常见的需求：按条件分组后，取出每组中某字段最大值的那条记录。其实就是组内排序的问题，我的做法是：子查询先进行倒序排序，外层查询分组。\n示例 +----+----+-------+ | id | no | name | +----+----+-------+ | 5 | 5 | Mike | | 4 | 4 | Herry | | 3 | 3 | wyett | | 2 | 2 | John | | 7 | 2 | John | | 1 | 1 | Mike | | 6 | 1 | John | | 8 | 1 | Mike | | 9 | 1 | Mike | +----+----+-------+ 要求：取出每人（按 name），最大 no 的记录。\nselect * from ( select id,no,name from testorder order by no desc )a group by a.name; +----+----+-------+ | id | no | name | +----+----+-------+ | 4 | 4 | Herry | | 2 | 2 | John | | 5 | 5 | Mike | | 3 | 3 | wyett | +----+----+-------+ 但是在 5.7 中，首先需要关闭 ql_mode = ONLY_FULL_GROUP_BY；相同的 name 值，返回则是取了 最早写入的数据行 ，忽略了 order by no desc，按照数据的逻辑存储顺序来返回\n+----+----+-------+ | id | no | name | +----+----+-------+ | 4 | 4 | Herry | | 2 | 2 | John | | 1 | 1 | Mike | | 3 | 3 | wyett | +----+----+-------+ 等价于\nselect id,no,name from testorder group by name A query such as\nSELECT field1, field2 FROM ( SELECT field1, field2 FROM table1 ORDER BY field2 ) alias returns a result set that is not necessarily ordered by field2. This is not a bug. A “table” (and subquery in the FROM clause too) is - according to the SQL standard - an unordered set of rows. Rows in a table (or in a subquery in the FROM clause) do not come in any specific order.\n可以总结为：\n在 FROM 后的 subquery 中的 ORDER BY 会被忽略 GROUP BY cloumn 返回的行是无序的 解决方案 select a.id,a.no,a.name from testorder a inner join ( select max(no) no,name from testorder group by name ) b on a.no = b.no and a.name = b.name group by name,no 其他方案：\n对于不符合 ONLY_FULL_GROUP_BY 限制的字段，添加 unique 索引。 使用 ANY_VALUE()，让 MySQL 跳过 ONLY_FULL_GROUP_BY 检测。 小结 MySQL 5.6 Handling of GROUP BY\nIn standard SQL, a query that includes a GROUP BY clause cannot refer to nonaggregated columns in the select list that are not named in the GROUP BY clause.\n在标准 SQL 中，包含 GROUP BY 子句的查询 不能引用 select 列表中未在 GROUP BY 子句中命名的列。\nMySQL extends the standard SQL use of GROUP BY so that the select list can refer to nonaggregated columns not named in the GROUP BY clause. This means that the preceding query is legal in MySQL.\nMySQL 扩展了 GROUP BY 的标准 SQL 使用，以便选择列表可以引用 GROUP BY 子句中未命名的非集合列。这意味着前面的查询在 MySQL 中是合法的。\nHowever, this is useful primarily when all values in each nonaggregated column not named in the GROUP BY are the same for each group. The server is free to choose any value from each group, so unless they are the same, the values chosen are indeterminate.\n但是，主要是在 GROUP BY 中 未命名的每个非分组列中的所有值对于每个组是相同的，这是有用的。服务器可以自由选择每个组中的任何值，因此除非它们相同，所选择的值是 不确定的。\nFurthermore, the selection of values from each group cannot be influenced by adding an ORDER BY clause. Result set sorting occurs after values have been chosen, and ORDER BY does not affect which values within each group the server chooses.\n此外，通过添加 ORDER BY 子句不会影响来自每个组的值的选择。结果集排序发生在选择值后，ORDER BY 不影响 服务选择的每个组中的哪些值。\nMySQL 5.7 Handling of GROUP BY\nMySQL 5.7.5 and up implements detection of functional dependence. If the ONLY_FULL_GROUP_BY SQL mode is enabled (which it is by default), MySQL rejects queries for which the select list, HAVING condition, or ORDER BY list refer to nonaggregated columns that are neither named in the GROUP BY clause nor are functionally dependent on them. (Before 5.7.5, MySQL does not detect functional dependency and ONLY_FULL_GROUP_BY is not enabled by default.)\nMySQL 5.7.5 及以上功能依赖检测功能。如果启用了 ONLY_FULL_GROUP_BY SQL 模式（默认情况下），MySQL 将拒绝对列表，HAVING 条件或 ORDER BY 列表的查询引用在 GROUP BY 子句中既未命名的非集合列，也不在功能上依赖于它们。（5.7.5 之前，MySQL 没有检测到功能依赖关系，默认情况下不启用 ONLY_FULL_GROUP_BY）\nYou can achieve the same effect without disabling ONLY_FULL_GROUP_BY by using ANY_VALUE() to refer to the nonaggregated column.\n你可以通过使用 ANY_VALUE() 使禁用了 ONLY_FULL_GROUP_BY 的 SQL，来实现相同的效果来引用非聚合列。\n5.6 与 5.7 的区别 5.6 升级到 5.7 版本要注意：\nsql_mode 默认值的改变。 optimizer_switch 值的改变。 备库升级影响主备复制。 SELECT @@SQL_MODE, @@GLOBAL.SQL_MODE; -- 5.6 -- NO_ENGINE_SUBSTITUTION -- 5.7 -- ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION ONLY_FULL_GROUP_BY SELECT 查询的字段必须是 GROUP BY 中出现的或者使用聚合函数的或者是具有唯一索引的。 STRICT_TRANS_TABLES 在该模式下，如果一个值不能插入到一个事务表中，则中断当前的操作，对非事务表不做任何限制。 NO_ZERO_IN_DATE 在严格模式，不接受月或日部分为 0 的日期。如果使用 IGNORE 选项，我们为类似的日期插入'0000-00-00’。在非严格模式，可以接受该日期，但会生成警告。 NO_ZERO_DATE 在严格模式，不要将 ‘0000-00-00’做为合法日期。你仍然可以用 IGNORE 选项插入零日期。在非严格模式，可以接受该日期，但会生成警告。 ERROR_FOR_DIVISION_BY_ZERO 在严格模式，在 INSERT 或 UPDATE 过程中，如果被零除(或 MOD(X，0))，则产生错误(否则为警告)。如果未给出该模式，被零除时 MySQL 返回 NULL。如果用到 INSERT IGNORE 或 UPDATE IGNORE 中，MySQL 生成被零除警告，但操作结果为 NULL。 NO_AUTO_CREATE_USER 防止 GRANT 自动创建新用户，除非还指定了密码。 NO_ENGINE_SUBSTITUTION 如果需要的存储引擎被禁用或未编译，那么抛出错误。不设置此值时，用默认的存储引擎替代，并抛出一个异常。 STRICT_TRANS_TABLES 和 STRICT_ALL_TABLES 的区别 唯一的区别是：对于不支持事务的表，若开启 STRICT_TRANS_TABLES，MySQL 会尝试将一个不合法的字段值转换成一个值最近的合法值插入表中；而开启 STRICT_ALL_TABLES 后，则表现为不写入数据，且抛出错误。\n因为现在绝大部分用的 InnoDB 引擎，是支持事务的，所以基本不用关心这种区别。\n严格模式和非严格模式的区别 SET sql_mode = 'STRICT_TRANS_TABLES'; 严格模式下不能在无符号整数字段插入负值。\n非严格模式下，会存储为 0。 严格模式下，报错。 严格模式下，无默认值的 NOT NULL 字段在插入数据时必须指定值。\n非严格模式下，若不插入数据会存储字段类型的默认值。 严格模式下，报错。 严格模式下，插入字符串不能超出定义长度\n非严格模式下，会成功插入数据，但是内容被截断。 严格模式下，报错。 References MySQL 组内排序取最大值 | mysqlwyett sql - MySQL Group By and Order By; - Stack Overflow MySQL5.7 中的 sql_mode 默认值 | zhihu MySQL: 严格模式 | letianbiji – EOF –\n","wordCount":"765","inLanguage":"en","datePublished":"2017-04-20T20:00:00Z","dateModified":"2017-04-20T20:00:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zyf.im/2017/04/20/mysql-group-by-and-order-by-difference-between-56-57/"},"publisher":{"@type":"Organization","name":"ZYF.IM BLOG","logo":{"@type":"ImageObject","url":"https://zyf.im/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://zyf.im/ accesskey=h title="ZYF.IM (Alt + H)"><img src=https://zyf.im/apple-touch-icon.png alt aria-label=logo height=35>ZYF.IM</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://zyf.im/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://zyf.im/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://zyf.im/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://zyf.im/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://zyf.im/>Home</a>&nbsp;»&nbsp;<a href=https://zyf.im/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">MySQL 5.6 5.7 组内排序的区别</h1><div class=post-meta><span title='2017-04-20 20:00:00 +0000 UTC'>April 20, 2017</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;765 words&nbsp;·&nbsp;Me</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#示例>示例</a></li><li><a href=#解决方案>解决方案</a></li><li><a href=#小结>小结</a></li><li><a href=#56-与-57-的区别>5.6 与 5.7 的区别</a><ul><li><a href=#strict_trans_tables-和-strict_all_tables-的区别>STRICT_TRANS_TABLES 和 STRICT_ALL_TABLES 的区别</a></li><li><a href=#严格模式和非严格模式的区别>严格模式和非严格模式的区别</a></li></ul></li><li><a href=#references>References</a></li></ul></nav></div></details></div><div class=post-content><p>MySQL 5.7 对比 5.6 有很多的变化。一个常见的需求：按条件分组后，取出每组中某字段最大值的那条记录。其实就是组内排序的问题，我的做法是：子查询先进行倒序排序，外层查询分组。</p><h2 id=示例>示例<a hidden class=anchor aria-hidden=true href=#示例>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-md data-lang=md><span class=line><span class=cl>+----+----+-------+
</span></span><span class=line><span class=cl>| id | no | name |
</span></span><span class=line><span class=cl>+----+----+-------+
</span></span><span class=line><span class=cl>| 5 | 5 | Mike |
</span></span><span class=line><span class=cl>| 4 | 4 | Herry |
</span></span><span class=line><span class=cl>| 3 | 3 | wyett |
</span></span><span class=line><span class=cl>| 2 | 2 | John |
</span></span><span class=line><span class=cl>| 7 | 2 | John |
</span></span><span class=line><span class=cl>| 1 | 1 | Mike |
</span></span><span class=line><span class=cl>| 6 | 1 | John |
</span></span><span class=line><span class=cl>| 8 | 1 | Mike |
</span></span><span class=line><span class=cl>| 9 | 1 | Mike |
</span></span><span class=line><span class=cl>+----+----+-------+
</span></span></code></pre></div><p>要求：取出每人（按 name），最大 no 的记录。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>select</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>select</span><span class=w> </span><span class=n>id</span><span class=p>,</span><span class=k>no</span><span class=p>,</span><span class=n>name</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>testorder</span><span class=w> </span><span class=k>order</span><span class=w> </span><span class=k>by</span><span class=w> </span><span class=k>no</span><span class=w> </span><span class=k>desc</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>)</span><span class=n>a</span><span class=w> </span><span class=k>group</span><span class=w> </span><span class=k>by</span><span class=w> </span><span class=n>a</span><span class=p>.</span><span class=n>name</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-md data-lang=md><span class=line><span class=cl>+----+----+-------+
</span></span><span class=line><span class=cl>| id | no | name |
</span></span><span class=line><span class=cl>+----+----+-------+
</span></span><span class=line><span class=cl>| 4 | 4 | Herry |
</span></span><span class=line><span class=cl>| 2 | 2 | John |
</span></span><span class=line><span class=cl>| 5 | 5 | Mike |
</span></span><span class=line><span class=cl>| 3 | 3 | wyett |
</span></span><span class=line><span class=cl>+----+----+-------+
</span></span></code></pre></div><p>但是在 5.7 中，首先需要关闭 <code>ql_mode = ONLY_FULL_GROUP_BY</code>；相同的 <code>name</code> 值，返回则是取了 <strong>最早写入的数据行</strong> ，<strong>忽略了 <code>order by no desc</code>，按照数据的逻辑存储顺序来返回</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-md data-lang=md><span class=line><span class=cl>+----+----+-------+
</span></span><span class=line><span class=cl>| id | no | name |
</span></span><span class=line><span class=cl>+----+----+-------+
</span></span><span class=line><span class=cl>| 4 | 4 | Herry |
</span></span><span class=line><span class=cl>| 2 | 2 | John |
</span></span><span class=line><span class=cl>| 1 | 1 | Mike |
</span></span><span class=line><span class=cl>| 3 | 3 | wyett |
</span></span><span class=line><span class=cl>+----+----+-------+
</span></span></code></pre></div><p>等价于</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>select</span><span class=w> </span><span class=n>id</span><span class=p>,</span><span class=k>no</span><span class=p>,</span><span class=n>name</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>testorder</span><span class=w> </span><span class=k>group</span><span class=w> </span><span class=k>by</span><span class=w> </span><span class=n>name</span><span class=w>
</span></span></span></code></pre></div><p>A query such as</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=n>field1</span><span class=p>,</span><span class=w> </span><span class=n>field2</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=p>(</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=n>field1</span><span class=p>,</span><span class=w> </span><span class=n>field2</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>table1</span><span class=w> </span><span class=k>ORDER</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>field2</span><span class=w> </span><span class=p>)</span><span class=w> </span><span class=k>alias</span><span class=w>
</span></span></span></code></pre></div><p>returns a result set that is not necessarily ordered by field2. This is not a bug.
A &ldquo;table&rdquo; (and subquery in the FROM clause too) is - according to the SQL standard - an unordered set of rows.
Rows in a table (or in a subquery in the FROM clause) do not come in any specific order.</p><p>可以总结为：</p><ul><li>在 FROM 后的 subquery 中的 ORDER BY 会被忽略</li><li>GROUP BY cloumn 返回的行是无序的</li></ul><h2 id=解决方案>解决方案<a hidden class=anchor aria-hidden=true href=#解决方案>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>select</span><span class=w> </span><span class=n>a</span><span class=p>.</span><span class=n>id</span><span class=p>,</span><span class=n>a</span><span class=p>.</span><span class=k>no</span><span class=p>,</span><span class=n>a</span><span class=p>.</span><span class=n>name</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>from</span><span class=w> </span><span class=n>testorder</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=k>inner</span><span class=w> </span><span class=k>join</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>select</span><span class=w> </span><span class=k>max</span><span class=p>(</span><span class=k>no</span><span class=p>)</span><span class=w> </span><span class=k>no</span><span class=p>,</span><span class=n>name</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>testorder</span><span class=w> </span><span class=k>group</span><span class=w> </span><span class=k>by</span><span class=w> </span><span class=n>name</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>)</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=k>on</span><span class=w> </span><span class=n>a</span><span class=p>.</span><span class=k>no</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>b</span><span class=p>.</span><span class=k>no</span><span class=w> </span><span class=k>and</span><span class=w> </span><span class=n>a</span><span class=p>.</span><span class=n>name</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>b</span><span class=p>.</span><span class=n>name</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>group</span><span class=w> </span><span class=k>by</span><span class=w> </span><span class=n>name</span><span class=p>,</span><span class=k>no</span><span class=w>
</span></span></span></code></pre></div><p>其他方案：</p><ol><li>对于不符合 ONLY_FULL_GROUP_BY 限制的字段，添加 unique 索引。</li><li>使用 ANY_VALUE()，让 MySQL 跳过 ONLY_FULL_GROUP_BY 检测。</li></ol><h2 id=小结>小结<a hidden class=anchor aria-hidden=true href=#小结>#</a></h2><blockquote><p><a href=https://dev.mysql.com/doc/refman/5.6/en/group-by-handling.html>MySQL 5.6 Handling of GROUP BY</a></p></blockquote><p>In standard SQL, a query that includes a GROUP BY clause cannot refer to nonaggregated columns in the select list that are not named in the GROUP BY clause.</p><p>在标准 SQL 中，包含 GROUP BY 子句的查询 <strong>不能引用</strong> select 列表中未在 GROUP BY 子句中命名的列。</p><p>MySQL extends the standard SQL use of GROUP BY so that the select list can refer to nonaggregated columns not named in the GROUP BY clause. This means that the preceding query is legal in MySQL.</p><p>MySQL 扩展了 GROUP BY 的标准 SQL 使用，以便选择列表可以引用 GROUP BY 子句中未命名的非集合列。这意味着前面的查询在 MySQL 中是合法的。</p><p>However, this is useful primarily when all values in each nonaggregated column not named in the GROUP BY are the same for each group. The server is free to choose any value from each group, so unless they are the same, the values chosen are indeterminate.</p><p>但是，主要是在 GROUP BY 中 <strong>未命名的每个非分组列中的所有值对于每个组是相同的</strong>，这是有用的。服务器可以自由选择每个组中的任何值，因此除非它们相同，所选择的值是 <strong>不确定的</strong>。</p><p>Furthermore, the selection of values from each group cannot be influenced by adding an ORDER BY clause. Result set sorting occurs after values have been chosen, and ORDER BY does not affect which values within each group the server chooses.</p><p>此外，通过添加 ORDER BY 子句不会影响来自每个组的值的选择。结果集排序发生在选择值后，ORDER BY <strong>不影响</strong> 服务选择的每个组中的哪些值。</p><blockquote><p><a href=https://dev.mysql.com/doc/refman/5.7/en/group-by-handling.html>MySQL 5.7 Handling of GROUP BY</a></p></blockquote><p>MySQL 5.7.5 and up implements detection of functional dependence. If the ONLY_FULL_GROUP_BY SQL mode is enabled (which it is by default), MySQL rejects queries for which the select list, HAVING condition, or ORDER BY list refer to nonaggregated columns that are neither named in the GROUP BY clause nor are functionally dependent on them. (Before 5.7.5, MySQL does not detect functional dependency and ONLY_FULL_GROUP_BY is not enabled by default.)</p><p>MySQL 5.7.5 及以上功能依赖检测功能。如果启用了 ONLY_FULL_GROUP_BY SQL 模式（默认情况下），MySQL 将拒绝对列表，HAVING 条件或 ORDER BY 列表的查询引用在 GROUP BY 子句中既未命名的非集合列，也不在功能上依赖于它们。（5.7.5 之前，MySQL 没有检测到功能依赖关系，默认情况下不启用 ONLY_FULL_GROUP_BY）</p><p>You can achieve the same effect without disabling ONLY_FULL_GROUP_BY by using ANY_VALUE() to refer to the nonaggregated column.</p><p>你可以通过使用 <code>ANY_VALUE()</code> 使禁用了 ONLY_FULL_GROUP_BY 的 SQL，来实现相同的效果来引用非聚合列。</p><h2 id=56-与-57-的区别>5.6 与 5.7 的区别<a hidden class=anchor aria-hidden=true href=#56-与-57-的区别>#</a></h2><p>5.6 升级到 5.7 版本要注意：</p><ol><li>sql_mode 默认值的改变。</li><li>optimizer_switch 值的改变。</li><li>备库升级影响主备复制。</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=o>@@</span><span class=n>SQL_MODE</span><span class=p>,</span><span class=w> </span><span class=o>@@</span><span class=k>GLOBAL</span><span class=p>.</span><span class=n>SQL_MODE</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- 5.6
</span></span></span><span class=line><span class=cl><span class=c1>-- NO_ENGINE_SUBSTITUTION
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- 5.7
</span></span></span><span class=line><span class=cl><span class=c1>-- ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION
</span></span></span></code></pre></div><ul><li><code>ONLY_FULL_GROUP_BY</code> SELECT 查询的字段必须是 GROUP BY 中出现的或者使用聚合函数的或者是具有唯一索引的。</li><li><code>STRICT_TRANS_TABLES</code> 在该模式下，如果一个值不能插入到一个事务表中，则中断当前的操作，对非事务表不做任何限制。</li><li><code>NO_ZERO_IN_DATE</code> 在严格模式，不接受月或日部分为 0 的日期。如果使用 IGNORE 选项，我们为类似的日期插入'0000-00-00&rsquo;。在非严格模式，可以接受该日期，但会生成警告。</li><li><code>NO_ZERO_DATE</code> 在严格模式，不要将 &lsquo;0000-00-00&rsquo;做为合法日期。你仍然可以用 IGNORE 选项插入零日期。在非严格模式，可以接受该日期，但会生成警告。</li><li><code>ERROR_FOR_DIVISION_BY_ZERO</code> 在严格模式，在 INSERT 或 UPDATE 过程中，如果被零除(或 MOD(X，0))，则产生错误(否则为警告)。如果未给出该模式，被零除时 MySQL 返回 NULL。如果用到 INSERT IGNORE 或 UPDATE IGNORE 中，MySQL 生成被零除警告，但操作结果为 NULL。</li><li><code>NO_AUTO_CREATE_USER</code> 防止 GRANT 自动创建新用户，除非还指定了密码。</li><li><code>NO_ENGINE_SUBSTITUTION</code> 如果需要的存储引擎被禁用或未编译，那么抛出错误。不设置此值时，用默认的存储引擎替代，并抛出一个异常。</li></ul><h3 id=strict_trans_tables-和-strict_all_tables-的区别>STRICT_TRANS_TABLES 和 STRICT_ALL_TABLES 的区别<a hidden class=anchor aria-hidden=true href=#strict_trans_tables-和-strict_all_tables-的区别>#</a></h3><p>唯一的区别是：对于不支持事务的表，若开启 STRICT_TRANS_TABLES，MySQL 会尝试将一个不合法的字段值转换成一个值最近的合法值插入表中；而开启 STRICT_ALL_TABLES 后，则表现为不写入数据，且抛出错误。</p><p>因为现在绝大部分用的 InnoDB 引擎，是支持事务的，所以基本不用关心这种区别。</p><h3 id=严格模式和非严格模式的区别>严格模式和非严格模式的区别<a hidden class=anchor aria-hidden=true href=#严格模式和非严格模式的区别>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SET</span><span class=w> </span><span class=n>sql_mode</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;STRICT_TRANS_TABLES&#39;</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><p>严格模式下不能在无符号整数字段插入负值。</p><ul><li>非严格模式下，会存储为 0。</li><li>严格模式下，报错。</li></ul><p>严格模式下，无默认值的 NOT NULL 字段在插入数据时必须指定值。</p><ul><li>非严格模式下，若不插入数据会存储字段类型的默认值。</li><li>严格模式下，报错。</li></ul><p>严格模式下，插入字符串不能超出定义长度</p><ul><li>非严格模式下，会成功插入数据，但是内容被截断。</li><li>严格模式下，报错。</li></ul><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><ul><li><a href=http://mysqlwyett.com/blog/2017/01/17/max_values_in_group_by/>MySQL 组内排序取最大值 | mysqlwyett</a></li><li><a href=http://stackoverflow.com/questions/1066453/mysql-group-by-and-order-by>sql - MySQL Group By and Order By; - Stack Overflow</a></li><li><a href=https://zhuanlan.zhihu.com/p/50278304>MySQL5.7 中的 sql_mode 默认值 | zhihu</a></li><li><a href=https://www.letianbiji.com/mysql/mysql-strict-mode.html>MySQL: 严格模式 | letianbiji</a></li></ul><p>&ndash; EOF &ndash;</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://zyf.im/tags/mysql/>Mysql</a></li></ul><nav class=paginav><a class=prev href=https://zyf.im/2017/04/21/cgi-fastcgi-phpcgi-php-fpm/><span class=title>« Prev</span><br><span>区分 CGI FastCGI PHP-CGI PHP-FPM</span>
</a><a class=next href=https://zyf.im/2017/04/11/mysql-manage-user-and-grant/><span class=title>Next »</span><br><span>MySQL 管理用户与访问授权</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://zyf.im/>ZYF.IM BLOG</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>