<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.148.0"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>ZYF.IM BLOG</title><meta name=keywords content="ZYF,ZYF.IM,Blog,Portfolio,PaperMod"><meta name=description content="Code. Create. Conquer."><meta name=author content="Me"><link rel=canonical href=https://zyf.im/><link crossorigin=anonymous href=/assets/css/stylesheet.63618a0fd0c7dd946ad6f368012c097fc6e5a8464cefd289c140dd28c01ec58d.css integrity="sha256-Y2GKD9DH3ZRq1vNoASwJf8blqEZM79KJwUDdKMAexY0=" rel="preload stylesheet" as=style><link rel=icon href=https://zyf.im/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zyf.im/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://zyf.im/favicon-32x32.png><link rel=apple-touch-icon href=https://zyf.im/apple-touch-icon.png><link rel=mask-icon href=https://zyf.im/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://zyf.im/index.xml><link rel=alternate type=application/json href=https://zyf.im/index.json><link rel=alternate hreflang=en href=https://zyf.im/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-6DVZ6E58DG"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-6DVZ6E58DG")}</script><meta property="og:url" content="https://zyf.im/"><meta property="og:site_name" content="ZYF.IM BLOG"><meta property="og:title" content="ZYF.IM BLOG"><meta property="og:description" content="Code. Create. Conquer."><meta property="og:locale" content="en-us"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="ZYF.IM BLOG"><meta name=twitter:description content="Code. Create. Conquer."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"ZYF.IM BLOG","url":"https://zyf.im/","description":"Code. Create. Conquer.","logo":"https://zyf.im/favicon.ico","sameAs":["https://github.com/","https://space.bilibili.com/29991589","/links/"]}</script></head><body class="list dark" id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://zyf.im/ accesskey=h title="ZYF.IM (Alt + H)"><img src=https://zyf.im/apple-touch-icon.png alt aria-label=logo height=35>ZYF.IM</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://zyf.im/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://zyf.im/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://zyf.im/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://zyf.im/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>ES6 中使用 jQuery $(this) 的问题</h2></header><div class=entry-content><p>在老项目中，我开始使用 laravel-mix 和 ES6 进行逐渐过渡。在这个过程中，发现了一个问题：当 jQuery 和 箭头函数 一起使用时，$(this) 的含义会发生变化。
问题解释 这个问题主要是因为没有理解 箭头函数 的特性。箭头函数不会创建自己的 this 上下文，而是继承父作用域的 this。
看下面的例子：
// 问题代码 $('.js-bottom-btn').click(() => { let flag = $(this).data('flag'); // ... }); 在箭头函数中，this 不是指向被点击的元素，而是指向父作用域的 this（可能是 window 或 undefined）。
解决方案 根据 jQuery click 文档，可以使用以下方法解决：
方法 1: 使用传统函数 $('.js-bottom-btn').click(function() { let flag = $(this).data('flag'); // ... }); 方法 2: 使用事件参数 $('.js-bottom-btn').click(event => { let flag = $(event.currentTarget).data('flag'); // ... }); 其他常见场景 jQuery 的 .each() 方法中也会遇到类似问题：
// 问题代码 $("jquery-selector").each(() => { $(this).click(); }); 需要修改为：
$("jquery-selector").each((index, element) => { $(element).click(); }); 箭头函数和 this 绑定 箭头函数的一个主要特点是词法绑定（lexical binding）。这意味着：
箭头函数不创建自己的 this 上下文 箭头函数继承定义它的外部作用域的 this 值 这种行为与传统函数不同，传统函数中的 this 是根据调用方式决定的 参考资料 Using jQuery $(this) with ES6 Arrow Functions (lexical this binding) – EOF –
...</p></div><footer class=entry-footer><span title='2019-04-10 17:09:23 +0800 CST'>April 10, 2019</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;113 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to ES6 中使用 jQuery $(this) 的问题" href=https://zyf.im/2019/04/10/es6-jquery-this-arrow-function/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>寻找数组中轴索引</h2></header><div class=entry-content><p>将 pivot 索引定义为：左边的数字之和等于索引右边的数字之和。
Input: nums = [1, 7, 3, 6, 5, 6] Output: 3 Explanation: 1 + 7 + 3 = 5 + 6 Input: nums = [1, 2, 3] Output: -1 Explanation: There is no index that satisfies the conditions in the problem statement. Note:
The length of nums will be in the range [0, 10000]. Each element nums[i] will be an integer in the range [-1000, 1000]. 关键点 动态规划 数组的和 - 中轴数 = 中轴数左边数组的和 * 2 解答 func findPivot(_ array: [Int]) -> Int { // 数组和 let sum = array.reduce(0, +) // 左侧数组和 var leftSum = 0 for (key, value) in array.enumerated() { if sum - value == leftSum * 2 { return key } leftSum += value } return -1 } let array = [1, 7, 3, 6, 5, 6] search(array) // 3 References 找到数组中左右两边的和相等的 pivot 的下标 Find Pivot Index – EOF –
...</p></div><footer class=entry-footer><span title='2019-03-06 14:00:00 +0800 CST'>March 6, 2019</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;146 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 寻找数组中轴索引" href=https://zyf.im/2019/03/06/find-pivot-index/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>m 进制转 n 进制</h2></header><div class=entry-content><p>思路 m 进制 -> 十进制 -> n 进制 利用柯里化生成函数（炫技 🐶） m 进制 -> 十进制 // carry 范围值: 2-36 // origin 范围值: 0-9 [ascii 48-58], A-Z [65-90], a-z [97-122] func carryToDecimalism(_ carry: Int) -> (_ origin: String) -> Int { return { origin in // 得到字符串对应的 ascii 码 let asciis = origin.uppercased().unicodeScalars.map { Int($0.value) } // 累加每一位 let result = asciis.reversed().enumerated().map { (index, ascii) -> Int in var standard: Int if 65 &lt;= ascii && ascii &lt;= 90 { standard = ascii - 65 + 10 } else { standard = ascii - 48 } return standard * Int(pow(Double(carry), Double(index))) }.reduce(0, +) return result } } let 十六进制转十进制 = carryToDecimalism(16) print(十六进制转十进制("1a")) // 26 let 二进制转十进制 = carryToDecimalism(2) print(二进制转十进制("110")) // 6 十进制 -> n 进制 func decimalismToCarry(_ carry: Int) -> (_ origin: Int) -> String { return { origin in var result = [Int]() var remain = origin while remain > 0 { result.append(remain % carry) remain /= carry } if carry &lt;= 10 { return result.reversed().map(String.init).joined() } else { return result.reversed().map { i -> String in return i &lt; 10 ? String(i) : String(UnicodeScalar(i + 55)!) }.joined() } } } let 十进制转二进制 = decimalismToCarry(2) print(十进制转二进制(26)) // "11010" References ASCII 码对照表 – EOF –
...</p></div><footer class=entry-footer><span title='2019-03-02 14:00:00 +0800 CST'>March 2, 2019</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;202 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to m 进制转 n 进制" href=https://zyf.im/2019/03/02/convert-m-number-to-n-number/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>超长阶乘的计算</h2></header><div class=entry-content><p>打印 n! 的结果（1 &lt;= n &lt;= 100）。注意：当 n > 20 时 64 位的 Int 将无法直接存储结果。
思路 将大数字用 数组 形式表示。比如 987 使用 [9,8,7] 代替。 每一位乘以 n，再进行进位操作，得到新数组。 let nums = [9, 8, 7] let tmpNums = nums.map { $0 * 2 } // [18, 16, 14] // 遍历 tmpNums 每一个数字，进行进制操作 [18, 16, 14] -> [18, 17, 4] -> [19, 7, 4] -> [1, 9, 7, 4] print(tmpNums.map(String.init).joined()) // 1974 解答项目 func extraLongFactorials(n: Int) -> Void { guard n > 0 else { return } // 结果数组 var result: [Int] = [1] for index in 1...n { // 数组翻转 从低位开始每一位乘以本次的数字 let tmpNums = result.reversed().map { $0 * index } // 进位数 var carryNum = 0 // 重置结果 result = [] tmpNums.forEach { // 每一位加上上一位的进的数 let tmpNum = $0 + carryNum // 向下一位进制的数 carryNum = tmpNum / 10 // 本位实际剩下的数 插入结果 result.append(tmpNum % 10) } // 处理剩余进位数 进位数是可能大于 100 while carryNum > 0 { // 逐渐插入进制 result.append(carryNum % 10) carryNum /= 10 } // 翻转回数组 result = result.reversed() } // 连接字符串 print(result.map(String.init).joined()) } References Extra Long Factorials | HackerRank Swift 3 calculate factorial number. Result becomes too high? – EOF –
...</p></div><footer class=entry-footer><span title='2019-03-01 14:00:00 +0800 CST'>March 1, 2019</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;187 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 超长阶乘的计算" href=https://zyf.im/2019/03/01/extra-long-factorials/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>fastlane 入门使用</h2></header><div class=entry-content><p>这次以 fastlane 为例，尝试项目中有什么事情可以被自动完成。
fastlane 是 Ruby scripts 的集合，安装方法不多说了见 官网文档。
fastlane 中有但不限于以下工具集：
produce 同时在 Apple Developer Portal 和 App Store Connect 中创建新的 iOS apps。 cert 自动创建和维护 iOS 签名证书。 sigh 创建，更新，下载和修复配置文件。 snapshot 自动在每台设备上获取 iOS 应用的本地化屏幕截图。 frameit 将您的屏幕截图放入正确的设备框架中。 gym 构建和打包您的 iOS apps。 deliver 将截图，元数据和您的应用上传到 App Store。 pem 自动生成并更新推送通知配置文件。 spaceship 一个 Ruby 库能够访问苹果开发者中心和应用商店连接 api。 pilot 自动化 TestFlight 部署并管理测试用户。 boarding 邀请 beta 测试人员。 match 使用 Git 同步整个团队的证书和配置文件。 scan 运行 app 测试。 实验环境：Xcode 10.1、Swift 4.2、fastlane 2.116.1、$99 开发者账户
...</p></div><footer class=entry-footer><span title='2019-02-28 10:00:00 +0800 CST'>February 28, 2019</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;657 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to fastlane 入门使用" href=https://zyf.im/2019/02/28/fastlane-getting-started/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>【Swifter - Swift 开发者必备 Tips】笔记</h2></header><div class=entry-content><p>再读王巍的【Swifter - Swift 开发者必备 Tips】，看看有什么新收获。
柯里化（Currying） 柯里化 是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术，这个词自己是第一次见到。
自己的理解就是：把接受多个参数的函数变换为，先接受一个参数，然后返回一个函数，这个函数再接受其他参数。
两个细节：
只有一个参数，并且这个参数是该函数的第一个参数。必须按照参数的定义顺序来调用柯里化函数。 柯里化函数的函数体只会执行一次，只会在调用完最后一个参数的时候执行柯里化函数体。 /// 一个数加 x 的函数 func addTo(_ adder: Int) -> (Int) -> Int { return { adder + $0 } } // +2 let addTwo = addTo(2) let result = addTwo(6) // 8 // +10 let addTen = addTo(10) addTen(6) // 16 柯里化是一种量产相似方法的好办法，可以通过柯里化一个方法模板来避免写出很多重复代码，也方便了今后维护。
书中还提到了一个封装 Selector 的例子，但是没懂，欢迎指教。
Reference:
Swift 函数柯里化介绍及使用场景 将 protocol 的方法声明为 mutating protocol 不仅可以被 class 类型实现，也适用于 struct 和 enum。因为这个原因就要考虑定义的方法是否应该使用 mutating 来修饰。在 protocl 中使用 mutating 修饰的方法，对于 class 的实现是完全透明的。
多元组（Tuple） python 中有见过类似。
/// 交互数据 func swapMe&lt;T>(_ a: inout T, _ b: inout T) { (a, b) = (b, a) } var a = 10 var b = 20 swapMe(&amp;a, &amp;b) // a: 20 b: 10 /// 可读的返回值 let rect = CGRect(x: 0, y: 0, width: 100, height: 100) let (slice, remainder) = rect.divided(atDistance: 20, from: .minYEdge) // slice {x 0 y 0 w 100 h 20} // remainder {x 0 y 20 w 100 h 80} @autoclosure 和 ?? @autoclosure 做的事情就是把一句表达式自动的封装成一个闭包（closure）。这样有时候在语法上看起来就会非常漂亮。
...</p></div><footer class=entry-footer><span title='2019-02-15 17:00:00 +0800 CST'>February 15, 2019</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;402 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 【Swifter - Swift 开发者必备 Tips】笔记" href=https://zyf.im/2019/02/15/swifter-tips-reading-notes/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>PromiseKit 入门使用</h2></header><div class=entry-content><p>在 GitHub Trending 中总是看到 mxcl/PromiseKit 它是主要解决的是 “回调地狱” 的问题，决定尝试用一下。
环境：Swift 4.2、PromiseKit 6
then and done 下面是一个典型的 promise 链式（chain）调用：
firstly { login() }.then { creds in fetch(avatar: creds.user) }.done { image in self.imageView = image } 如果这段代码使用完成回调（completion handler）实现，他将是：
login { creds, error in if let creds = creds { fetch(avatar: creds.user) { image, error in if let image = image { self.imageView = image } } } } then 是完成回调的另一种方式，但是它更丰富。在处级阶段的理解，它更具有可读性。上面的 promise chain 更容易阅读和理解：一个异步操作接着另一个，一行接一行。它与程序代码非常接近，因为我们很容易得到 Swift 的当前状态。
...</p></div><footer class=entry-footer><span title='2019-01-19 14:00:00 +0800 CST'>January 19, 2019</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;749 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to PromiseKit 入门使用" href=https://zyf.im/2019/01/19/promisekit-getting-started/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>回顾 2018</h2></header><div class=entry-content><p>重新翻阅的自己工作邮件的发件箱，回顾一年工作。新年伊始自己还是在开发 P 项目的 iOS App，开始写 Q&amp;A 功能。一些不算太难的 tableView 布局的需求，对我来说，都是头大的问题。
这段时期招聘时的面试，竟成为我学习 App 开发的一扇小窗。
年前收到了奖金还是挺开心的。leader 新年寄语：
要发声，要当主力 当有好的想法时，要学会说服别人 要有耐心，Yifan 需要时间的沉淀 前两点意思差不多，这段时间思想上困扰我的是：自己对自己的定位是一个初级工程师，认为会的东西、经验不多，见识少，我尊重比我年长的工程师的想法与观点，也相信他们是经过长远思考过的。这个思维设定，我觉得没有什么问题。但是也许有人忽略了 责任，对方案负责，对项目负责。开发方案一再重建性修改，接口结构没有规范。
2017 的总结说胜利属于伏地魔，本想苟着发育，这时发现：苟是苟不住的，这个世界 需要英雄 carry。
后来我感觉应该将公司看做一个舞台，舞台上有灯光、音效就要利用，展示自己、锻炼自己，即使是出糗，那就整理整理再来一次，who care? 成长是最重要的。
Course 模块是前工程师用 Objective-C 写的，离职后一直没有再维护，过年期间自己重构了所有 Objective-C 的代码，项目完全转为了一个纯 Swift 项目。使用 Realm 作为数据本地化方案，选择的原因也很朴素，GitHub 哪个星多我就优先选用什么。
后来参考 Jack Feng - 6ag 的几个 Swift 开源项目，新创建了 P 项目的工具 App，也对主项目结构做了重新的整理，在这里再次特别感谢。
西安运营部的成立，加多了 C 项目的后台需求，难以都顾及项目两头。使用 laravel-admin 搭建新后台，也开始使用 Docker 部署项目，感觉从此离不开 Docker 了，像极了遇到 Git 时的感觉。
C 项目主站的前端是在服务端渲染，非常传统的模式，多个工程师转手也是十分混乱。参考了 白俊遥 工程的博客、laravel 项目，修改了项目结构，添加了 gulp 工具制定了工作流，虽然没有实现前后端的完全分离，但终究是向现代化前端走出了一步。
转眼就到了年中调薪，公司不含糊，薪水涨到了我满意的值。这对我很关键，调整的不单单是我的薪水，也调整了我的心态。因为当时我认为没有强的工程师、甚至归我负责，却拿着比我还高的薪水。现在总算是有了一个平衡。
不断向 C 项目投入更多的资源，项目 指标 的要求越来越多。比如：优化了项目、优化了查询，到底优化了多少，怎么量化？这些在之前一直不被重视，改好了就都算叫优化了。项目中出现的问题错误，都要查找真实具体的原因，而不是说一个可能的什么原因，就当解答的了。我一开始也很难适应这些，但心里是认同的。
...</p></div><footer class=entry-footer><span title='2018-12-31 21:00:00 +0800 CST'>December 31, 2018</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;136 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 回顾 2018" href=https://zyf.im/2018/12/31/review-2018/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>二分查找 Binary Search</h2></header><div class=entry-content><p>快速从一个数组中查找一个元素。
Linear Search 线性查找 func linearSearch&lt;T: Equatable>(_ a: [T], _ key: T) -> Int? { for i in 0 ..&lt; a.count { if a[i] == key { return i } } return nil } 线性查找在最坏情况：遍历了整个数组，但没有找到合适的元素。平均要遍历一半的元素性能为 O(n)，而二分查找的效率为 O(log n)，也就是说一个有 1,000,000 元素的数组只需要 20 步就可以找到想要的元素 log_2(1,000,000) = 19.9。
但是二分查找要求数组必须是排好序。
二分查找步骤：
将数组分为两半。 判断想要找的元素是在左边数组还是右边，这也是数组需要排好顺序的原因。 如果要的元素在左边，就将左边的数组分成更小的两部分，并判断要的元素在哪部分。 重复步骤直到找到想要的元素。如果数组不能进一步查分，就说明要找的元素不在数组中。 divide-and-conquer
The code func binarySearch&lt;T: Comparable>(_ a: [T], key: T, range: Range&lt;Int>) -> Int? { if range.lowerBound >= range.upperBound { // If we get here, then the search key is not present in the array. return nil } else { // Calculate where to split the array. let midIndex = range.lowerBound + (range.upperBound - range.lowerBound) / 2 // Is the search key in the left half? if a[midIndex] > key { return binarySearch(a, key: key, range: range.lowerBound ..&lt; midIndex) // Is the search key in the right half? // 这里 + 1 的原因是排除 midIndex 中间值 } else if a[midIndex] &lt; key { return binarySearch(a, key: key, range: midIndex + 1 ..&lt; range.upperBound) // If we get here, then we've found the search key! } else { return midIndex } } } // 19 numbers let numbers = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67] // 0 ..&lt; numbers.count 覆盖所有范围 binarySearch(numbers, key: 43, range: 0 ..&lt; numbers.count) // gives 13 二分查找是将数组分为两个，但是我们不需要正真的创建两个新数组。取而代之，我们使用 Swift Range 对象跟踪这些拆分。左闭右开。upperBound 总是比最后一个元素的索引多一。
...</p></div><footer class=entry-footer><span title='2018-12-10 14:00:00 +0800 CST'>December 10, 2018</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;329 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 二分查找 Binary Search" href=https://zyf.im/2018/12/10/binary-search/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>插入排序 Insertion Sort</h2></header><div class=entry-content><p>将一个数组从高到低或者从低到高排序。
插入排序算法的工作原理：
将若干数字放在一个数组里，数组是乱序的。 从数组中挑选一个数字，它是哪个并不重要，但是为了方便我们挑选数组头部的这个。 将这个数字插入到一个新的数组里。 从乱序数组里挑选下一个数字也将它放到新数组里。这个数字要么在第一个数字前或者后，所以这个两个数字是被排序的。 再次重从乱序数组里挑选下一个数字也将它放到新数组里，并将数字放在正确的位置。 一直如此进行直到乱序数组中没有数字。这时也将等到一个排序好的新数组。 自己的一个实现：
let array = [2, 1, 3, 8, 3, 5, 4] var newArray = [Int]() for (k, v) in array.enumerated() { for (nK, nV) in newArray.enumerated() { // 本次的数 小于 存在的数的第一个(nv) if v &lt; nV { newArray.insert(v, at: nK) break } } // 没有插入成功 放在末尾 if newArray.count &lt; k + 1 { newArray.append(v) } } In-place sort 上面的排序需要两个数组，一个原始的，一个排好顺序的。但是我们也可以 就地排序 无需创建一个额外的数组。我们只需要跟踪记录原始数组中哪里部分排好顺序了，哪一部分还没有排序。
...</p></div><footer class=entry-footer><span title='2018-11-24 16:00:00 +0800 CST'>November 24, 2018</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;574 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 插入排序 Insertion Sort" href=https://zyf.im/2018/11/24/insertion-sort/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://zyf.im/page/7/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://zyf.im/page/9/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://zyf.im/>ZYF.IM BLOG</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>