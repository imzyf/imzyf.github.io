<!doctype html><html lang=en dir=auto data-theme=dark><head><meta name=generator content="Hugo 0.154.2"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>ZYF.IM BLOG</title><meta name=keywords content="ZYF,Yifans,Blog,Portfolio,PaperMod"><meta name=description content="The limits of my language mean the limits of my world."><meta name=author content="Me"><link rel=canonical href=https://zyf.im/><link crossorigin=anonymous href=/assets/css/stylesheet.88888b1f97bcb20b824590bc7c6603a852913a2540638b3b3e2663e642691da3.css integrity="sha256-iIiLH5e8sguCRZC8fGYDqFKROiVAY4s7PiZj5kJpHaM=" rel="preload stylesheet" as=style><link rel=icon href=https://zyf.im/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zyf.im/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://zyf.im/favicon-32x32.png><link rel=apple-touch-icon href=https://zyf.im/apple-touch-icon.png><link rel=mask-icon href=https://zyf.im/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://zyf.im/index.xml title=rss><link rel=alternate type=application/json href=https://zyf.im/index.json title=json><link rel=alternate hreflang=en href=https://zyf.im/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script>localStorage.getItem("pref-theme")==="light"&&(document.querySelector("html").dataset.theme="light")</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-6DVZ6E58DG"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-6DVZ6E58DG")}</script><meta property="og:url" content="https://zyf.im/"><meta property="og:site_name" content="ZYF.IM BLOG"><meta property="og:title" content="ZYF.IM BLOG"><meta property="og:description" content="The limits of my language mean the limits of my world."><meta property="og:locale" content="en-us"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="ZYF.IM BLOG"><meta name=twitter:description content="The limits of my language mean the limits of my world."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"ZYF.IM BLOG","url":"https://zyf.im/","description":"The limits of my language mean the limits of my world.","logo":"https://zyf.im/favicon.ico","sameAs":["https://github.com/","https://space.bilibili.com/29991589","/links/"]}</script></head><body class=list id=top><header class=header><nav class=nav><div class=logo><a href=https://zyf.im/ accesskey=h title="ZYF.IM (Alt + H)"><img src=https://zyf.im/apple-touch-icon.png alt aria-label=logo height=35>ZYF.IM</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://zyf.im/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://zyf.im/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://zyf.im/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://zyf.im/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>插入排序 Insertion Sort</h2></header><div class=entry-content><p>将一个数组从高到低或者从低到高排序。
插入排序算法的工作原理：
将若干数字放在一个数组里，数组是乱序的。 从数组中挑选一个数字，它是哪个并不重要，但是为了方便我们挑选数组头部的这个。 将这个数字插入到一个新的数组里。 从乱序数组里挑选下一个数字也将它放到新数组里。这个数字要么在第一个数字前或者后，所以这个两个数字是被排序的。 再次重从乱序数组里挑选下一个数字也将它放到新数组里，并将数字放在正确的位置。 一直如此进行直到乱序数组中没有数字。这时也将等到一个排序好的新数组。 自己的一个实现：
let array = [2, 1, 3, 8, 3, 5, 4] var newArray = [Int]() for (k, v) in array.enumerated() { for (nK, nV) in newArray.enumerated() { // 本次的数 小于 存在的数的第一个(nv) if v &lt; nV { newArray.insert(v, at: nK) break } } // 没有插入成功 放在末尾 if newArray.count &lt; k + 1 { newArray.append(v) } } In-place sort 上面的排序需要两个数组，一个原始的，一个排好顺序的。但是我们也可以 就地排序 无需创建一个额外的数组。我们只需要跟踪记录原始数组中哪里部分排好顺序了，哪一部分还没有排序。
...</p></div><footer class=entry-footer><span title='2018-11-24 16:00:00 +0800 CST'>November 24, 2018</span>&nbsp;·&nbsp;<span>3 min</span>&nbsp;·&nbsp;<span>574 words</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to 插入排序 Insertion Sort" href=https://zyf.im/2018/11/24/insertion-sort/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>队列 Queue Data Structure</h2></header><div class=entry-content><p>实现一个 队列，包括 enqueue、dequeue、peek。
Queue 队列 核心也是 array，A queue gives you a FIFO or first-in, first-out order. 队列是：先进先出的。
public struct Queue&lt;T> { fileprivate var array = [T]() } enqueue 进队，在数组尾部追加元素。
public mutating func enqueue(_ element: T) { array.append(element) } dequeue 出队，将首位的元素移除。因为首位元素移除后，其他元素依次向前移动，所以是 O(n)。
public var isEmpty: Bool { // 使用数组自身的方法，而不是 array.count > 0 return array.isEmpty } public mutating func dequeue() -> T? { // 使用定义的变量 if isEmpty { return nil } else { return array.removeLast() } } peek 查看队首元素。
/// peek() 改为更有语义话的只读变量 public var front: T? { return array.first } 优化出队 在出队后不移动元素而是移动 起始索引，就像动的收银台而不是排队的人。
/// 优化 队列 的出队 public struct OptimizedQueue&lt;T> { /// 这里改为了可选型，为了可以清理无效的元素 fileprivate var array = [T?]() /// 起始索引 fileprivate var head = 0 public var count: Int { // 减去 起始索引 前面的数量 return array.count - head } public var isEmpty: Bool { // 根据实际数量判断 return count == 0 } // 保持不变 public mutating func enqueue(_ element: T) { array.append(element) } public mutating func dequeue() -> T? { guard head &lt; array.count, let element = array[head] else { return nil } // 置空当前位置元素 array[head] = nil // 前移起始索引 head += 1 // 空索引的占用比例 let percentage = Double(head)/Double(array.count) // 50 0.25 都是魔法数字，主要是为了控制数组修剪的频率，可以自行调整 if array.count > 50 && percentage > 0.25 { // 将起始空元素删除 array.removeFirst(head) // 重置 起始索引 head = 0 } return element } public var front: T? { if isEmpty { return nil } else { // 根据 起始索引进行 返回 return array[head] } } } 文章代码：GitHub - imzyf/data-structure-and-algorithm/002-Queue/。
...</p></div><footer class=entry-footer><span title='2018-11-22 16:00:00 +0800 CST'>November 22, 2018</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>239 words</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to 队列 Queue Data Structure" href=https://zyf.im/2018/11/22/queue-data-structure/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>栈 Stack Data Structure</h2></header><div class=entry-content><p>加入 Swift Algorithm Club /‘ælgə’rɪðəm/，回炉重新学习数据结构与算法。
自己创建的项目：GitHub - imzyf/data-structure-and-algorithm。
实现一个 栈 /stæk/，包含 push peek pop 与 Generics 泛型。
stack 栈 非常像一个数组，它包括少量的方法。
push 添加一个新元素到栈顶 pop 从栈顶移除一个元素 peek 查看栈顶的一个元素但是不 pop A stack gives you a LIFO or last-in first-out order. 栈是后进先出，队列是先进先出。
public struct Stack&lt;Element> { fileprivate var array: [Element] = [] } push push 是在数组的尾部添加元素是以 O(1)，如果是在数组最前添加是 O(n) 这是昂贵的。
public mutating func push(_ element: Element) { array.append(element) } 因为使用的 struct，修改属性值的方法要加 mutating。
pop 想从一个空栈中弹出最后一个元素将返回 nil。
...</p></div><footer class=entry-footer><span title='2018-11-22 14:00:00 +0800 CST'>November 22, 2018</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>126 words</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to 栈 Stack Data Structure" href=https://zyf.im/2018/11/22/stack-data-structure/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>在 MySQL 中选择合适的日期类型</h2></header><div class=entry-content><p>如何在 MySQL 中选择合适的日期类型困扰了很久，varchar、int、timestamp、datetime 都有尝试过，近来有所感悟，做此总结。
注：此总结考虑了 PHP 和 Laravel 框架的特点。
使用 varchar varchar 存储日期时间的格式完全可以自己控制，月/日/年 还是 年-月-日 需求怎么说就怎么存，读取后展示是也不用在格式化。同时伏笔也就此埋下：日期时间格式没强制约束，总有一天字段里出现了与众不同的格式；要是日期时间会 变化 或作为 查询条件 或要进行 排序 时就又是一坑，还是要格式化标准格式再处理。可以说 varchar 应该是最差的选择了。
使用 int 与 timestamp PHP time() 可以直接获取当前时间戳秒数，数据库字段要也是 int 一存就完事了，不会有格式问题，谁用什么样转什么样。但是在数据库工具中查看此字段时显示不够直观，范围时会不方便，这些在使用 timestamp 是会得到解决。
timestamp 是我一直迷惑的一个类型。我写了几个例子做测试：
将 Laravel 项目设置为 CST 中国标准时间，MySQL 时区设置为 UTC，使用 now() 获取当前日期时间，比如：2018-5-25 11:00:00 存入 timestamp 类型的字段中，使用数据库工具查看字段结果为仍然为 2018-5-25 11:00:00。 继续上面的操作，项目中使用查询语句查询刚才的记录，结果显示为 2018-5-25 11:00:00，将项目时区从 CST 改为 UTC 后再次查询的结果仍然为 2018-5-25 11:00:00 没有变化。 继续上面的操作，将数据库的时区改为 +8:00，数据库工具、项目查询后的结果为 2018-5-25 19:00:00 发生了变化，修改项目为 CST 查询结果是 2018-5-25 19:00:00 和刚才一样也变化了。 这个测试说明了：
...</p></div><footer class=entry-footer><span title='2018-05-25 16:00:00 +0800 CST'>May 25, 2018</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>254 words</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to 在 MySQL 中选择合适的日期类型" href=https://zyf.im/2018/05/25/select-the-appropriate-date-type-in-mysql/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>【Modern PHP】笔记</h2></header><div class=entry-content><p>又回到 PHP Web 开发，使用 Laravel 框架，重读《Modern PHP》。
PHP 正在重生。
特性 命名空间 声明命名空间：
&lt;?php namespace Oreilly\ModernPHP; 导入和别名：
&lt;?php use Symfony\Component\HttpFoundation\Response as Res; $r = new Res('Oops', 400); $r->send(); PHP 5.6 开始可以导入函数和常量：
&lt;?php use func Namespace\functionName; use constant Namespace\CONST_NAME; functionName(); echo CONST_NAME; 使用接口 接口是两个 PHP 对象之间的契约，其目的不是让一个对象依赖另一个对象的身份，而是依赖另一个对象的能力。
使用接口编写更加灵活，能委托别人实现细节。
性状 trait 性状是类的部分实现，可以混入一个或者多个现有的 PHP 类中。性状有两个作用：表明类可以做什么（像是接口）；提供模块化实现（像是类）。
如果想让两个无关的 PHP 类具有类似的行为，应该怎么呢？性状就是为了解决这种问题而诞生的。性状能把模块化的实现方式注入多个无关的类中。而且性状还能促进代码的重用。
这与创建一个接口，两个无关的类实现这个接口的优势在于：不用写相同的实现代码，符合 DRY 原则。
PHP 解释器在编译时会把性状复制粘贴到类的定义体中，但是不会处理这个操作引入的不兼容问题。如果性状假定类中有特定的属性和方法（在性状中没有定义），要确保相应的类中有对应的属性和方法。
生成器 Generator 是 PHP 5.5.0 引入的功能。生成器是简单的迭代器，仅此而已。
PHP 生成器不要求类实现 Iterator 接口，从而减轻了类的负担。生成器会根据需求计算并产生要迭代的值。这对应该的性能有重大影响。假如标准的 PHP 迭代器经常在内存中执行迭代操作，这要预先计算出数据集，性能低；此时我们可以使用生成器，即时计算并产出后续值，不占用宝贵的内存资源。
PHP 生成器不能满足所有迭代操作的需求，因为如果不查询，生成器永远不知道下一个要迭代的值是什么，在生成器中无法后退和快进。生成器还是一次性，无法多次迭代同一个生成器。不过，如果需要，可以重建或克隆生成器。
PHP 生成器是 PHP 函数，只不过要在函数中一次或者多次使用 yield 关键字。生成器从不返回值，值产出值。
function myGenerator() { yield 'value1'; yield 'value2'; yield 'value3'; } foreach (myGenerator() as $yieldedValue) { echo $yieldedValue, PHP_EOL; } value1 value2 value3 使用生成器处理 CSV：
...</p></div><footer class=entry-footer><span title='2018-05-08 17:00:00 +0800 CST'>May 8, 2018</span>&nbsp;·&nbsp;<span>3 min</span>&nbsp;·&nbsp;<span>572 words</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to 【Modern PHP】笔记" href=https://zyf.im/2018/05/08/modern-php-reading-notes/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>PhpStorm 使用经验</h2></header><div class=entry-content><p>Getting Started Two shortcuts to get started
Shift+Shift(⇧+⇧) helps you find anything within your project. Alt+Enter(Option+Enter) provides instant access to contextual actions and quick fixes relevant to the selected code. Getting started with PHP in PhpStorm
还有个 One Dark theme 但是 Material Theme UI 已经包含这个主题。
配置：
Preferences > Appearance & Behavior > Appearance 下，右侧配置：Theme: Darcula，勾选 User custom font: .AppleSystemUIFont Size: 18。
Preferences > Editor > Font 下，右侧配置：Font: Menlo Size: 18 Line spacing: 1.2。
...</p></div><footer class=entry-footer><span title='2018-05-05 14:00:00 +0800 CST'>May 5, 2018</span>&nbsp;·&nbsp;<span>3 min</span>&nbsp;·&nbsp;<span>433 words</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to PhpStorm 使用经验" href=https://zyf.im/2018/05/05/phpstorm-using-experience/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>使用 Certbot 获取 Let’s Encrypt 颁发的 TLS 证书</h2></header><div class=entry-content><p>Certbot 和 Let’s Encrypt 的关系 Let’s Encrypt 一个免费、自动化、开放的公共证书颁发机构（CA）。 通过 ACME（Automatic Certificate Management Environment）协议向域名所有者颁发 DV（Domain Validation）TLS/SSL 证书。 Certbot 由 Electronic Frontier Foundation (EFF) 维护的开源 ACME 客户端。 主要目标是简化与 Let’s Encrypt 之间的交互： 自动化域名验证（HTTP-01、DNS-01、TLS-ALPN-01 等） 安装并续期证书 更新 Web 服务器配置（Apache、Nginx、Lighttpd 等） Certbot 也能与任何兼容 ACME 的 CA 通信，不限于 Let’s Encrypt。 典型工作流程 解析参数并检测服务器类型。 选择并执行挑战（例如在 /.well-known/acme-challenge/ 下写入 token）。 Let’s Encrypt 回访验证域名归属。 验证通过后签发证书；Certbot 下载并安装到本地。 创建定时任务 certbot renew 自动续期。 开始实验 实验环境：Amazon Linux 2023 (AL2023)
知识补充 dnf（Dandified YUM） 是 RPM-系 Linux 发行版的下一代包管理器。它在功能上取代了传统的 yum，两者命令参数几乎保持兼容。 RPM 一开始叫 Red Hat Package Manager，后来改名为递归含义的 RPM Package Manager。 RPM-系发行版 是把 RPM 作为原生软件包格式与核心包管理工具链的那一族 Linux 发行版。常听到的 Fedora / RHEL / CentOS / AlmaLinux / Rocky Linux / openSUSE / SUSE Linux Enterprise / Amazon Linux 2023 等。 dnf 不是对 rpm CLI 的简单封装，而是调用 librpm 完成最终操作。 包管理器 代表发行版 归属 dnf / yum Fedora, RHEL, CentOS RPM zypper openSUSE, SLE RPM apt / apt-get Debian, Ubuntu DEB pacman Arch Linux tar.xz apk Alpine .apk snap 是一种由 Canonical（Ubuntu 的开发公司）推出的跨发行版应用打包和分发格式，也指围绕它的一整套生态系统。 跨发行版。同一个 snap 包可以在几十种发行版上直接安装运行，不依赖各自的 RPM/Deb 系统仓库。 自包含（bundled）依赖。snap 包内部包含所有依赖，无需外部安装。 https://snapcraft.io/ Launch an AWS EC2 instance Instance type: t2.nano Username: ec2-user Security Groups: Allow HTTP and HTTPS Public IPv4: 35.86.90.4 配置 nginx sudo dnf update -y sudo dnf install -y nginx nginx -v # nginx version: nginx/1.28.0 sudo systemctl start nginx sudo systemctl enable nginx systemctl status nginx # Started nginx.service - The nginx HTTP and reverse proxy server. 直接通过 http://35.86.90.4，会看到默认的 nginx 欢迎页面。
...</p></div><footer class=entry-footer><span title='2018-04-26 16:00:00 +0800 CST'>April 26, 2018</span>&nbsp;·&nbsp;<span>5 min</span>&nbsp;·&nbsp;<span>914 words</span>&nbsp;·&nbsp;<span>Me, LLM</span></footer><a class=entry-link aria-label="post link to 使用 Certbot 获取 Let’s Encrypt 颁发的 TLS 证书" href=https://zyf.im/2018/04/26/lets-encrypt-wildcard-certificates/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Swift 初始化</h2></header><div class=entry-content><p>因为自己是直接从 Swift 进入的 iOS 开发，Swift 与 Objective-C 初始化的对比就不多提了。感觉上 Swift 初始化的方式像 Java，自己也只是这样套着 Java 去理解，但也发现了不相同的地方。
初始化顺序 class Blog: NSObject { let param: String override init() { } } 这里有一条错误 error: property 'self.param' not initialized at implicitly generated super.init call，说明 param 参数没有在隐式生成 super.init 调用之前完成初始化。
Swift 中并不是不调用 super.init，而是为了方便开发者，由编译器完成了这一步。但要求在调用 super.init 之前完成成员变量的初始化。
class Blog: NSObject { let param: String override init() { param = "swift init" } } 对于需要修改父类中成员变量值的情况，我们需要在调用 super.init 之后再进行修改：
class Cat { var name: String init() { name = "cat" } } class Tiger: Cat { let power: Int override init() { power = 10 super.init() name = "tiger" } } Swift 中类的初始化顺序：
...</p></div><footer class=entry-footer><span title='2018-03-31 17:00:00 +0800 CST'>March 31, 2018</span>&nbsp;·&nbsp;<span>5 min</span>&nbsp;·&nbsp;<span>969 words</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Swift 初始化" href=https://zyf.im/2018/03/31/swift-init/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>【Git 权威指南】读书笔记 - 协同模型</h2></header><div class=entry-content><p>主要内容：【Git 协同模型】
经典 Git 协同模型 集中式协同模型 可以像集中式版本控制系统那样使用 Git，在一个大家都可以访问到的服务器上架设 Git 服务器，每个人从该服务器克隆代码，本地提交推送到服务器上。
金字塔式协同模型 虽然理论上每个开发者的版本库都是平等的，但是会有一个公认的权威的版本库，这个版本库由一个或者多个核心开发者负责维护（具有推送的权限）。
开源社区逐渐发展出金字塔模型，而这也是必然之选。
Topgit 协同模型 笔者注：Topgit 是否已经过时？
卖主分支 Vendor Branch 是在版本库中专门创建一个和上游同步的分支，一旦有上游代码发布就捡入到卖主分支中。
子模组协同模型 创建子模组 git submodule add /path/to/repos/libA.git lib/lib_a .gitmodules 的内容：
cat .gitmodules [submodule "lib/lib_a"] path = lib/lib_a url = /path/to/repos/libA.git 克隆带子模组的版本库 git clone /path/to/repos/super.git /path/to/my/workspace/super-clone 子模组的版本库并不会默认克隆，如果需要克隆出子模组型式引用的外部库，需要执行：
git submodule init git submodule update 在子模组中修改和子模组的更新 修改更新的方式和普通仓库一样。如果修改了子模块，要先推送子模块的修改，再推送主仓库，以防止其他人克隆 super 版本库、更新模组时因为找不到该子模组版本库相应的提交而导致出错。
查看子模组状态：
git submodule status 子树合并 引入外部版本库 # 注册外部版本库 git remote add util /path/to/repos/util.git git fetch util # 查看所有分支 git branch -a # 从 util/master 远程分支创建一个本地分支 util-branch git checkout -b util-branch util/master 子目录方式合并外部版本库 # 在主分支，将分支 util-branch 读取到当前分支的一个子目录下 git read-tree --prefix=lib util-branch # 将 lib 目录下的文件更新出来 git checkout -- lib 现在还不能忙着提交，因为如果现在进行提交就体现不出来两个分支的合并关系。需要使用 Git 底层的命令进行数据提交。
...</p></div><footer class=entry-footer><span title='2018-01-19 14:00:00 +0800 CST'>January 19, 2018</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>339 words</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to 【Git 权威指南】读书笔记 - 协同模型" href=https://zyf.im/2018/01/19/got-git-reading-notes-model/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>【Git 权威指南】读书笔记 - 和声</h2></header><div class=entry-content><p>主要内容：【Git 协议与工作协同】、【冲突解决】、【Git 里程碑】、【Git 分支】、【远程版本库】、【补丁文件交互】
Git 协议与工作协同 Git 支持的协议 SSH、GIT、HTTP、HTTPS、FTP、FTPS、RSYNC 及前面已经看到的本地协议。
SSH 协议：
ssh://[user@]example.com[:port]/path/to/repo.git/ [user@]example.com:path/to/repo.git/ GIT 协议，最常用的只读协议：
git://example.com[:port]/path/to/repo.git/ HTTP[S] 协议：
http[s]://example.com[:port]/path/to/repo.git/ 强制非快进式推送 git push -f 强制推送，会强制刷新服务器中的版本。
禁止非快进式推送 git --git-dir=/path/to/repos/shared.git config receive.denyNonFastForwards true 冲突解决 拉回操作中的合并 git pull = git fetch + git merge 合并策略 Merge Strategis
Git 合并操作支持很多合并策略，默认会选择最适合的合并策略。例如，和一个分支进行合并时会选择 recursive 合并策略，当和两个或两个以上的其他分支进行合并时采用 octopus 合并策略。
git merge [-s &lt;strategy>] [-X &lt;strategy-option>] [&lt;commit>...] This option forces conflicting hunks to be auto-resolved cleanly by favoring our version.
git merge -s recursive -X ours [&lt;commit>...] Merge branch obsolete into the current branch, using ours merge strategy:
...</p></div><footer class=entry-footer><span title='2018-01-17 19:00:00 +0800 CST'>January 17, 2018</span>&nbsp;·&nbsp;<span>3 min</span>&nbsp;·&nbsp;<span>469 words</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to 【Git 权威指南】读书笔记 - 和声" href=https://zyf.im/2018/01/17/got-git-reading-notes-harmony/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://zyf.im/page/7/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://zyf.im/page/9/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2026 <a href=https://zyf.im/>ZYF.IM BLOG</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>