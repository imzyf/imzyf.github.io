<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>正则表达式 | ZYF.IM BLOG</title>
<meta name=keywords content="regular-expression"><meta name=description content="00

regex101
regulex
ihateregex

01 元字符
正则表达式 —— 字符串的规则。
元字符就是指那些在正则表达式中具有特殊意义的专用字符。

特殊单字符

. 任意字符（换行除外）
\d 任意数字 \D 任意非数字
\w A-Za-z0-9_ \W
\s 空白符 \S


空白符

\r 回车符
\n 换行符
\f 换页符
\t 制表符
\v 垂直制表符


范围

| 或
[abc] 多选一
[a-z] 之间
[^abc] 取反，不能是括号中的任意单个元素


量词

* 0<=
+ 1<=
? 0或1
{m} m
{m,} m<=
{m,n} m-n



02 量词与贪婪
贪婪(Greedy) *：匹配最长。在贪婪量词模式下，正则表达式会尽可能长地去匹配符合规则的字符串，且会回溯。
preg_match_all(&#34;/a*/i&#34;, &#34;aaabb&#34;, $matches);
var_dump($matches);
非贪婪(Reluctant) +?：匹配最短。在非贪婪量词模式下，正则表达式会匹配尽可能短的字符串。
ENV：Python3
import re
re.findall(r'a*', 'aaabb') # 贪婪模式
# ['aaa', '', '', '']
re.findall(r'a*?', 'aaabb') # 非贪婪模式
# ['', 'a', '', 'a', '', 'a', '', '', '']

re.findall(r'&#34;.+&#34;', '&#34;the little cat&#34; is a toy, it lokks &#34;a little bad&#34;') # 贪婪模式
# ['&#34;the little cat&#34; is a toy, it lokks &#34;a little bad&#34;']
re.findall(r'&#34;.+?&#34;', '&#34;the little cat&#34; is a toy, it lokks &#34;a little bad&#34;') # 非贪婪模式
# ['&#34;the little cat&#34;', '&#34;a little bad&#34;']
独占模式(Possessive) ++：同贪婪一样匹配最长。不过在独占量词模式下，正则表达式尽可能长地去匹配字符串，一旦匹配不成功就会结束匹配而 不会回溯。"><meta name=author content="Me"><link rel=canonical href=https://zyf.im/2023/03/01/regular-expression-getting-started/><link crossorigin=anonymous href=/assets/css/stylesheet.eb010ba19da259e1633d31a246087e3b0656d556c30406763ea24160333d238f.css integrity="sha256-6wELoZ2iWeFjPTGiRgh+OwZW1VbDBAZ2PqJBYDM9I48=" rel="preload stylesheet" as=style><link rel=icon href=https://zyf.im/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zyf.im/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://zyf.im/favicon-32x32.png><link rel=apple-touch-icon href=https://zyf.im/apple-touch-icon.png><link rel=mask-icon href=https://zyf.im/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://zyf.im/2023/03/01/regular-expression-getting-started/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-6DVZ6E58DG"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-6DVZ6E58DG")}</script><meta property="og:url" content="https://zyf.im/2023/03/01/regular-expression-getting-started/"><meta property="og:site_name" content="ZYF.IM BLOG"><meta property="og:title" content="正则表达式"><meta property="og:description" content="00 regex101 regulex ihateregex 01 元字符 正则表达式 —— 字符串的规则。
元字符就是指那些在正则表达式中具有特殊意义的专用字符。
特殊单字符 . 任意字符（换行除外） \d 任意数字 \D 任意非数字 \w A-Za-z0-9_ \W \s 空白符 \S 空白符 \r 回车符 \n 换行符 \f 换页符 \t 制表符 \v 垂直制表符 范围 | 或 [abc] 多选一 [a-z] 之间 [^abc] 取反，不能是括号中的任意单个元素 量词 * 0<= + 1<= ? 0或1 {m} m {m,} m<= {m,n} m-n 02 量词与贪婪 贪婪(Greedy) *：匹配最长。在贪婪量词模式下，正则表达式会尽可能长地去匹配符合规则的字符串，且会回溯。
preg_match_all(&#34;/a*/i&#34;, &#34;aaabb&#34;, $matches); var_dump($matches); 非贪婪(Reluctant) +?：匹配最短。在非贪婪量词模式下，正则表达式会匹配尽可能短的字符串。
ENV：Python3
import re re.findall(r'a*', 'aaabb') # 贪婪模式 # ['aaa', '', '', ''] re.findall(r'a*?', 'aaabb') # 非贪婪模式 # ['', 'a', '', 'a', '', 'a', '', '', ''] re.findall(r'&#34;.+&#34;', '&#34;the little cat&#34; is a toy, it lokks &#34;a little bad&#34;') # 贪婪模式 # ['&#34;the little cat&#34; is a toy, it lokks &#34;a little bad&#34;'] re.findall(r'&#34;.+?&#34;', '&#34;the little cat&#34; is a toy, it lokks &#34;a little bad&#34;') # 非贪婪模式 # ['&#34;the little cat&#34;', '&#34;a little bad&#34;'] 独占模式(Possessive) ++：同贪婪一样匹配最长。不过在独占量词模式下，正则表达式尽可能长地去匹配字符串，一旦匹配不成功就会结束匹配而 不会回溯。"><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-03-01T15:31:15+00:00"><meta property="article:modified_time" content="2023-03-01T15:31:15+00:00"><meta property="article:tag" content="Regular-Expression"><meta property="og:image" content="https://images.unsplash.com/photo-1548588627-f978862b85e1?ixlib=rb-4.0.3&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=960&amp;q=80"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://images.unsplash.com/photo-1548588627-f978862b85e1?ixlib=rb-4.0.3&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=960&amp;q=80"><meta name=twitter:title content="正则表达式"><meta name=twitter:description content="00

regex101
regulex
ihateregex

01 元字符
正则表达式 —— 字符串的规则。
元字符就是指那些在正则表达式中具有特殊意义的专用字符。

特殊单字符

. 任意字符（换行除外）
\d 任意数字 \D 任意非数字
\w A-Za-z0-9_ \W
\s 空白符 \S


空白符

\r 回车符
\n 换行符
\f 换页符
\t 制表符
\v 垂直制表符


范围

| 或
[abc] 多选一
[a-z] 之间
[^abc] 取反，不能是括号中的任意单个元素


量词

* 0<=
+ 1<=
? 0或1
{m} m
{m,} m<=
{m,n} m-n



02 量词与贪婪
贪婪(Greedy) *：匹配最长。在贪婪量词模式下，正则表达式会尽可能长地去匹配符合规则的字符串，且会回溯。
preg_match_all(&#34;/a*/i&#34;, &#34;aaabb&#34;, $matches);
var_dump($matches);
非贪婪(Reluctant) +?：匹配最短。在非贪婪量词模式下，正则表达式会匹配尽可能短的字符串。
ENV：Python3
import re
re.findall(r'a*', 'aaabb') # 贪婪模式
# ['aaa', '', '', '']
re.findall(r'a*?', 'aaabb') # 非贪婪模式
# ['', 'a', '', 'a', '', 'a', '', '', '']

re.findall(r'&#34;.+&#34;', '&#34;the little cat&#34; is a toy, it lokks &#34;a little bad&#34;') # 贪婪模式
# ['&#34;the little cat&#34; is a toy, it lokks &#34;a little bad&#34;']
re.findall(r'&#34;.+?&#34;', '&#34;the little cat&#34; is a toy, it lokks &#34;a little bad&#34;') # 非贪婪模式
# ['&#34;the little cat&#34;', '&#34;a little bad&#34;']
独占模式(Possessive) ++：同贪婪一样匹配最长。不过在独占量词模式下，正则表达式尽可能长地去匹配字符串，一旦匹配不成功就会结束匹配而 不会回溯。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zyf.im/posts/"},{"@type":"ListItem","position":2,"name":"正则表达式","item":"https://zyf.im/2023/03/01/regular-expression-getting-started/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"正则表达式","name":"正则表达式","description":"00 regex101 regulex ihateregex 01 元字符 正则表达式 —— 字符串的规则。\n元字符就是指那些在正则表达式中具有特殊意义的专用字符。\n特殊单字符 . 任意字符（换行除外） \\d 任意数字 \\D 任意非数字 \\w A-Za-z0-9_ \\W \\s 空白符 \\S 空白符 \\r 回车符 \\n 换行符 \\f 换页符 \\t 制表符 \\v 垂直制表符 范围 | 或 [abc] 多选一 [a-z] 之间 [^abc] 取反，不能是括号中的任意单个元素 量词 * 0\u0026lt;= + 1\u0026lt;= ? 0或1 {m} m {m,} m\u0026lt;= {m,n} m-n 02 量词与贪婪 贪婪(Greedy) *：匹配最长。在贪婪量词模式下，正则表达式会尽可能长地去匹配符合规则的字符串，且会回溯。\npreg_match_all(\u0026#34;/a*/i\u0026#34;, \u0026#34;aaabb\u0026#34;, $matches); var_dump($matches); 非贪婪(Reluctant) +?：匹配最短。在非贪婪量词模式下，正则表达式会匹配尽可能短的字符串。\nENV：Python3\nimport re re.findall(r\u0026#39;a*\u0026#39;, \u0026#39;aaabb\u0026#39;) # 贪婪模式 # [\u0026#39;aaa\u0026#39;, \u0026#39;\u0026#39;, \u0026#39;\u0026#39;, \u0026#39;\u0026#39;] re.findall(r\u0026#39;a*?\u0026#39;, \u0026#39;aaabb\u0026#39;) # 非贪婪模式 # [\u0026#39;\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;\u0026#39;, \u0026#39;\u0026#39;, \u0026#39;\u0026#39;] re.findall(r\u0026#39;\u0026#34;.+\u0026#34;\u0026#39;, \u0026#39;\u0026#34;the little cat\u0026#34; is a toy, it lokks \u0026#34;a little bad\u0026#34;\u0026#39;) # 贪婪模式 # [\u0026#39;\u0026#34;the little cat\u0026#34; is a toy, it lokks \u0026#34;a little bad\u0026#34;\u0026#39;] re.findall(r\u0026#39;\u0026#34;.+?\u0026#34;\u0026#39;, \u0026#39;\u0026#34;the little cat\u0026#34; is a toy, it lokks \u0026#34;a little bad\u0026#34;\u0026#39;) # 非贪婪模式 # [\u0026#39;\u0026#34;the little cat\u0026#34;\u0026#39;, \u0026#39;\u0026#34;a little bad\u0026#34;\u0026#39;] 独占模式(Possessive) ++：同贪婪一样匹配最长。不过在独占量词模式下，正则表达式尽可能长地去匹配字符串，一旦匹配不成功就会结束匹配而 不会回溯。\n","keywords":["regular-expression"],"articleBody":"00 regex101 regulex ihateregex 01 元字符 正则表达式 —— 字符串的规则。\n元字符就是指那些在正则表达式中具有特殊意义的专用字符。\n特殊单字符 . 任意字符（换行除外） \\d 任意数字 \\D 任意非数字 \\w A-Za-z0-9_ \\W \\s 空白符 \\S 空白符 \\r 回车符 \\n 换行符 \\f 换页符 \\t 制表符 \\v 垂直制表符 范围 | 或 [abc] 多选一 [a-z] 之间 [^abc] 取反，不能是括号中的任意单个元素 量词 * 0\u003c= + 1\u003c= ? 0或1 {m} m {m,} m\u003c= {m,n} m-n 02 量词与贪婪 贪婪(Greedy) *：匹配最长。在贪婪量词模式下，正则表达式会尽可能长地去匹配符合规则的字符串，且会回溯。\npreg_match_all(\"/a*/i\", \"aaabb\", $matches); var_dump($matches); 非贪婪(Reluctant) +?：匹配最短。在非贪婪量词模式下，正则表达式会匹配尽可能短的字符串。\nENV：Python3\nimport re re.findall(r'a*', 'aaabb') # 贪婪模式 # ['aaa', '', '', ''] re.findall(r'a*?', 'aaabb') # 非贪婪模式 # ['', 'a', '', 'a', '', 'a', '', '', ''] re.findall(r'\".+\"', '\"the little cat\" is a toy, it lokks \"a little bad\"') # 贪婪模式 # ['\"the little cat\" is a toy, it lokks \"a little bad\"'] re.findall(r'\".+?\"', '\"the little cat\" is a toy, it lokks \"a little bad\"') # 非贪婪模式 # ['\"the little cat\"', '\"a little bad\"'] 独占模式(Possessive) ++：同贪婪一样匹配最长。不过在独占量词模式下，正则表达式尽可能长地去匹配字符串，一旦匹配不成功就会结束匹配而 不会回溯。\n# 回溯示例： import re re.findall(r'xy{1,3}z', 'xyyz') # 回溯 # ['xyyz'] # 正则 xy{1,3} 会尽可能长地去匹配到 xyyz，无法匹配 z，向前回溯 xyy # 正则 z 匹配到剩下字符串 z re.findall(r'xy{1,3}?z', 'xyyz') # 非贪婪 # ['xyyz'] # 正则 xy{1,3} 会尽可能短地去匹配到 xy # 正则 z 匹配到字符串 y，无法匹配，向前回溯 # 正则 xy{1,3} 会尽可能短地去匹配 xyy # 正则 z 匹配到剩下字符串 z # 独占模式示例： # pip install regex -i https://mirrors.aliyun.com/pypi/simple/ import regex regex.findall(r'xy{1,3}+z', 'xyyz') # 独占 # ['xyyz'] # 正则 xy{1,3}+ 会尽可能长地去匹配到 xyy 并占用 # 正则 z 匹配到字符串 z regex.findall(r'xy{1,3}+yz', 'xyyz') # 独占 # [] # 正则 xy{1,3}+ 会尽可能长地去匹配到 xyy 并占用 # 正则 yz 无法匹配到剩下字符串 z 03 分组与引用 import regex # 不保存分组 (?:正则) regex.sub(r'(\\d{4})-(?:\\d{2})-(\\d{2})', r\"年：\\1 日：\\2\", '2023-03-01') # '年：2023 日：01' # 去除重复连续单词 regex.sub(r'(\\w+)(\\s\\1)+', r\"\\1\", 'the little cat cat is in the hat hat hat, we like it.') # 'the little cat is in the hat, we like it.' 04 匹配模式 指改变元字符匹配行为。\n不区分大小写模式（Case-Insensitive）(?模式标识) (?i)。\nimport regex regex.findall(r\"(?i)cat\", \"cat Cat CAt\") # ['cat', 'Cat', 'CAt'] # https://regex101.com/r/3OUJda/1 # 二次重复时的大小写一致 ((?i)cat) \\1 点号通配模式（Dot All）(?s) 让英文的点 . 可以匹配上包括换行的任何字符。等价 [\\s\\S] [\\d\\D] [\\w\\W]。\n# https://regex101.com/r/zXtwLv/1 # 匹配包括换行符 (?s).+ 多行匹配模式（Multiline）(?m) 使 ^ 和 $ 能匹配上每行的开头或结尾。\n# 分行匹配 (?m)^cat|dog$ 注释模式（Comment）(?#)\n(\\w+)(?#word) \\1(?#word repeat again) 05 断言 Assertion 对要匹配的文本的位置也有一定的要求。只用于匹配位置，而不是文本内容本身，这种结构就是断言。\n边界（Boundary）\nimport re # 单词边界 \\b # tom -\u003e jerry, tomorrow 不受影响 re.sub(r'\\btom\\b', 'jerry', \"tom asked me if I would go fishing with him tomorrow.\") # 'jerry asked me if I would go fishing with him tomorrow.' # 行的开始结束 # \\A \\z 不受模式影响 # \\A -\u003e ^, \\z -\u003e $ re.sub(r'\\Atom', 'jerry', \"tom asked me if I would go fishing with him tomorrow.\") # 环视 左尖括号代表看左边，没有尖括号是看右边，感叹号是非的意思 # (?\u003c=Y) 左边是Y # (?\u003c!Y) 左边不是Y # (?=Y) 右边是Y # (?!Y) 右边不是Y re.findall(r'[1-9]\\d{5}', \"138001380002\") # ['138001', '380002'] re.findall(r'(?\u003c!\\d)[1-9]\\d{5}(?!\\d)', \"138001380002\") # 左边不是数字、右边不是数字 # [] re.findall(r'(?\u003c!\\d)[1-9]\\d{5}(?!\\d)', \"code138001code\") # 左边不是数字、右边不是数字 # ['138001'] # \\b\\w+\\b -\u003e (?\u003c!\\w)\\w+(?!\\w) -\u003e (?\u003c=\\W)\\w+(?=\\W) # https://regex101.com/r/PBEKxY/1 # (\\w+)(\\s+\\b\\1\\b)+ # 单词，单词的左边是单词边界、可以有一个及以上空格，右边是单词边界 # 比 (\\w+)(\\s+\\1)+ 更严谨 eg: the little cat cat2 is in the hat hat2 06 转义 转义字符 Escape Character 后面的字符，不是原来的意思了。\nimport re re.findall(r'\\\\d', 'abc\\\\d123d\\\\') # ['\\\\d'] re.findall('\\\\', 'a*b+c?\\\\d123d\\\\') # bad escape (end of pattern) at position 0 re.findall('\\\\\\\\', 'a*b+c?\\\\d123d\\\\') # ['\\\\', '\\\\'] # 字符串-\u003e正则表达式：字符串转义和正则转义 # \\\\\\\\ 字符串转义 \\\\ # \\\\ 正则转义 \\ re.findall(r'\\\\', 'a*b+c?\\\\d123d\\\\') # ['\\\\', '\\\\'] re.findall('\\(\\)\\[]\\{}', '()[]{}') # ['()[]{}'] # 方括号和花括号的转义一般转义开括号就可以，但圆括号两个都需要转义 import re re.escape('\\d') # 反斜杠和字母d转义 # '\\\\\\\\d' re.findall(re.escape('\\d'), '\\d') # ['\\\\d'] re.escape('[+]') # '\\\\[\\\\+\\\\]' re.findall(re.escape('[+]'), '[+]') # ['[+]'] import re re.findall(r'[^ab]', '^ab') # 转义前代表\"非\" # ['^'] re.findall(r'[^cd]', '^ab') # ['^', 'a', 'b'] re.findall(r'[\\^ab]', '^ab') # 转义后代表普通字符 # ['^', 'a', 'b'] re.findall(r'[a-c]', 'abc-') # 中划线在中间，代表\"范围\" # ['a', 'b', 'c'] re.findall(r'[a\\-c]', 'abc-') # 中划线在中间，转义后的 re.findall(r'[-ac]', 'abc-') # 在开头，不需要转义 re.findall(r'[ac-]', 'abc-') # 在结尾，不需要转义 # ['a', 'c', '-'] re.findall(r'[]ab]', ']ab') # 右括号不转义，在首位 # [']', 'a', 'b'] re.findall(r'[a]b]', ']ab') # 右括号不转义，不在首位 # [] re.findall(r'[a\\]b]', ']ab') # 转义后代表普通字符 # [']', 'a', 'b'] re.findall(r'[.*+?()]', '[.*+?()]') # 单个长度的元字符在中括号里，可以不转义 # ['.', '*', '+', '?', '(', ')'] re.findall(r'[\\d]', 'd12\\\\') # \\w，\\d等在中括号中还是元字符的功能 # ['1', '2'] import re re.findall('\\n', '\\\\n\\n\\\\') # ['\\n'] \\n -\u003e (\\n) -\u003e (\\n) re.findall('\\\\n', '\\\\n\\n\\\\') # ['\\n'] \\\\n -\u003e \\n -\u003e (\\n) re.findall('\\\\\\n', '\\\\n\\n\\\\') # ['\\n'] \\\\\\n -\u003e \\n -\u003e (\\n) re.escape('\\n') # '\\\\\\n' re.findall('\\\\\\\\n', '\\\\n\\n\\\\') # ['\\\\n'] \\\\\\\\n -\u003e \\\\\\n -\u003e \\(\\n) re.escape('\\\\n') # '\\\\\\\\n' 07 流派及其特性 POSIX Portable Operating System Interface。不能使用 \\d。 BRE Basic Regular Expression 基本正则表达式。grep sed 花园问管家 {}()?|+ 要转义。 ERE Extended Regular Expression 扩展正则表达式。egrep grep -E sed -E。 PCRE Perl Compatible Regular Expressions。可以使用 \\d \\w \\s。grep -P sed -P。 grep --help | grep PATTERN # PATTERN is, by default, a basic regular expression (BRE). # -E, --extended-regexp PATTERN is an extended regular expression (ERE) # -F, --fixed-strings PATTERN is a set of newline-separated fixed strings # -G, --basic-regexp PATTERN is a basic regular expression (BRE) # -P, --perl-regexp PATTERN is a Perl regular expression Linux/Unix 工具与正则表达式的 POSIX 规范 | 余晟\n08 处理 Unicode 文本 Unicode 相当于规定了字符对应的码值，这个码值得编码成字节的形式去传输和存储。最常见的编码方式是 UTF-8，另外还有 UTF-16，UTF-32 等。UTF-8 之所以能够流行起来，是因为其编码比较巧妙，采用的是变长的方法。也就是一个 Unicode 字符，在使用 UTF-8 编码表示时占用 1 到 4 个字节不等。最重要的是 Unicode 兼容 ASCII 编码，在表示纯英文时，并不会占用更多存储空间。而汉字呢，在 UTF-8 中，通常是用三个字节来表示。\n# python2.7 import re u'极客'.encode('utf-8') # '\\xe6\\x9e\\x81\\xe5\\xae\\xa2' u'时间'.encode('utf-8') # '\\xe6\\x97\\xb6\\xe9\\x97\\xb4' # 都含有 e6 re.search(r'[时间]', '极客') is not None # True re.compile(r'[时间]', re.DEBUG) # in # literal 230 # literal 151 # literal 182 # literal 233 # literal 151 # literal 180 # \u003c_sre.SRE_Pattern object at 0x10ab44d78\u003e re.compile(r'[极客]', re.DEBUG) # in # literal 230 # literal 158 # literal 129 # literal 229 # literal 174 # literal 162 # \u003c_sre.SRE_Pattern object at 0x10ab44e40\u003e re.compile(ur'[时间]', re.DEBUG) # in # literal 26102 # literal 38388 # \u003c_sre.SRE_Pattern object at 0x10ac02710\u003e re.search(ur'[时间]', '时间') is not None False re.search(ur'[时间]', u'时间') is not None True # python2.7 import re re.findall(r'^.$', '学') # [] re.findall(r'^.$', u'学') # [u'\\u5b66'] re.findall(ur'^.$', u'学') # [u'\\u5b66'] print(unichr(0x5B66)) # 学 # python3 import re re.findall(r'^.$', '学') # ['学'] re.findall(r'(?a)^.$', '学') # ['学'] # (?a) 表示启用 ASCII 模式 chr(0x5B66) # '学' // 可以匹配汉语 in PHP \\p{Han} # python2.7 import re re.findall(r'客{3}', '极客客客客') # [] re.findall(ur'客{3}', '极客客客客') # [] re.findall(r'客{3}', u'极客客客客') # [] re.findall(ur'客{3}', u'极客客客客') # [u'\\u5ba2\\u5ba2\\u5ba2'] re.findall(r'(客){3}', '极客客客客') # python3 re.findall(r'客{3}', '极客客客客') # ['客客客'] # 在 Python3 中，不需要在正则表达式字符串前面添加 u 前缀，因为所有字符串都默认为 Unicode 字符串。 Script (Unicode) | wikipedia 09 编辑器中使用正则 竖向编辑：MacOS alt + 鼠标纵向滑动。\n10 语言中用正则 校验文本内容：\nimport re reg = re.compile(r'\\A\\d{4}-\\d{2}-\\d{2}\\Z') # 建议先编译，提高效率 reg.search('2020-06-01') is not None # True reg.match('2020-06-01') is not None # 使用 match 时 \\A 可省略，match 就是从头匹配 # True reg = re.compile(r'\\d{4}-\\d{2}') reg.findall('2020-05 2020-06') # ['2020-05', '2020-06'] /^\\d{4}-\\d{2}-\\d{2}$/.test(\"2020-06-01\") // true var regex = new RegExp(/^\\d{4}-\\d{2}-\\d{2}$/) regex.test(\"2020-01-01\") // true var regex = /^\\d{4}-\\d{2}-\\d{2}$/ \"2020-06-01\".search(regex) // 0 $regex = '/^\\d{4}-\\d{2}-\\d{2}$/'; $ret = preg_match($regex, \"2020-06-01\"); var_dump($ret); // int(1) 提取文本内容：\nimport re # 没有子组时 reg = re.compile(r'\\d{4}-\\d{2}') reg.findall('2020-05 2020-06') # ['2020-05', '2020-06'] # 有子组时 reg = re.compile(r'(\\d{4})-(\\d{2})') reg.findall('2020-05 2020-06') [('2020', '05'), ('2020', '06')] reg = re.compile(r'(\\d{4})-(\\d{2})') for match in reg.finditer('2020-05 2020-06'): print('date: ', match[0]) # 整个正则匹配到的内容 print('year: ', match[1]) # 第一个子组 print('month:', match[2]) # 第二个子组 # date: 2020-05 # year: 2020 # month: 05 # date: 2020-06 # year: 2020 # month: 06 // 使用g模式，查找所有符合要求的内容 \"2020-06 2020-07\".match(/\\d{4}-\\d{2}/g) // ['2020-06', '2020-07'] // 不使用g模式，找到第一个就会停下来 \"2020-06 2020-07\".match(/\\d{4}-\\d{2}/) // ['2020-06', index: 0, input: '2020-06 2020-07', groups: undefined] $regex = \"/\\d{4}-\\d{2}/\"; $str = \"2020-05 2020-04\"; $matchs = []; preg_match_all($regex, $str, $matchs, PREG_SET_ORDER); var_dump($matchs); // array(2) { // [0] =\u003e // array(1) { // [0] =\u003e // string(7) \"2020-05\" // } // [1] =\u003e // array(1) { // [0] =\u003e // string(7) \"2020-04\" // } // } // PREG_PATTERN_ORDER: 结果排序为$matches[0]保存完整模式的所有匹配, $matches[1]保存第一个子组的所有匹配，以此类推。 // PREG_SET_ORDER: 结果排序为$matches[0]包含第一次匹配得到的所有匹配(包含子组)，$matches[1]是包含第二次匹配到的所有匹配(包含子组)的数组，以此类推。 替换文本内容：\nreg = re.compile(r'(\\d{2})-(\\d{2})-(\\d{4})') reg.sub(r'\\3年\\1月\\2日', '02-20-2020 05-21-2020') # '2020年02月20日 2020年05月21日' # 可以在替换中使用 \\g\u003c数字\u003e，如果分组多于10个时避免歧义 reg.sub(r'\\g\u003c3\u003e年\\g\u003c1\u003e月\\g\u003c2\u003e日', '02-20-2020 05-21-2020') # '2020年02月20日 2020年05月21日' # 返回替换次数 reg.subn(r'\\3年\\1月\\2日', '02-20-2020 05-21-2020') # ('2020年02月20日 2020年05月21日', 2) // 使用g模式，替换所有的 \"02-20-2020 05-21-2020\".replace(/(\\d{2})-(\\d{2})-(\\d{4})/g, \"$3年$1月$2日\") // \"2020年02月20日 2020年05月21日\" // 不使用 g 模式时，只替换一次 \"02-20-2020 05-21-2020\".replace(/(\\d{2})-(\\d{2})-(\\d{4})/, \"$3年$1月$2日\") // \"2020年02月20日 05-21-2020\" $ret = preg_replace('/(\\d{2})-(\\d{2})-(\\d{4})/', '\\3年\\1月\\2日', \"02-20-2020 05-21-2020\"); var_dump($ret); // string(35) \"2020年02月20日 2020年05月21日\" 切割文本内容：\nreg = re.compile(r'\\W+') reg.split(\"apple, pear! orange; tea\") # ['apple', 'pear', 'orange', 'tea'] # 限制切割次数，比如切一刀，变成两部分 reg.split(\"apple, pear! orange; tea\", 1) # ['apple', 'pear! orange; tea'] \"apple, pear! orange; tea\".split(/\\W+/) // [\"apple\", \"pear\", \"orange\", \"tea\"] // 传入第二个参数的情况 \"apple, pear! orange; tea\".split(/\\W+/, 1) // [\"apple\"] \"apple, pear! orange; tea\".split(/\\W+/, 2) // [\"apple\", \"pear\"] \"apple, pear! orange; tea\".split(/\\W+/, 10) // [\"apple\", \"pear\", \"orange\", \"tea\"] $ret = preg_split('/\\W+/', 'apple, pear! orange; tea'); var_dump($ret); // array(4) { // [0] =\u003e // string(5) \"apple\" // [1] =\u003e // string(4) \"pear\" // [2] =\u003e // string(6) \"orange\" // [3] =\u003e // string(3) \"tea\" // } $ret = preg_split('/\\W+/', 'apple, pear! orange; tea', 2); var_dump($ret); // array(2) { // [0] =\u003e // string(5) \"apple\" // [1] =\u003e // string(17) \"pear! orange; tea\" // } 11 匹配原理以及优化原则 回溯不可怕，我们要尽量减少回溯后的判断\nimport re x = '-' * 1000000 + 'abc' timeit re.search('abc', x) 提前编译好正则。 尽量准确表示匹配范围：匹配引号里面的内容 .+? 改写为 [^\"]+。 提取出公共部分：(abcd|abxy) =\u003e ab(cd|xy)，(^this|^that) =\u003e ^th(is|at)。 出现可能性大的放左边：\\.(?:com|net)\\b。 只在必要时才使用子组：把不需要保存子组的括号中加上 ?: 来表示只用于归组。 警惕嵌套的子组重复：(.*)* 匹配的次数会呈指数级增长，尽量不要写这样的正则。 避免不同分支重复匹配。 NFA 是以表达式为主导的，先看正则表达式，再看文本。而 DFA 则是以文本为主导的，先看文本，再看正则表达式。POSIX NFA 是指符合 POSIX 标准的 NFA 引擎，它会不断回溯，以确保找到最左侧最长匹配。\n12 常见问题 import re re.match(r'^(?:(?!\\d\\d)\\w){6}$', '11abcd') # 不能匹配上 # 否定预测先行断言的语法\"(?!)\"来排除两个数字字符结尾的情况 # (?!) 表示匹配不满足某个条件的位置 re.match(r'^(?:\\w(?!\\d\\d)){6}$', '11abcd') # 错误正则示范 # # (11) 回溯 # 1(1a) ok # 11ab... ok 正负号、可二位小数、小数位末尾 0 无影响 Regulex：^[-+]?\\d+(?:\\.(?:\\d){0,2}0*)?$ 手机号码：1(?:3\\d|4[5-9]|5[0-35-9]|6[2567]|7[0-8]|8\\d|9[1389])\\d{8} 身份证：[1-9]\\d{14}(\\d\\d[0-9Xx])? 邮政编码：(?\u003c!\\d)\\d{6}(?!\\d) 中文字符：[\\u4E00-\\u9FFF] \\p{Han} 邮箱：a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+ 程语言的角度来理解正则 命令式编程的世界观是：程序是由若干行动指令组成的有序列表； 命令式编程的方法论是：用变量来存储数据，用语句来执行指令。 声明式编程的世界观是：程序是由若干目标任务组成的有序列表； 声明式编程的方法论是：用语法元素来描述任务，由解析引擎转化为指令并执行。 References 《精通正则表达式（第三版）》 《正则指引（第二版）》 – EOF –\n","wordCount":"1441","inLanguage":"en","image":"https://images.unsplash.com/photo-1548588627-f978862b85e1?ixlib=rb-4.0.3\u0026ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8\u0026auto=format\u0026fit=crop\u0026w=960\u0026q=80","datePublished":"2023-03-01T15:31:15Z","dateModified":"2023-03-01T15:31:15Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zyf.im/2023/03/01/regular-expression-getting-started/"},"publisher":{"@type":"Organization","name":"ZYF.IM BLOG","logo":{"@type":"ImageObject","url":"https://zyf.im/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://zyf.im/ accesskey=h title="ZYF.IM (Alt + H)"><img src=https://zyf.im/apple-touch-icon.png alt aria-label=logo height=35>ZYF.IM</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://zyf.im/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://zyf.im/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://zyf.im/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://zyf.im/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://zyf.im/>Home</a>&nbsp;»&nbsp;<a href=https://zyf.im/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">正则表达式</h1><div class=post-meta><span title='2023-03-01 15:31:15 +0000 UTC'>March 1, 2023</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;1441 words&nbsp;·&nbsp;Me</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#00>00</a></li><li><a href=#01-元字符>01 元字符</a></li><li><a href=#02-量词与贪婪>02 量词与贪婪</a></li><li><a href=#03-分组与引用>03 分组与引用</a></li><li><a href=#04-匹配模式>04 匹配模式</a></li><li><a href=#05-断言-assertion>05 断言 Assertion</a></li><li><a href=#06-转义>06 转义</a></li><li><a href=#07-流派及其特性>07 流派及其特性</a></li><li><a href=#08-处理-unicode-文本>08 处理 Unicode 文本</a></li><li><a href=#09-编辑器中使用正则>09 编辑器中使用正则</a></li><li><a href=#10-语言中用正则>10 语言中用正则</a></li><li><a href=#11-匹配原理以及优化原则>11 匹配原理以及优化原则</a></li><li><a href=#12-常见问题>12 常见问题</a></li><li><a href=#程语言的角度来理解正则>程语言的角度来理解正则</a></li><li><a href=#references>References</a></li></ul></nav></div></details></div><div class=post-content><h2 id=00>00<a hidden class=anchor aria-hidden=true href=#00>#</a></h2><ul><li><a href=https://regex101.com/>regex101</a></li><li><a href="https://jex.im/regulex/#!flags=&amp;re=%5E(a%7Cb)*%3F%24">regulex</a></li><li><a href=https://ihateregex.io/expr/username/>ihateregex</a></li></ul><h2 id=01-元字符>01 元字符<a hidden class=anchor aria-hidden=true href=#01-元字符>#</a></h2><p>正则表达式 —— 字符串的规则。</p><p>元字符就是指那些在正则表达式中具有特殊意义的专用字符。</p><ul><li>特殊单字符<ul><li><code>.</code> 任意字符（换行除外）</li><li><code>\d</code> 任意数字 <code>\D</code> 任意非数字</li><li><code>\w</code> A-Za-z0-9_ <code>\W</code></li><li><code>\s</code> 空白符 <code>\S</code></li></ul></li><li>空白符<ul><li><code>\r</code> 回车符</li><li><code>\n</code> 换行符</li><li><code>\f</code> 换页符</li><li><code>\t</code> 制表符</li><li><code>\v</code> 垂直制表符</li></ul></li><li>范围<ul><li><code>|</code> 或</li><li><code>[abc]</code> 多选一</li><li><code>[a-z]</code> 之间</li><li><code>[^abc]</code> 取反，不能是括号中的任意单个元素</li></ul></li><li>量词<ul><li><code>*</code> 0&lt;=</li><li><code>+</code> 1&lt;=</li><li><code>?</code> 0或1</li><li><code>{m}</code> m</li><li><code>{m,}</code> m&lt;=</li><li><code>{m,n}</code> m-n</li></ul></li></ul><h2 id=02-量词与贪婪>02 量词与贪婪<a hidden class=anchor aria-hidden=true href=#02-量词与贪婪>#</a></h2><p>贪婪(Greedy) <code>*</code>：匹配最长。在贪婪量词模式下，正则表达式会尽可能长地去匹配符合规则的字符串，且会回溯。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-php data-lang=php><span class=line><span class=cl><span class=nx>preg_match_all</span><span class=p>(</span><span class=s2>&#34;/a*/i&#34;</span><span class=p>,</span> <span class=s2>&#34;aaabb&#34;</span><span class=p>,</span> <span class=nv>$matches</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>var_dump</span><span class=p>(</span><span class=nv>$matches</span><span class=p>);</span>
</span></span></code></pre></div><p>非贪婪(Reluctant) <code>+?</code>：匹配最短。在非贪婪量词模式下，正则表达式会匹配尽可能短的字符串。</p><p>ENV：Python3</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>re</span>
</span></span><span class=line><span class=cl><span class=n>re</span><span class=o>.</span><span class=n>findall</span><span class=p>(</span><span class=sa>r</span><span class=s1>&#39;a*&#39;</span><span class=p>,</span> <span class=s1>&#39;aaabb&#39;</span><span class=p>)</span> <span class=c1># 贪婪模式</span>
</span></span><span class=line><span class=cl><span class=c1># [&#39;aaa&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;]</span>
</span></span><span class=line><span class=cl><span class=n>re</span><span class=o>.</span><span class=n>findall</span><span class=p>(</span><span class=sa>r</span><span class=s1>&#39;a*?&#39;</span><span class=p>,</span> <span class=s1>&#39;aaabb&#39;</span><span class=p>)</span> <span class=c1># 非贪婪模式</span>
</span></span><span class=line><span class=cl><span class=c1># [&#39;&#39;, &#39;a&#39;, &#39;&#39;, &#39;a&#39;, &#39;&#39;, &#39;a&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>re</span><span class=o>.</span><span class=n>findall</span><span class=p>(</span><span class=sa>r</span><span class=s1>&#39;&#34;.+&#34;&#39;</span><span class=p>,</span> <span class=s1>&#39;&#34;the little cat&#34; is a toy, it lokks &#34;a little bad&#34;&#39;</span><span class=p>)</span> <span class=c1># 贪婪模式</span>
</span></span><span class=line><span class=cl><span class=c1># [&#39;&#34;the little cat&#34; is a toy, it lokks &#34;a little bad&#34;&#39;]</span>
</span></span><span class=line><span class=cl><span class=n>re</span><span class=o>.</span><span class=n>findall</span><span class=p>(</span><span class=sa>r</span><span class=s1>&#39;&#34;.+?&#34;&#39;</span><span class=p>,</span> <span class=s1>&#39;&#34;the little cat&#34; is a toy, it lokks &#34;a little bad&#34;&#39;</span><span class=p>)</span> <span class=c1># 非贪婪模式</span>
</span></span><span class=line><span class=cl><span class=c1># [&#39;&#34;the little cat&#34;&#39;, &#39;&#34;a little bad&#34;&#39;]</span>
</span></span></code></pre></div><p>独占模式(Possessive) <code>++</code>：同贪婪一样匹配最长。不过在独占量词模式下，正则表达式尽可能长地去匹配字符串，一旦匹配不成功就会结束匹配而 <strong>不会回溯</strong>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 回溯示例：</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>re</span>
</span></span><span class=line><span class=cl><span class=n>re</span><span class=o>.</span><span class=n>findall</span><span class=p>(</span><span class=sa>r</span><span class=s1>&#39;xy{1,3}z&#39;</span><span class=p>,</span> <span class=s1>&#39;xyyz&#39;</span><span class=p>)</span> <span class=c1># 回溯</span>
</span></span><span class=line><span class=cl><span class=c1># [&#39;xyyz&#39;]</span>
</span></span><span class=line><span class=cl><span class=c1># 正则 xy{1,3} 会尽可能长地去匹配到 xyyz，无法匹配 z，向前回溯 xyy</span>
</span></span><span class=line><span class=cl><span class=c1># 正则 z 匹配到剩下字符串 z</span>
</span></span><span class=line><span class=cl><span class=n>re</span><span class=o>.</span><span class=n>findall</span><span class=p>(</span><span class=sa>r</span><span class=s1>&#39;xy{1,3}?z&#39;</span><span class=p>,</span> <span class=s1>&#39;xyyz&#39;</span><span class=p>)</span> <span class=c1># 非贪婪</span>
</span></span><span class=line><span class=cl><span class=c1># [&#39;xyyz&#39;]</span>
</span></span><span class=line><span class=cl><span class=c1># 正则 xy{1,3} 会尽可能短地去匹配到 xy</span>
</span></span><span class=line><span class=cl><span class=c1># 正则 z 匹配到字符串 y，无法匹配，向前回溯</span>
</span></span><span class=line><span class=cl><span class=c1># 正则 xy{1,3} 会尽可能短地去匹配 xyy</span>
</span></span><span class=line><span class=cl><span class=c1># 正则 z 匹配到剩下字符串 z</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 独占模式示例：</span>
</span></span><span class=line><span class=cl><span class=c1># pip install regex -i https://mirrors.aliyun.com/pypi/simple/</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>regex</span>
</span></span><span class=line><span class=cl><span class=n>regex</span><span class=o>.</span><span class=n>findall</span><span class=p>(</span><span class=sa>r</span><span class=s1>&#39;xy{1,3}+z&#39;</span><span class=p>,</span> <span class=s1>&#39;xyyz&#39;</span><span class=p>)</span> <span class=c1># 独占</span>
</span></span><span class=line><span class=cl><span class=c1># [&#39;xyyz&#39;]</span>
</span></span><span class=line><span class=cl><span class=c1># 正则 xy{1,3}+ 会尽可能长地去匹配到 xyy 并占用</span>
</span></span><span class=line><span class=cl><span class=c1># 正则 z 匹配到字符串 z</span>
</span></span><span class=line><span class=cl><span class=n>regex</span><span class=o>.</span><span class=n>findall</span><span class=p>(</span><span class=sa>r</span><span class=s1>&#39;xy{1,3}+yz&#39;</span><span class=p>,</span> <span class=s1>&#39;xyyz&#39;</span><span class=p>)</span> <span class=c1># 独占</span>
</span></span><span class=line><span class=cl><span class=c1># []</span>
</span></span><span class=line><span class=cl><span class=c1># 正则 xy{1,3}+ 会尽可能长地去匹配到 xyy 并占用</span>
</span></span><span class=line><span class=cl><span class=c1># 正则 yz 无法匹配到剩下字符串 z</span>
</span></span></code></pre></div><h2 id=03-分组与引用>03 分组与引用<a hidden class=anchor aria-hidden=true href=#03-分组与引用>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>regex</span>
</span></span><span class=line><span class=cl><span class=c1># 不保存分组 (?:正则)</span>
</span></span><span class=line><span class=cl><span class=n>regex</span><span class=o>.</span><span class=n>sub</span><span class=p>(</span><span class=sa>r</span><span class=s1>&#39;(\d</span><span class=si>{4}</span><span class=s1>)-(?:\d</span><span class=si>{2}</span><span class=s1>)-(\d</span><span class=si>{2}</span><span class=s1>)&#39;</span><span class=p>,</span> <span class=sa>r</span><span class=s2>&#34;年：\1  日：\2&#34;</span><span class=p>,</span> <span class=s1>&#39;2023-03-01&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># &#39;年：2023  日：01&#39;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 去除重复连续单词</span>
</span></span><span class=line><span class=cl><span class=n>regex</span><span class=o>.</span><span class=n>sub</span><span class=p>(</span><span class=sa>r</span><span class=s1>&#39;(\w+)(\s\1)+&#39;</span><span class=p>,</span> <span class=sa>r</span><span class=s2>&#34;\1&#34;</span><span class=p>,</span> <span class=s1>&#39;the little cat cat is in the hat hat hat, we like it.&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># &#39;the little cat is in the hat, we like it.&#39;</span>
</span></span></code></pre></div><h2 id=04-匹配模式>04 匹配模式<a hidden class=anchor aria-hidden=true href=#04-匹配模式>#</a></h2><p>指改变元字符匹配行为。</p><p>不区分大小写模式（Case-Insensitive）<code>(?模式标识)</code> <code>(?i)</code>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>regex</span>
</span></span><span class=line><span class=cl><span class=n>regex</span><span class=o>.</span><span class=n>findall</span><span class=p>(</span><span class=sa>r</span><span class=s2>&#34;(?i)cat&#34;</span><span class=p>,</span> <span class=s2>&#34;cat Cat CAt&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># [&#39;cat&#39;, &#39;Cat&#39;, &#39;CAt&#39;]</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-re data-lang=re><span class=line><span class=cl><span class=ow>#</span> <span class=n>https</span><span class=ow>:</span><span class=c1>//regex101.com/r/3OUJda/1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=ow>#</span> <span class=n>二次重复时的大小写一致</span>
</span></span><span class=line><span class=cl><span class=ow>((?</span><span class=n>i</span><span class=ow>)</span><span class=n>cat</span><span class=ow>)</span> <span class=err>\</span><span class=n>1</span>
</span></span></code></pre></div><p>点号通配模式（Dot All）<code>(?s)</code> 让英文的点 <code>.</code> 可以匹配上包括换行的任何字符。等价 <code>[\s\S]</code> <code>[\d\D]</code> <code>[\w\W]</code>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-re data-lang=re><span class=line><span class=cl><span class=ow>#</span> <span class=n>https</span><span class=ow>:</span><span class=c1>//regex101.com/r/zXtwLv/1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=ow>#</span> <span class=n>匹配包括换行符</span>
</span></span><span class=line><span class=cl><span class=ow>(?</span><span class=n>s</span><span class=ow>).+</span>
</span></span></code></pre></div><p>多行匹配模式（Multiline）<code>(?m)</code> 使 <code>^</code> 和 <code>$</code> 能匹配上每行的开头或结尾。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-re data-lang=re><span class=line><span class=cl><span class=ow>#</span> <span class=n>分行匹配</span>
</span></span><span class=line><span class=cl><span class=ow>(?</span><span class=n>m</span><span class=ow>)</span><span class=o>^</span><span class=n>cat</span><span class=ow>|</span><span class=n>dog</span><span class=o>$</span>
</span></span></code></pre></div><p>注释模式（Comment）<code>(?#)</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-re data-lang=re><span class=line><span class=cl><span class=ow>(</span><span class=err>\</span><span class=n>w</span><span class=ow>+)(?#</span><span class=n>word</span><span class=ow>)</span> <span class=err>\</span><span class=n>1</span><span class=ow>(?#</span><span class=n>word</span> <span class=n>repeat</span> <span class=n>again</span><span class=ow>)</span>
</span></span></code></pre></div><h2 id=05-断言-assertion>05 断言 Assertion<a hidden class=anchor aria-hidden=true href=#05-断言-assertion>#</a></h2><p>对要匹配的文本的位置也有一定的要求。只用于匹配位置，而不是文本内容本身，这种结构就是断言。</p><p>边界（Boundary）</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>re</span>
</span></span><span class=line><span class=cl><span class=c1># 单词边界 \b</span>
</span></span><span class=line><span class=cl><span class=c1># tom -&gt; jerry, tomorrow 不受影响</span>
</span></span><span class=line><span class=cl><span class=n>re</span><span class=o>.</span><span class=n>sub</span><span class=p>(</span><span class=sa>r</span><span class=s1>&#39;\btom\b&#39;</span><span class=p>,</span> <span class=s1>&#39;jerry&#39;</span><span class=p>,</span> <span class=s2>&#34;tom asked me if I would go fishing with him tomorrow.&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># &#39;jerry asked me if I would go fishing with him tomorrow.&#39;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 行的开始结束</span>
</span></span><span class=line><span class=cl><span class=c1># \A \z 不受模式影响</span>
</span></span><span class=line><span class=cl><span class=c1># \A -&gt; ^, \z -&gt; $</span>
</span></span><span class=line><span class=cl><span class=n>re</span><span class=o>.</span><span class=n>sub</span><span class=p>(</span><span class=sa>r</span><span class=s1>&#39;\Atom&#39;</span><span class=p>,</span> <span class=s1>&#39;jerry&#39;</span><span class=p>,</span> <span class=s2>&#34;tom asked me if I would go fishing with him tomorrow.&#34;</span><span class=p>)</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 环视 左尖括号代表看左边，没有尖括号是看右边，感叹号是非的意思</span>
</span></span><span class=line><span class=cl><span class=c1># (?&lt;=Y) 左边是Y</span>
</span></span><span class=line><span class=cl><span class=c1># (?&lt;!Y) 左边不是Y</span>
</span></span><span class=line><span class=cl><span class=c1># (?=Y) 右边是Y</span>
</span></span><span class=line><span class=cl><span class=c1># (?!Y) 右边不是Y</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>re</span><span class=o>.</span><span class=n>findall</span><span class=p>(</span><span class=sa>r</span><span class=s1>&#39;[1-9]\d</span><span class=si>{5}</span><span class=s1>&#39;</span><span class=p>,</span> <span class=s2>&#34;138001380002&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># [&#39;138001&#39;, &#39;380002&#39;]</span>
</span></span><span class=line><span class=cl><span class=n>re</span><span class=o>.</span><span class=n>findall</span><span class=p>(</span><span class=sa>r</span><span class=s1>&#39;(?&lt;!\d)[1-9]\d</span><span class=si>{5}</span><span class=s1>(?!\d)&#39;</span><span class=p>,</span> <span class=s2>&#34;138001380002&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># 左边不是数字、右边不是数字</span>
</span></span><span class=line><span class=cl><span class=c1># []</span>
</span></span><span class=line><span class=cl><span class=n>re</span><span class=o>.</span><span class=n>findall</span><span class=p>(</span><span class=sa>r</span><span class=s1>&#39;(?&lt;!\d)[1-9]\d</span><span class=si>{5}</span><span class=s1>(?!\d)&#39;</span><span class=p>,</span> <span class=s2>&#34;code138001code&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># 左边不是数字、右边不是数字</span>
</span></span><span class=line><span class=cl><span class=c1># [&#39;138001&#39;]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># \b\w+\b -&gt; (?&lt;!\w)\w+(?!\w) -&gt; (?&lt;=\W)\w+(?=\W)</span>
</span></span><span class=line><span class=cl><span class=c1># https://regex101.com/r/PBEKxY/1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># (\w+)(\s+\b\1\b)+</span>
</span></span><span class=line><span class=cl><span class=c1># 单词，单词的左边是单词边界、可以有一个及以上空格，右边是单词边界</span>
</span></span><span class=line><span class=cl><span class=c1># 比 (\w+)(\s+\1)+ 更严谨 eg: the little cat cat2 is in the hat hat2</span>
</span></span></code></pre></div><h2 id=06-转义>06 转义<a hidden class=anchor aria-hidden=true href=#06-转义>#</a></h2><p>转义字符 Escape Character 后面的字符，不是原来的意思了。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>re</span>
</span></span><span class=line><span class=cl><span class=n>re</span><span class=o>.</span><span class=n>findall</span><span class=p>(</span><span class=sa>r</span><span class=s1>&#39;</span><span class=se>\\</span><span class=s1>d&#39;</span><span class=p>,</span> <span class=s1>&#39;abc</span><span class=se>\\</span><span class=s1>d123d</span><span class=se>\\</span><span class=s1>&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># [&#39;\\d&#39;]</span>
</span></span><span class=line><span class=cl><span class=n>re</span><span class=o>.</span><span class=n>findall</span><span class=p>(</span><span class=s1>&#39;</span><span class=se>\\</span><span class=s1>&#39;</span><span class=p>,</span> <span class=s1>&#39;a*b+c?</span><span class=se>\\</span><span class=s1>d123d</span><span class=se>\\</span><span class=s1>&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># bad escape (end of pattern) at position 0</span>
</span></span><span class=line><span class=cl><span class=n>re</span><span class=o>.</span><span class=n>findall</span><span class=p>(</span><span class=s1>&#39;</span><span class=se>\\\\</span><span class=s1>&#39;</span><span class=p>,</span> <span class=s1>&#39;a*b+c?</span><span class=se>\\</span><span class=s1>d123d</span><span class=se>\\</span><span class=s1>&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># [&#39;\\&#39;, &#39;\\&#39;]</span>
</span></span><span class=line><span class=cl><span class=c1># 字符串-&gt;正则表达式：字符串转义和正则转义</span>
</span></span><span class=line><span class=cl><span class=c1># \\\\ 字符串转义 \\</span>
</span></span><span class=line><span class=cl><span class=c1># \\ 正则转义 \</span>
</span></span><span class=line><span class=cl><span class=n>re</span><span class=o>.</span><span class=n>findall</span><span class=p>(</span><span class=sa>r</span><span class=s1>&#39;</span><span class=se>\\</span><span class=s1>&#39;</span><span class=p>,</span> <span class=s1>&#39;a*b+c?</span><span class=se>\\</span><span class=s1>d123d</span><span class=se>\\</span><span class=s1>&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># [&#39;\\&#39;, &#39;\\&#39;]</span>
</span></span><span class=line><span class=cl><span class=n>re</span><span class=o>.</span><span class=n>findall</span><span class=p>(</span><span class=s1>&#39;\(\)\[]\</span><span class=si>{}</span><span class=s1>&#39;</span><span class=p>,</span> <span class=s1>&#39;()[]</span><span class=si>{}</span><span class=s1>&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># [&#39;()[]{}&#39;]</span>
</span></span><span class=line><span class=cl><span class=c1># 方括号和花括号的转义一般转义开括号就可以，但圆括号两个都需要转义</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>re</span>
</span></span><span class=line><span class=cl><span class=n>re</span><span class=o>.</span><span class=n>escape</span><span class=p>(</span><span class=s1>&#39;\d&#39;</span><span class=p>)</span> <span class=c1># 反斜杠和字母d转义</span>
</span></span><span class=line><span class=cl><span class=c1># &#39;\\\\d&#39;</span>
</span></span><span class=line><span class=cl><span class=n>re</span><span class=o>.</span><span class=n>findall</span><span class=p>(</span><span class=n>re</span><span class=o>.</span><span class=n>escape</span><span class=p>(</span><span class=s1>&#39;\d&#39;</span><span class=p>),</span> <span class=s1>&#39;\d&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># [&#39;\\d&#39;]</span>
</span></span><span class=line><span class=cl><span class=n>re</span><span class=o>.</span><span class=n>escape</span><span class=p>(</span><span class=s1>&#39;[+]&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># &#39;\\[\\+\\]&#39;</span>
</span></span><span class=line><span class=cl><span class=n>re</span><span class=o>.</span><span class=n>findall</span><span class=p>(</span><span class=n>re</span><span class=o>.</span><span class=n>escape</span><span class=p>(</span><span class=s1>&#39;[+]&#39;</span><span class=p>),</span> <span class=s1>&#39;[+]&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># [&#39;[+]&#39;]</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>re</span>
</span></span><span class=line><span class=cl><span class=n>re</span><span class=o>.</span><span class=n>findall</span><span class=p>(</span><span class=sa>r</span><span class=s1>&#39;[^ab]&#39;</span><span class=p>,</span> <span class=s1>&#39;^ab&#39;</span><span class=p>)</span>  <span class=c1># 转义前代表&#34;非&#34;</span>
</span></span><span class=line><span class=cl><span class=c1># [&#39;^&#39;]</span>
</span></span><span class=line><span class=cl><span class=n>re</span><span class=o>.</span><span class=n>findall</span><span class=p>(</span><span class=sa>r</span><span class=s1>&#39;[^cd]&#39;</span><span class=p>,</span> <span class=s1>&#39;^ab&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># [&#39;^&#39;, &#39;a&#39;, &#39;b&#39;]</span>
</span></span><span class=line><span class=cl><span class=n>re</span><span class=o>.</span><span class=n>findall</span><span class=p>(</span><span class=sa>r</span><span class=s1>&#39;[\^ab]&#39;</span><span class=p>,</span> <span class=s1>&#39;^ab&#39;</span><span class=p>)</span>  <span class=c1># 转义后代表普通字符</span>
</span></span><span class=line><span class=cl><span class=c1># [&#39;^&#39;, &#39;a&#39;, &#39;b&#39;]</span>
</span></span><span class=line><span class=cl><span class=n>re</span><span class=o>.</span><span class=n>findall</span><span class=p>(</span><span class=sa>r</span><span class=s1>&#39;[a-c]&#39;</span><span class=p>,</span> <span class=s1>&#39;abc-&#39;</span><span class=p>)</span>  <span class=c1># 中划线在中间，代表&#34;范围&#34;</span>
</span></span><span class=line><span class=cl><span class=c1># [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>
</span></span><span class=line><span class=cl><span class=n>re</span><span class=o>.</span><span class=n>findall</span><span class=p>(</span><span class=sa>r</span><span class=s1>&#39;[a\-c]&#39;</span><span class=p>,</span> <span class=s1>&#39;abc-&#39;</span><span class=p>)</span>  <span class=c1># 中划线在中间，转义后的</span>
</span></span><span class=line><span class=cl><span class=n>re</span><span class=o>.</span><span class=n>findall</span><span class=p>(</span><span class=sa>r</span><span class=s1>&#39;[-ac]&#39;</span><span class=p>,</span> <span class=s1>&#39;abc-&#39;</span><span class=p>)</span>  <span class=c1># 在开头，不需要转义</span>
</span></span><span class=line><span class=cl><span class=n>re</span><span class=o>.</span><span class=n>findall</span><span class=p>(</span><span class=sa>r</span><span class=s1>&#39;[ac-]&#39;</span><span class=p>,</span> <span class=s1>&#39;abc-&#39;</span><span class=p>)</span>  <span class=c1># 在结尾，不需要转义</span>
</span></span><span class=line><span class=cl><span class=c1># [&#39;a&#39;, &#39;c&#39;, &#39;-&#39;]</span>
</span></span><span class=line><span class=cl><span class=n>re</span><span class=o>.</span><span class=n>findall</span><span class=p>(</span><span class=sa>r</span><span class=s1>&#39;[]ab]&#39;</span><span class=p>,</span> <span class=s1>&#39;]ab&#39;</span><span class=p>)</span>  <span class=c1># 右括号不转义，在首位</span>
</span></span><span class=line><span class=cl><span class=c1># [&#39;]&#39;, &#39;a&#39;, &#39;b&#39;]</span>
</span></span><span class=line><span class=cl><span class=n>re</span><span class=o>.</span><span class=n>findall</span><span class=p>(</span><span class=sa>r</span><span class=s1>&#39;[a]b]&#39;</span><span class=p>,</span> <span class=s1>&#39;]ab&#39;</span><span class=p>)</span>  <span class=c1># 右括号不转义，不在首位</span>
</span></span><span class=line><span class=cl><span class=c1># []</span>
</span></span><span class=line><span class=cl><span class=n>re</span><span class=o>.</span><span class=n>findall</span><span class=p>(</span><span class=sa>r</span><span class=s1>&#39;[a\]b]&#39;</span><span class=p>,</span> <span class=s1>&#39;]ab&#39;</span><span class=p>)</span>  <span class=c1># 转义后代表普通字符</span>
</span></span><span class=line><span class=cl><span class=c1># [&#39;]&#39;, &#39;a&#39;, &#39;b&#39;]</span>
</span></span><span class=line><span class=cl><span class=n>re</span><span class=o>.</span><span class=n>findall</span><span class=p>(</span><span class=sa>r</span><span class=s1>&#39;[.*+?()]&#39;</span><span class=p>,</span> <span class=s1>&#39;[.*+?()]&#39;</span><span class=p>)</span>  <span class=c1># 单个长度的元字符在中括号里，可以不转义</span>
</span></span><span class=line><span class=cl><span class=c1># [&#39;.&#39;, &#39;*&#39;, &#39;+&#39;, &#39;?&#39;, &#39;(&#39;, &#39;)&#39;]</span>
</span></span><span class=line><span class=cl><span class=n>re</span><span class=o>.</span><span class=n>findall</span><span class=p>(</span><span class=sa>r</span><span class=s1>&#39;[\d]&#39;</span><span class=p>,</span> <span class=s1>&#39;d12</span><span class=se>\\</span><span class=s1>&#39;</span><span class=p>)</span>  <span class=c1># \w，\d等在中括号中还是元字符的功能</span>
</span></span><span class=line><span class=cl><span class=c1># [&#39;1&#39;, &#39;2&#39;]</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>re</span>
</span></span><span class=line><span class=cl><span class=n>re</span><span class=o>.</span><span class=n>findall</span><span class=p>(</span><span class=s1>&#39;</span><span class=se>\n</span><span class=s1>&#39;</span><span class=p>,</span> <span class=s1>&#39;</span><span class=se>\\</span><span class=s1>n</span><span class=se>\n\\</span><span class=s1>&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># [&#39;\n&#39;] \n -&gt; (\n) -&gt; (\n)</span>
</span></span><span class=line><span class=cl><span class=n>re</span><span class=o>.</span><span class=n>findall</span><span class=p>(</span><span class=s1>&#39;</span><span class=se>\\</span><span class=s1>n&#39;</span><span class=p>,</span> <span class=s1>&#39;</span><span class=se>\\</span><span class=s1>n</span><span class=se>\n\\</span><span class=s1>&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># [&#39;\n&#39;] \\n -&gt; \n -&gt; (\n)</span>
</span></span><span class=line><span class=cl><span class=n>re</span><span class=o>.</span><span class=n>findall</span><span class=p>(</span><span class=s1>&#39;</span><span class=se>\\\n</span><span class=s1>&#39;</span><span class=p>,</span> <span class=s1>&#39;</span><span class=se>\\</span><span class=s1>n</span><span class=se>\n\\</span><span class=s1>&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># [&#39;\n&#39;] \\\n -&gt; \n -&gt; (\n)</span>
</span></span><span class=line><span class=cl><span class=n>re</span><span class=o>.</span><span class=n>escape</span><span class=p>(</span><span class=s1>&#39;</span><span class=se>\n</span><span class=s1>&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># &#39;\\\n&#39;</span>
</span></span><span class=line><span class=cl><span class=n>re</span><span class=o>.</span><span class=n>findall</span><span class=p>(</span><span class=s1>&#39;</span><span class=se>\\\\</span><span class=s1>n&#39;</span><span class=p>,</span> <span class=s1>&#39;</span><span class=se>\\</span><span class=s1>n</span><span class=se>\n\\</span><span class=s1>&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># [&#39;\\n&#39;] \\\\n -&gt; \\\n -&gt; \(\n)</span>
</span></span><span class=line><span class=cl><span class=n>re</span><span class=o>.</span><span class=n>escape</span><span class=p>(</span><span class=s1>&#39;</span><span class=se>\\</span><span class=s1>n&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># &#39;\\\\n&#39;</span>
</span></span></code></pre></div><h2 id=07-流派及其特性>07 流派及其特性<a hidden class=anchor aria-hidden=true href=#07-流派及其特性>#</a></h2><ul><li>POSIX Portable Operating System Interface。不能使用 <code>\d</code>。<ul><li>BRE Basic Regular Expression 基本正则表达式。<code>grep</code> <code>sed</code> 花园问管家 <code>{}()?|+</code> 要转义。</li><li>ERE Extended Regular Expression 扩展正则表达式。<code>egrep</code> <code>grep -E</code> <code>sed -E</code>。</li></ul></li><li>PCRE Perl Compatible Regular Expressions。可以使用 <code>\d</code> <code>\w</code> <code>\s</code>。<code>grep -P</code> <code>sed -P</code>。</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>grep --help <span class=p>|</span> grep PATTERN
</span></span><span class=line><span class=cl><span class=c1># PATTERN is, by default, a basic regular expression (BRE).</span>
</span></span><span class=line><span class=cl><span class=c1>#   -E, --extended-regexp     PATTERN is an extended regular expression (ERE)</span>
</span></span><span class=line><span class=cl><span class=c1>#   -F, --fixed-strings       PATTERN is a set of newline-separated fixed strings</span>
</span></span><span class=line><span class=cl><span class=c1>#   -G, --basic-regexp        PATTERN is a basic regular expression (BRE)</span>
</span></span><span class=line><span class=cl><span class=c1>#   -P, --perl-regexp         PATTERN is a Perl regular expression</span>
</span></span></code></pre></div><blockquote><p><a href=https://www.infoq.cn/article/2011/07/regular-expressions-6-posix>Linux/Unix 工具与正则表达式的 POSIX 规范 | 余晟</a></p></blockquote><h2 id=08-处理-unicode-文本>08 处理 Unicode 文本<a hidden class=anchor aria-hidden=true href=#08-处理-unicode-文本>#</a></h2><p>Unicode 相当于规定了字符对应的码值，这个码值得编码成字节的形式去传输和存储。最常见的编码方式是 UTF-8，另外还有 UTF-16，UTF-32 等。UTF-8 之所以能够流行起来，是因为其编码比较巧妙，采用的是变长的方法。也就是一个 Unicode 字符，在使用 UTF-8 编码表示时占用 1 到 4 个字节不等。最重要的是 Unicode 兼容 ASCII 编码，在表示纯英文时，并不会占用更多存储空间。而汉字呢，在 UTF-8 中，通常是用三个字节来表示。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># python2.7</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>re</span>
</span></span><span class=line><span class=cl><span class=sa>u</span><span class=s1>&#39;极客&#39;</span><span class=o>.</span><span class=n>encode</span><span class=p>(</span><span class=s1>&#39;utf-8&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># &#39;\xe6\x9e\x81\xe5\xae\xa2&#39;</span>
</span></span><span class=line><span class=cl><span class=sa>u</span><span class=s1>&#39;时间&#39;</span><span class=o>.</span><span class=n>encode</span><span class=p>(</span><span class=s1>&#39;utf-8&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># &#39;\xe6\x97\xb6\xe9\x97\xb4&#39;</span>
</span></span><span class=line><span class=cl><span class=c1># 都含有 e6</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>re</span><span class=o>.</span><span class=n>search</span><span class=p>(</span><span class=sa>r</span><span class=s1>&#39;[时间]&#39;</span><span class=p>,</span> <span class=s1>&#39;极客&#39;</span><span class=p>)</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl><span class=c1># True</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>re</span><span class=o>.</span><span class=n>compile</span><span class=p>(</span><span class=sa>r</span><span class=s1>&#39;[时间]&#39;</span><span class=p>,</span> <span class=n>re</span><span class=o>.</span><span class=n>DEBUG</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># in</span>
</span></span><span class=line><span class=cl><span class=c1>#   literal 230</span>
</span></span><span class=line><span class=cl><span class=c1>#   literal 151</span>
</span></span><span class=line><span class=cl><span class=c1>#   literal 182</span>
</span></span><span class=line><span class=cl><span class=c1>#   literal 233</span>
</span></span><span class=line><span class=cl><span class=c1>#   literal 151</span>
</span></span><span class=line><span class=cl><span class=c1>#   literal 180</span>
</span></span><span class=line><span class=cl><span class=c1># &lt;_sre.SRE_Pattern object at 0x10ab44d78&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>re</span><span class=o>.</span><span class=n>compile</span><span class=p>(</span><span class=sa>r</span><span class=s1>&#39;[极客]&#39;</span><span class=p>,</span> <span class=n>re</span><span class=o>.</span><span class=n>DEBUG</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># in</span>
</span></span><span class=line><span class=cl><span class=c1>#   literal 230</span>
</span></span><span class=line><span class=cl><span class=c1>#   literal 158</span>
</span></span><span class=line><span class=cl><span class=c1>#   literal 129</span>
</span></span><span class=line><span class=cl><span class=c1>#   literal 229</span>
</span></span><span class=line><span class=cl><span class=c1>#   literal 174</span>
</span></span><span class=line><span class=cl><span class=c1>#   literal 162</span>
</span></span><span class=line><span class=cl><span class=c1># &lt;_sre.SRE_Pattern object at 0x10ab44e40&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>re</span><span class=o>.</span><span class=n>compile</span><span class=p>(</span><span class=n>ur</span><span class=s1>&#39;[时间]&#39;</span><span class=p>,</span> <span class=n>re</span><span class=o>.</span><span class=n>DEBUG</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># in</span>
</span></span><span class=line><span class=cl><span class=c1>#   literal 26102</span>
</span></span><span class=line><span class=cl><span class=c1>#   literal 38388</span>
</span></span><span class=line><span class=cl><span class=c1># &lt;_sre.SRE_Pattern object at 0x10ac02710&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>re</span><span class=o>.</span><span class=n>search</span><span class=p>(</span><span class=n>ur</span><span class=s1>&#39;[时间]&#39;</span><span class=p>,</span> <span class=s1>&#39;时间&#39;</span><span class=p>)</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl><span class=kc>False</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>re</span><span class=o>.</span><span class=n>search</span><span class=p>(</span><span class=n>ur</span><span class=s1>&#39;[时间]&#39;</span><span class=p>,</span> <span class=sa>u</span><span class=s1>&#39;时间&#39;</span><span class=p>)</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl><span class=kc>True</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># python2.7</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>re</span>
</span></span><span class=line><span class=cl><span class=n>re</span><span class=o>.</span><span class=n>findall</span><span class=p>(</span><span class=sa>r</span><span class=s1>&#39;^.$&#39;</span><span class=p>,</span> <span class=s1>&#39;学&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># []</span>
</span></span><span class=line><span class=cl><span class=n>re</span><span class=o>.</span><span class=n>findall</span><span class=p>(</span><span class=sa>r</span><span class=s1>&#39;^.$&#39;</span><span class=p>,</span> <span class=sa>u</span><span class=s1>&#39;学&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># [u&#39;\u5b66&#39;]</span>
</span></span><span class=line><span class=cl><span class=n>re</span><span class=o>.</span><span class=n>findall</span><span class=p>(</span><span class=n>ur</span><span class=s1>&#39;^.$&#39;</span><span class=p>,</span> <span class=sa>u</span><span class=s1>&#39;学&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># [u&#39;\u5b66&#39;]</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>unichr</span><span class=p>(</span><span class=mh>0x5B66</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=c1># 学</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># python3</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>re</span>
</span></span><span class=line><span class=cl><span class=n>re</span><span class=o>.</span><span class=n>findall</span><span class=p>(</span><span class=sa>r</span><span class=s1>&#39;^.$&#39;</span><span class=p>,</span> <span class=s1>&#39;学&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># [&#39;学&#39;]</span>
</span></span><span class=line><span class=cl><span class=n>re</span><span class=o>.</span><span class=n>findall</span><span class=p>(</span><span class=sa>r</span><span class=s1>&#39;(?a)^.$&#39;</span><span class=p>,</span> <span class=s1>&#39;学&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># [&#39;学&#39;]</span>
</span></span><span class=line><span class=cl><span class=c1># (?a) 表示启用 ASCII 模式</span>
</span></span><span class=line><span class=cl><span class=nb>chr</span><span class=p>(</span><span class=mh>0x5B66</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># &#39;学&#39;</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-php data-lang=php><span class=line><span class=cl><span class=c1>// 可以匹配汉语 in PHP
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>\p</span><span class=p>{</span><span class=nx>Han</span><span class=p>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># python2.7</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>re</span>
</span></span><span class=line><span class=cl><span class=n>re</span><span class=o>.</span><span class=n>findall</span><span class=p>(</span><span class=sa>r</span><span class=s1>&#39;客</span><span class=si>{3}</span><span class=s1>&#39;</span><span class=p>,</span> <span class=s1>&#39;极客客客客&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># []</span>
</span></span><span class=line><span class=cl><span class=n>re</span><span class=o>.</span><span class=n>findall</span><span class=p>(</span><span class=n>ur</span><span class=s1>&#39;客</span><span class=si>{3}</span><span class=s1>&#39;</span><span class=p>,</span> <span class=s1>&#39;极客客客客&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># []</span>
</span></span><span class=line><span class=cl><span class=n>re</span><span class=o>.</span><span class=n>findall</span><span class=p>(</span><span class=sa>r</span><span class=s1>&#39;客</span><span class=si>{3}</span><span class=s1>&#39;</span><span class=p>,</span> <span class=sa>u</span><span class=s1>&#39;极客客客客&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># []</span>
</span></span><span class=line><span class=cl><span class=n>re</span><span class=o>.</span><span class=n>findall</span><span class=p>(</span><span class=n>ur</span><span class=s1>&#39;客</span><span class=si>{3}</span><span class=s1>&#39;</span><span class=p>,</span> <span class=sa>u</span><span class=s1>&#39;极客客客客&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># [u&#39;\u5ba2\u5ba2\u5ba2&#39;]</span>
</span></span><span class=line><span class=cl><span class=n>re</span><span class=o>.</span><span class=n>findall</span><span class=p>(</span><span class=sa>r</span><span class=s1>&#39;(客)</span><span class=si>{3}</span><span class=s1>&#39;</span><span class=p>,</span> <span class=s1>&#39;极客客客客&#39;</span><span class=p>)</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># python3</span>
</span></span><span class=line><span class=cl><span class=n>re</span><span class=o>.</span><span class=n>findall</span><span class=p>(</span><span class=sa>r</span><span class=s1>&#39;客</span><span class=si>{3}</span><span class=s1>&#39;</span><span class=p>,</span> <span class=s1>&#39;极客客客客&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># [&#39;客客客&#39;]</span>
</span></span><span class=line><span class=cl><span class=c1># 在 Python3 中，不需要在正则表达式字符串前面添加 u 前缀，因为所有字符串都默认为 Unicode 字符串。</span>
</span></span></code></pre></div><ul><li><a href=https://en.wikipedia.org/wiki/Script_(Unicode)#Hani>Script (Unicode) | wikipedia</a></li></ul><h2 id=09-编辑器中使用正则>09 编辑器中使用正则<a hidden class=anchor aria-hidden=true href=#09-编辑器中使用正则>#</a></h2><p>竖向编辑：MacOS alt + 鼠标纵向滑动。</p><h2 id=10-语言中用正则>10 语言中用正则<a hidden class=anchor aria-hidden=true href=#10-语言中用正则>#</a></h2><p>校验文本内容：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>re</span>
</span></span><span class=line><span class=cl><span class=n>reg</span> <span class=o>=</span> <span class=n>re</span><span class=o>.</span><span class=n>compile</span><span class=p>(</span><span class=sa>r</span><span class=s1>&#39;\A\d</span><span class=si>{4}</span><span class=s1>-\d</span><span class=si>{2}</span><span class=s1>-\d</span><span class=si>{2}</span><span class=s1>\Z&#39;</span><span class=p>)</span>  <span class=c1># 建议先编译，提高效率</span>
</span></span><span class=line><span class=cl><span class=n>reg</span><span class=o>.</span><span class=n>search</span><span class=p>(</span><span class=s1>&#39;2020-06-01&#39;</span><span class=p>)</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl><span class=c1># True</span>
</span></span><span class=line><span class=cl><span class=n>reg</span><span class=o>.</span><span class=k>match</span><span class=p>(</span><span class=s1>&#39;2020-06-01&#39;</span><span class=p>)</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span>  <span class=c1># 使用 match 时 \A 可省略，match 就是从头匹配</span>
</span></span><span class=line><span class=cl><span class=c1># True</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>reg</span> <span class=o>=</span> <span class=n>re</span><span class=o>.</span><span class=n>compile</span><span class=p>(</span><span class=sa>r</span><span class=s1>&#39;\d</span><span class=si>{4}</span><span class=s1>-\d</span><span class=si>{2}</span><span class=s1>&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>reg</span><span class=o>.</span><span class=n>findall</span><span class=p>(</span><span class=s1>&#39;2020-05 2020-06&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># [&#39;2020-05&#39;, &#39;2020-06&#39;]</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=sr>/^\d{4}-\d{2}-\d{2}$/</span><span class=p>.</span><span class=nx>test</span><span class=p>(</span><span class=s2>&#34;2020-06-01&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>// true
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>regex</span> <span class=o>=</span> <span class=k>new</span> <span class=nb>RegExp</span><span class=p>(</span><span class=sr>/^\d{4}-\d{2}-\d{2}$/</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>regex</span><span class=p>.</span><span class=nx>test</span><span class=p>(</span><span class=s2>&#34;2020-01-01&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>// true
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>regex</span> <span class=o>=</span> <span class=sr>/^\d{4}-\d{2}-\d{2}$/</span>
</span></span><span class=line><span class=cl><span class=s2>&#34;2020-06-01&#34;</span><span class=p>.</span><span class=nx>search</span><span class=p>(</span><span class=nx>regex</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>// 0
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-php data-lang=php><span class=line><span class=cl><span class=nv>$regex</span> <span class=o>=</span> <span class=s1>&#39;/^\d{4}-\d{2}-\d{2}$/&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nv>$ret</span> <span class=o>=</span> <span class=nx>preg_match</span><span class=p>(</span><span class=nv>$regex</span><span class=p>,</span> <span class=s2>&#34;2020-06-01&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>var_dump</span><span class=p>(</span><span class=nv>$ret</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// int(1)
</span></span></span></code></pre></div><p>提取文本内容：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>re</span>
</span></span><span class=line><span class=cl><span class=c1># 没有子组时</span>
</span></span><span class=line><span class=cl><span class=n>reg</span> <span class=o>=</span> <span class=n>re</span><span class=o>.</span><span class=n>compile</span><span class=p>(</span><span class=sa>r</span><span class=s1>&#39;\d</span><span class=si>{4}</span><span class=s1>-\d</span><span class=si>{2}</span><span class=s1>&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>reg</span><span class=o>.</span><span class=n>findall</span><span class=p>(</span><span class=s1>&#39;2020-05 2020-06&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># [&#39;2020-05&#39;, &#39;2020-06&#39;]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 有子组时</span>
</span></span><span class=line><span class=cl><span class=n>reg</span> <span class=o>=</span> <span class=n>re</span><span class=o>.</span><span class=n>compile</span><span class=p>(</span><span class=sa>r</span><span class=s1>&#39;(\d</span><span class=si>{4}</span><span class=s1>)-(\d</span><span class=si>{2}</span><span class=s1>)&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>reg</span><span class=o>.</span><span class=n>findall</span><span class=p>(</span><span class=s1>&#39;2020-05 2020-06&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>[(</span><span class=s1>&#39;2020&#39;</span><span class=p>,</span> <span class=s1>&#39;05&#39;</span><span class=p>),</span> <span class=p>(</span><span class=s1>&#39;2020&#39;</span><span class=p>,</span> <span class=s1>&#39;06&#39;</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>reg</span> <span class=o>=</span> <span class=n>re</span><span class=o>.</span><span class=n>compile</span><span class=p>(</span><span class=sa>r</span><span class=s1>&#39;(\d</span><span class=si>{4}</span><span class=s1>)-(\d</span><span class=si>{2}</span><span class=s1>)&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=k>match</span> <span class=ow>in</span> <span class=n>reg</span><span class=o>.</span><span class=n>finditer</span><span class=p>(</span><span class=s1>&#39;2020-05 2020-06&#39;</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;date: &#39;</span><span class=p>,</span> <span class=k>match</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span>  <span class=c1># 整个正则匹配到的内容</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;year: &#39;</span><span class=p>,</span> <span class=k>match</span><span class=p>[</span><span class=mi>1</span><span class=p>])</span>  <span class=c1># 第一个子组</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;month:&#39;</span><span class=p>,</span> <span class=k>match</span><span class=p>[</span><span class=mi>2</span><span class=p>])</span>  <span class=c1># 第二个子组</span>
</span></span><span class=line><span class=cl><span class=c1># date:  2020-05</span>
</span></span><span class=line><span class=cl><span class=c1># year:  2020</span>
</span></span><span class=line><span class=cl><span class=c1># month: 05</span>
</span></span><span class=line><span class=cl><span class=c1># date:  2020-06</span>
</span></span><span class=line><span class=cl><span class=c1># year:  2020</span>
</span></span><span class=line><span class=cl><span class=c1># month: 06</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=c1>// 使用g模式，查找所有符合要求的内容
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=s2>&#34;2020-06 2020-07&#34;</span><span class=p>.</span><span class=nx>match</span><span class=p>(</span><span class=sr>/\d{4}-\d{2}/g</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>// [&#39;2020-06&#39;, &#39;2020-07&#39;]
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// 不使用g模式，找到第一个就会停下来
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=s2>&#34;2020-06 2020-07&#34;</span><span class=p>.</span><span class=nx>match</span><span class=p>(</span><span class=sr>/\d{4}-\d{2}/</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>// [&#39;2020-06&#39;, index: 0, input: &#39;2020-06 2020-07&#39;, groups: undefined]
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-php data-lang=php><span class=line><span class=cl><span class=nv>$regex</span> <span class=o>=</span> <span class=s2>&#34;/\d{4}-\d{2}/&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nv>$str</span> <span class=o>=</span> <span class=s2>&#34;2020-05 2020-04&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nv>$matchs</span> <span class=o>=</span> <span class=p>[];</span>
</span></span><span class=line><span class=cl><span class=nx>preg_match_all</span><span class=p>(</span><span class=nv>$regex</span><span class=p>,</span> <span class=nv>$str</span><span class=p>,</span> <span class=nv>$matchs</span><span class=p>,</span> <span class=nx>PREG_SET_ORDER</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>var_dump</span><span class=p>(</span><span class=nv>$matchs</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// array(2) {
</span></span></span><span class=line><span class=cl><span class=c1>//   [0] =&gt;
</span></span></span><span class=line><span class=cl><span class=c1>//   array(1) {
</span></span></span><span class=line><span class=cl><span class=c1>//     [0] =&gt;
</span></span></span><span class=line><span class=cl><span class=c1>//     string(7) &#34;2020-05&#34;
</span></span></span><span class=line><span class=cl><span class=c1>//   }
</span></span></span><span class=line><span class=cl><span class=c1>//   [1] =&gt;
</span></span></span><span class=line><span class=cl><span class=c1>//   array(1) {
</span></span></span><span class=line><span class=cl><span class=c1>//     [0] =&gt;
</span></span></span><span class=line><span class=cl><span class=c1>//     string(7) &#34;2020-04&#34;
</span></span></span><span class=line><span class=cl><span class=c1>//   }
</span></span></span><span class=line><span class=cl><span class=c1>// }
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// PREG_PATTERN_ORDER: 结果排序为$matches[0]保存完整模式的所有匹配, $matches[1]保存第一个子组的所有匹配，以此类推。
</span></span></span><span class=line><span class=cl><span class=c1>// PREG_SET_ORDER: 结果排序为$matches[0]包含第一次匹配得到的所有匹配(包含子组)，$matches[1]是包含第二次匹配到的所有匹配(包含子组)的数组，以此类推。
</span></span></span></code></pre></div><p>替换文本内容：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>reg</span> <span class=o>=</span> <span class=n>re</span><span class=o>.</span><span class=n>compile</span><span class=p>(</span><span class=sa>r</span><span class=s1>&#39;(\d</span><span class=si>{2}</span><span class=s1>)-(\d</span><span class=si>{2}</span><span class=s1>)-(\d</span><span class=si>{4}</span><span class=s1>)&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>reg</span><span class=o>.</span><span class=n>sub</span><span class=p>(</span><span class=sa>r</span><span class=s1>&#39;\3年\1月\2日&#39;</span><span class=p>,</span> <span class=s1>&#39;02-20-2020 05-21-2020&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># &#39;2020年02月20日 2020年05月21日&#39;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 可以在替换中使用 \g&lt;数字&gt;，如果分组多于10个时避免歧义</span>
</span></span><span class=line><span class=cl><span class=n>reg</span><span class=o>.</span><span class=n>sub</span><span class=p>(</span><span class=sa>r</span><span class=s1>&#39;\g&lt;3&gt;年\g&lt;1&gt;月\g&lt;2&gt;日&#39;</span><span class=p>,</span> <span class=s1>&#39;02-20-2020 05-21-2020&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># &#39;2020年02月20日 2020年05月21日&#39;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 返回替换次数</span>
</span></span><span class=line><span class=cl><span class=n>reg</span><span class=o>.</span><span class=n>subn</span><span class=p>(</span><span class=sa>r</span><span class=s1>&#39;\3年\1月\2日&#39;</span><span class=p>,</span> <span class=s1>&#39;02-20-2020 05-21-2020&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># (&#39;2020年02月20日 2020年05月21日&#39;, 2)</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=c1>// 使用g模式，替换所有的
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=s2>&#34;02-20-2020 05-21-2020&#34;</span><span class=p>.</span><span class=nx>replace</span><span class=p>(</span><span class=sr>/(\d{2})-(\d{2})-(\d{4})/g</span><span class=p>,</span> <span class=s2>&#34;$3年$1月$2日&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>// &#34;2020年02月20日 2020年05月21日&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// 不使用 g 模式时，只替换一次
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=s2>&#34;02-20-2020 05-21-2020&#34;</span><span class=p>.</span><span class=nx>replace</span><span class=p>(</span><span class=sr>/(\d{2})-(\d{2})-(\d{4})/</span><span class=p>,</span> <span class=s2>&#34;$3年$1月$2日&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>// &#34;2020年02月20日 05-21-2020&#34;
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-php data-lang=php><span class=line><span class=cl><span class=nv>$ret</span> <span class=o>=</span> <span class=nx>preg_replace</span><span class=p>(</span><span class=s1>&#39;/(\d{2})-(\d{2})-(\d{4})/&#39;</span><span class=p>,</span> <span class=s1>&#39;\3年\1月\2日&#39;</span><span class=p>,</span> <span class=s2>&#34;02-20-2020 05-21-2020&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>var_dump</span><span class=p>(</span><span class=nv>$ret</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// string(35) &#34;2020年02月20日 2020年05月21日&#34;
</span></span></span></code></pre></div><p>切割文本内容：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>reg</span> <span class=o>=</span> <span class=n>re</span><span class=o>.</span><span class=n>compile</span><span class=p>(</span><span class=sa>r</span><span class=s1>&#39;\W+&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>reg</span><span class=o>.</span><span class=n>split</span><span class=p>(</span><span class=s2>&#34;apple, pear! orange; tea&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># [&#39;apple&#39;, &#39;pear&#39;, &#39;orange&#39;, &#39;tea&#39;]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 限制切割次数，比如切一刀，变成两部分</span>
</span></span><span class=line><span class=cl><span class=n>reg</span><span class=o>.</span><span class=n>split</span><span class=p>(</span><span class=s2>&#34;apple, pear! orange; tea&#34;</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># [&#39;apple&#39;, &#39;pear! orange; tea&#39;]</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=s2>&#34;apple, pear! orange; tea&#34;</span><span class=p>.</span><span class=nx>split</span><span class=p>(</span><span class=sr>/\W+/</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>// [&#34;apple&#34;, &#34;pear&#34;, &#34;orange&#34;, &#34;tea&#34;]
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// 传入第二个参数的情况
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=s2>&#34;apple, pear! orange; tea&#34;</span><span class=p>.</span><span class=nx>split</span><span class=p>(</span><span class=sr>/\W+/</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>// [&#34;apple&#34;]
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=s2>&#34;apple, pear! orange; tea&#34;</span><span class=p>.</span><span class=nx>split</span><span class=p>(</span><span class=sr>/\W+/</span><span class=p>,</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>// [&#34;apple&#34;, &#34;pear&#34;]
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=s2>&#34;apple, pear! orange; tea&#34;</span><span class=p>.</span><span class=nx>split</span><span class=p>(</span><span class=sr>/\W+/</span><span class=p>,</span> <span class=mi>10</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>// [&#34;apple&#34;, &#34;pear&#34;, &#34;orange&#34;, &#34;tea&#34;]
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-php data-lang=php><span class=line><span class=cl><span class=nv>$ret</span> <span class=o>=</span> <span class=nx>preg_split</span><span class=p>(</span><span class=s1>&#39;/\W+/&#39;</span><span class=p>,</span> <span class=s1>&#39;apple, pear! orange; tea&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>var_dump</span><span class=p>(</span><span class=nv>$ret</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// array(4) {
</span></span></span><span class=line><span class=cl><span class=c1>//   [0] =&gt;
</span></span></span><span class=line><span class=cl><span class=c1>//   string(5) &#34;apple&#34;
</span></span></span><span class=line><span class=cl><span class=c1>//   [1] =&gt;
</span></span></span><span class=line><span class=cl><span class=c1>//   string(4) &#34;pear&#34;
</span></span></span><span class=line><span class=cl><span class=c1>//   [2] =&gt;
</span></span></span><span class=line><span class=cl><span class=c1>//   string(6) &#34;orange&#34;
</span></span></span><span class=line><span class=cl><span class=c1>//   [3] =&gt;
</span></span></span><span class=line><span class=cl><span class=c1>//   string(3) &#34;tea&#34;
</span></span></span><span class=line><span class=cl><span class=c1>// }
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nv>$ret</span> <span class=o>=</span> <span class=nx>preg_split</span><span class=p>(</span><span class=s1>&#39;/\W+/&#39;</span><span class=p>,</span> <span class=s1>&#39;apple, pear! orange; tea&#39;</span><span class=p>,</span> <span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>var_dump</span><span class=p>(</span><span class=nv>$ret</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// array(2) {
</span></span></span><span class=line><span class=cl><span class=c1>//   [0] =&gt;
</span></span></span><span class=line><span class=cl><span class=c1>//   string(5) &#34;apple&#34;
</span></span></span><span class=line><span class=cl><span class=c1>//   [1] =&gt;
</span></span></span><span class=line><span class=cl><span class=c1>//   string(17) &#34;pear! orange; tea&#34;
</span></span></span><span class=line><span class=cl><span class=c1>// }
</span></span></span></code></pre></div><h2 id=11-匹配原理以及优化原则>11 匹配原理以及优化原则<a hidden class=anchor aria-hidden=true href=#11-匹配原理以及优化原则>#</a></h2><p>回溯不可怕，我们要尽量减少回溯后的判断</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>re</span>
</span></span><span class=line><span class=cl><span class=n>x</span> <span class=o>=</span> <span class=s1>&#39;-&#39;</span> <span class=o>*</span> <span class=mi>1000000</span> <span class=o>+</span> <span class=s1>&#39;abc&#39;</span>
</span></span><span class=line><span class=cl><span class=n>timeit</span> <span class=n>re</span><span class=o>.</span><span class=n>search</span><span class=p>(</span><span class=s1>&#39;abc&#39;</span><span class=p>,</span> <span class=n>x</span><span class=p>)</span>
</span></span></code></pre></div><ul><li>提前编译好正则。</li><li>尽量准确表示匹配范围：匹配引号里面的内容 <code>.+?</code> 改写为 <code>[^"]+</code>。</li><li>提取出公共部分：<code>(abcd|abxy)</code> => <code>ab(cd|xy)</code>，<code>(^this|^that)</code> => <code>^th(is|at)</code>。</li><li>出现可能性大的放左边：<code>\.(?:com|net)\b</code>。</li><li>只在必要时才使用子组：把不需要保存子组的括号中加上 <code>?:</code> 来表示只用于归组。</li><li>警惕嵌套的子组重复：<code>(.*)*</code> 匹配的次数会呈指数级增长，尽量不要写这样的正则。</li><li>避免不同分支重复匹配。</li></ul><p>NFA 是以表达式为主导的，先看正则表达式，再看文本。而 DFA 则是以文本为主导的，先看文本，再看正则表达式。POSIX NFA 是指符合 POSIX 标准的 NFA 引擎，它会不断回溯，以确保找到最左侧最长匹配。</p><h2 id=12-常见问题>12 常见问题<a hidden class=anchor aria-hidden=true href=#12-常见问题>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>re</span>
</span></span><span class=line><span class=cl><span class=n>re</span><span class=o>.</span><span class=k>match</span><span class=p>(</span><span class=sa>r</span><span class=s1>&#39;^(?:(?!\d\d)\w)</span><span class=si>{6}</span><span class=s1>$&#39;</span><span class=p>,</span> <span class=s1>&#39;11abcd&#39;</span><span class=p>)</span> <span class=c1># 不能匹配上</span>
</span></span><span class=line><span class=cl><span class=c1># 否定预测先行断言的语法&#34;(?!)&#34;来排除两个数字字符结尾的情况</span>
</span></span><span class=line><span class=cl><span class=c1># (?!) 表示匹配不满足某个条件的位置</span>
</span></span><span class=line><span class=cl><span class=n>re</span><span class=o>.</span><span class=k>match</span><span class=p>(</span><span class=sa>r</span><span class=s1>&#39;^(?:\w(?!\d\d))</span><span class=si>{6}</span><span class=s1>$&#39;</span><span class=p>,</span> <span class=s1>&#39;11abcd&#39;</span><span class=p>)</span> <span class=c1># 错误正则示范</span>
</span></span><span class=line><span class=cl><span class=c1># &lt;re.Match object; span=(0, 6), match=&#39;11abcd&#39;&gt;</span>
</span></span><span class=line><span class=cl><span class=c1># (11) 回溯</span>
</span></span><span class=line><span class=cl><span class=c1># 1(1a) ok</span>
</span></span><span class=line><span class=cl><span class=c1># 11ab... ok</span>
</span></span></code></pre></div><ul><li>正负号、可二位小数、小数位末尾 0 无影响 <a href="https://jex.im/regulex/#!flags=&amp;re=%5E%5B-%2B%5D%3F%5Cd%2B(%3F%3A%5C.(%3F%3A%5Cd)%7B0%2C2%7D0*)%3F%24">Regulex</a>：<code>^[-+]?\d+(?:\.(?:\d){0,2}0*)?$</code></li><li>手机号码：<code>1(?:3\d|4[5-9]|5[0-35-9]|6[2567]|7[0-8]|8\d|9[1389])\d{8}</code></li><li>身份证：<code>[1-9]\d{14}(\d\d[0-9Xx])?</code></li><li>邮政编码：<code>(?&lt;!\d)\d{6}(?!\d)</code></li><li>中文字符：<code>[\u4E00-\u9FFF]</code> <code>\p{Han}</code></li><li>邮箱：<code>a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+</code></li></ul><h2 id=程语言的角度来理解正则>程语言的角度来理解正则<a hidden class=anchor aria-hidden=true href=#程语言的角度来理解正则>#</a></h2><ul><li>命令式编程的世界观是：程序是由若干行动指令组成的有序列表；</li><li>命令式编程的方法论是：用变量来存储数据，用语句来执行指令。</li><li>声明式编程的世界观是：程序是由若干目标任务组成的有序列表；</li><li>声明式编程的方法论是：用语法元素来描述任务，由解析引擎转化为指令并执行。</li></ul><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><ul><li>《精通正则表达式（第三版）》</li><li>《正则指引（第二版）》</li></ul><p>&ndash; EOF &ndash;</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://zyf.im/tags/regular-expression/>Regular-Expression</a></li></ul><nav class=paginav><a class=prev href=https://zyf.im/2023/03/09/hands-on-ddd-part1/><span class=title>« Prev</span><br><span>手把手教你落地 DDD Part1</span>
</a><a class=next href=https://zyf.im/2023/02/28/vim-practical-tips/><span class=title>Next »</span><br><span>Vim 实用技巧必知必会</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://zyf.im/>ZYF.IM BLOG</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>