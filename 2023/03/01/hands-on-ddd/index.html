<!doctype html><html lang=en dir=auto data-theme=dark><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>手把手教你落地 DDD | ZYF.IM BLOG</title><meta name=keywords content="ddd,design-pattern"><meta name=description content="01 DDD 小传
DDD（Domain-Driven Design）由 Eric Evans 于 2003 年提出，本质是一套用于开发复杂软件的系统化方法学与思想，核心关注“领域建模”。它源于面向对象方法学与敏捷开发，可理解为“把面向对象做对”（OO Done right），并将建模、设计与落地实践更体系化。
传统面向对象在企业应用中常见问题是重技术轻业务、领域建模难以掌握、协作与沟通不足、难以适应频繁变化。DDD 通过模式、原则与实践（如通用语言、限界上下文、模型驱动设计等）促进业务与技术协作沉淀知识，并用“柔性设计/演进”避免过度设计、支持持续重构。
近年因数字化带来更高复杂度与变化，以及敏捷/DevOps 与 Spring Boot、微服务、整洁架构、事件驱动、CQRS 等生态成熟，DDD 才从“屠龙术”变成广泛可用的方法。
02 迭代一 企业管理系统
企业为了满足管理诉求，希望员工每周在系统中填报自己在哪些项目上花了多少时间，也就是所谓的报工时。

  
      
          需求
          核心对象/范围
          主要功能（CRUD/流程）
          关键规则/约束
          关键字段/记录
      
  
  
      
          多租户
          租户（企业）
          管理多个租户（企业）
          每个租户代表一个使用 SaaS 的企业
          —
      
      
          人员与组织管理
          部门、员工
          部门：增删改查；员工：增删改查；员工分配部门
          员工只能从属于一个部门
          部门层级示例：开发中心 → 开发组；职能部门（人事/财务等）
      
      
          项目管理
          客户、合同、项目
          客户：增删改查；合同：增删改查 + 开始/结束；项目：增删改查 + 开始/结束
          客户对应客户经理；合同对应销售；项目对应项目经理；合同下可有多个项目
          合同/项目开始时间、结束时间等
      
      
          人员分配
          项目成员关系
          为项目分配人员；人员退出项目
          项目可多人；员工可同时参与多个项目；需记录投入比例
          投入百分比（人-项目）
      
      
          工时登记
          工时（周报/日记录）
          员工每周填报工时；查询；修改；填写备注
          仅当员工已分配到项目后，才可在该项目报工时
          日期、项目、投入时长、备注
      
  


03 事件风暴 识别领域事件

领域事件是什么
**领域事件（Domain Event）**用来表达：在业务流程的某一步完成后，所引发并被业务关心的“结果”。"><meta name=author content="Me"><link rel=canonical href=https://zyf.im/2023/03/01/hands-on-ddd/><link crossorigin=anonymous href=/assets/css/stylesheet.88888b1f97bcb20b824590bc7c6603a852913a2540638b3b3e2663e642691da3.css integrity="sha256-iIiLH5e8sguCRZC8fGYDqFKROiVAY4s7PiZj5kJpHaM=" rel="preload stylesheet" as=style><link rel=icon href=https://zyf.im/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zyf.im/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://zyf.im/favicon-32x32.png><link rel=apple-touch-icon href=https://zyf.im/apple-touch-icon.png><link rel=mask-icon href=https://zyf.im/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://zyf.im/2023/03/01/hands-on-ddd/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script>localStorage.getItem("pref-theme")==="light"&&(document.querySelector("html").dataset.theme="light")</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-6DVZ6E58DG"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-6DVZ6E58DG")}</script><meta property="og:url" content="https://zyf.im/2023/03/01/hands-on-ddd/"><meta property="og:site_name" content="ZYF.IM BLOG"><meta property="og:title" content="手把手教你落地 DDD"><meta property="og:description" content="01 DDD 小传 DDD（Domain-Driven Design）由 Eric Evans 于 2003 年提出，本质是一套用于开发复杂软件的系统化方法学与思想，核心关注“领域建模”。它源于面向对象方法学与敏捷开发，可理解为“把面向对象做对”（OO Done right），并将建模、设计与落地实践更体系化。
传统面向对象在企业应用中常见问题是重技术轻业务、领域建模难以掌握、协作与沟通不足、难以适应频繁变化。DDD 通过模式、原则与实践（如通用语言、限界上下文、模型驱动设计等）促进业务与技术协作沉淀知识，并用“柔性设计/演进”避免过度设计、支持持续重构。
近年因数字化带来更高复杂度与变化，以及敏捷/DevOps 与 Spring Boot、微服务、整洁架构、事件驱动、CQRS 等生态成熟，DDD 才从“屠龙术”变成广泛可用的方法。
02 迭代一 企业管理系统 企业为了满足管理诉求，希望员工每周在系统中填报自己在哪些项目上花了多少时间，也就是所谓的报工时。
需求 核心对象/范围 主要功能（CRUD/流程） 关键规则/约束 关键字段/记录 多租户 租户（企业） 管理多个租户（企业） 每个租户代表一个使用 SaaS 的企业 — 人员与组织管理 部门、员工 部门：增删改查；员工：增删改查；员工分配部门 员工只能从属于一个部门 部门层级示例：开发中心 → 开发组；职能部门（人事/财务等） 项目管理 客户、合同、项目 客户：增删改查；合同：增删改查 + 开始/结束；项目：增删改查 + 开始/结束 客户对应客户经理；合同对应销售；项目对应项目经理；合同下可有多个项目 合同/项目开始时间、结束时间等 人员分配 项目成员关系 为项目分配人员；人员退出项目 项目可多人；员工可同时参与多个项目；需记录投入比例 投入百分比（人-项目） 工时登记 工时（周报/日记录） 员工每周填报工时；查询；修改；填写备注 仅当员工已分配到项目后，才可在该项目报工时 日期、项目、投入时长、备注 03 事件风暴 识别领域事件 领域事件是什么 **领域事件（Domain Event）**用来表达：在业务流程的某一步完成后，所引发并被业务关心的“结果”。"><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-03-01T17:00:00+08:00"><meta property="article:modified_time" content="2023-03-01T17:00:00+08:00"><meta property="article:tag" content="Ddd"><meta property="article:tag" content="Design-Pattern"><meta name=twitter:card content="summary"><meta name=twitter:title content="手把手教你落地 DDD"><meta name=twitter:description content="01 DDD 小传
DDD（Domain-Driven Design）由 Eric Evans 于 2003 年提出，本质是一套用于开发复杂软件的系统化方法学与思想，核心关注“领域建模”。它源于面向对象方法学与敏捷开发，可理解为“把面向对象做对”（OO Done right），并将建模、设计与落地实践更体系化。
传统面向对象在企业应用中常见问题是重技术轻业务、领域建模难以掌握、协作与沟通不足、难以适应频繁变化。DDD 通过模式、原则与实践（如通用语言、限界上下文、模型驱动设计等）促进业务与技术协作沉淀知识，并用“柔性设计/演进”避免过度设计、支持持续重构。
近年因数字化带来更高复杂度与变化，以及敏捷/DevOps 与 Spring Boot、微服务、整洁架构、事件驱动、CQRS 等生态成熟，DDD 才从“屠龙术”变成广泛可用的方法。
02 迭代一 企业管理系统
企业为了满足管理诉求，希望员工每周在系统中填报自己在哪些项目上花了多少时间，也就是所谓的报工时。

  
      
          需求
          核心对象/范围
          主要功能（CRUD/流程）
          关键规则/约束
          关键字段/记录
      
  
  
      
          多租户
          租户（企业）
          管理多个租户（企业）
          每个租户代表一个使用 SaaS 的企业
          —
      
      
          人员与组织管理
          部门、员工
          部门：增删改查；员工：增删改查；员工分配部门
          员工只能从属于一个部门
          部门层级示例：开发中心 → 开发组；职能部门（人事/财务等）
      
      
          项目管理
          客户、合同、项目
          客户：增删改查；合同：增删改查 + 开始/结束；项目：增删改查 + 开始/结束
          客户对应客户经理；合同对应销售；项目对应项目经理；合同下可有多个项目
          合同/项目开始时间、结束时间等
      
      
          人员分配
          项目成员关系
          为项目分配人员；人员退出项目
          项目可多人；员工可同时参与多个项目；需记录投入比例
          投入百分比（人-项目）
      
      
          工时登记
          工时（周报/日记录）
          员工每周填报工时；查询；修改；填写备注
          仅当员工已分配到项目后，才可在该项目报工时
          日期、项目、投入时长、备注
      
  


03 事件风暴 识别领域事件

领域事件是什么
**领域事件（Domain Event）**用来表达：在业务流程的某一步完成后，所引发并被业务关心的“结果”。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zyf.im/posts/"},{"@type":"ListItem","position":2,"name":"手把手教你落地 DDD","item":"https://zyf.im/2023/03/01/hands-on-ddd/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"手把手教你落地 DDD","name":"手把手教你落地 DDD","description":"01 DDD 小传 DDD（Domain-Driven Design）由 Eric Evans 于 2003 年提出，本质是一套用于开发复杂软件的系统化方法学与思想，核心关注“领域建模”。它源于面向对象方法学与敏捷开发，可理解为“把面向对象做对”（OO Done right），并将建模、设计与落地实践更体系化。\n传统面向对象在企业应用中常见问题是重技术轻业务、领域建模难以掌握、协作与沟通不足、难以适应频繁变化。DDD 通过模式、原则与实践（如通用语言、限界上下文、模型驱动设计等）促进业务与技术协作沉淀知识，并用“柔性设计/演进”避免过度设计、支持持续重构。\n近年因数字化带来更高复杂度与变化，以及敏捷/DevOps 与 Spring Boot、微服务、整洁架构、事件驱动、CQRS 等生态成熟，DDD 才从“屠龙术”变成广泛可用的方法。\n02 迭代一 企业管理系统 企业为了满足管理诉求，希望员工每周在系统中填报自己在哪些项目上花了多少时间，也就是所谓的报工时。\n需求 核心对象/范围 主要功能（CRUD/流程） 关键规则/约束 关键字段/记录 多租户 租户（企业） 管理多个租户（企业） 每个租户代表一个使用 SaaS 的企业 — 人员与组织管理 部门、员工 部门：增删改查；员工：增删改查；员工分配部门 员工只能从属于一个部门 部门层级示例：开发中心 → 开发组；职能部门（人事/财务等） 项目管理 客户、合同、项目 客户：增删改查；合同：增删改查 + 开始/结束；项目：增删改查 + 开始/结束 客户对应客户经理；合同对应销售；项目对应项目经理；合同下可有多个项目 合同/项目开始时间、结束时间等 人员分配 项目成员关系 为项目分配人员；人员退出项目 项目可多人；员工可同时参与多个项目；需记录投入比例 投入百分比（人-项目） 工时登记 工时（周报/日记录） 员工每周填报工时；查询；修改；填写备注 仅当员工已分配到项目后，才可在该项目报工时 日期、项目、投入时长、备注 03 事件风暴 识别领域事件 领域事件是什么 **领域事件（Domain Event）**用来表达：在业务流程的某一步完成后，所引发并被业务关心的“结果”。\n","keywords":["ddd","design-pattern"],"articleBody":"01 DDD 小传 DDD（Domain-Driven Design）由 Eric Evans 于 2003 年提出，本质是一套用于开发复杂软件的系统化方法学与思想，核心关注“领域建模”。它源于面向对象方法学与敏捷开发，可理解为“把面向对象做对”（OO Done right），并将建模、设计与落地实践更体系化。\n传统面向对象在企业应用中常见问题是重技术轻业务、领域建模难以掌握、协作与沟通不足、难以适应频繁变化。DDD 通过模式、原则与实践（如通用语言、限界上下文、模型驱动设计等）促进业务与技术协作沉淀知识，并用“柔性设计/演进”避免过度设计、支持持续重构。\n近年因数字化带来更高复杂度与变化，以及敏捷/DevOps 与 Spring Boot、微服务、整洁架构、事件驱动、CQRS 等生态成熟，DDD 才从“屠龙术”变成广泛可用的方法。\n02 迭代一 企业管理系统 企业为了满足管理诉求，希望员工每周在系统中填报自己在哪些项目上花了多少时间，也就是所谓的报工时。\n需求 核心对象/范围 主要功能（CRUD/流程） 关键规则/约束 关键字段/记录 多租户 租户（企业） 管理多个租户（企业） 每个租户代表一个使用 SaaS 的企业 — 人员与组织管理 部门、员工 部门：增删改查；员工：增删改查；员工分配部门 员工只能从属于一个部门 部门层级示例：开发中心 → 开发组；职能部门（人事/财务等） 项目管理 客户、合同、项目 客户：增删改查；合同：增删改查 + 开始/结束；项目：增删改查 + 开始/结束 客户对应客户经理；合同对应销售；项目对应项目经理；合同下可有多个项目 合同/项目开始时间、结束时间等 人员分配 项目成员关系 为项目分配人员；人员退出项目 项目可多人；员工可同时参与多个项目；需记录投入比例 投入百分比（人-项目） 工时登记 工时（周报/日记录） 员工每周填报工时；查询；修改；填写备注 仅当员工已分配到项目后，才可在该项目报工时 日期、项目、投入时长、备注 03 事件风暴 识别领域事件 领域事件是什么 **领域事件（Domain Event）**用来表达：在业务流程的某一步完成后，所引发并被业务关心的“结果”。\n常见表达方式有一个很实用的习惯：\n完成时 被动语态 在 DDD 的各种命名中，优先使用约定俗成的业务术语，因为这些词本身就承载着业务知识与共识。\n领域事件的边界：两条关键提醒 在识别领域事件时，有两点特别容易踩坑：\n不要把技术事件当成领域事件。领域事件强调的是 业务上发生了什么，而不是 系统内部做了什么。 查询功能不算领域事件。查询行为通常不会改变业务世界的状态，因此一般 不构成领域事件。领域事件应当满足一个直觉标准： 对某样事物产生了影响 该影响是业务要记录/追踪的 或者它触发了对外通知（发消息给其他人或系统） 换句话说，领域事件通常对应“业务状态发生改变”或“业务需要对外告知”。\n如何识别领域事件：先发散，再收敛 个人发散：参与者各自写出自己理解的领域事件（尽量不互相干扰） 集体收敛：一起讨论、对齐含义、合并同类项、澄清歧义 这种“先发散、后收敛、反复迭代”的方式，本质上就是一种结构化的头脑风暴：先把可能性铺开，再通过讨论把共识沉淀下来。\n统一语言：事件风暴的隐性产出 在上述讨论过程中，其实已经在生成并强化 统一语言（Ubiquitous Language）。统一语言的核心是：\n业务人员和开发人员使用同一套词。 同一个词在不同人心里对应同一个概念。 语言一致意味着领域理解一致（语言是知识的载体）。 它不是某个阶段的文档，而是贯穿 DDD 全过程的基础设施。\n事件风暴的精髓是“协作” 事件风暴表面上是在贴事件、理流程，但真正关键的价值在于：\n让不同角色共同参与。 通过讨论对齐概念与边界。 在协作中形成统一语言与共同理解。 04 事件风暴 识别命令和识别领域名词 命令是什么：从领域事件反推 命令 = 引发领域事件的操作。做法上可以理解为一条简单的逆向链路：\n先有领域事件（结果） 再问：是谁做了什么，才让这个结果发生？ 除了命令本身，事件风暴里往往还会顺手补齐两类“命令的上下文信息”：\n执行者是谁？命令由谁发起/执行：可能是某个用户、某个岗位角色，也可能是系统内的某个领域对象在扮演某种角色，甚至与权限体系的角色有关。 执行命令前需要查询什么数据？为了执行该命令，需要先拿到哪些信息（用于校验、决策、填充表单、定位对象等）。 识别领域名词：从贴纸里提取“名词性概念” 这里的领域名词指：从命令、领域事件、执行者、查询数据中提取出来的名词性概念。举例理解：\n命令：签订合同。被影响的核心名词：合同 领域事件：合同已签订。本质上是名词“合同”的状态发生变化，并被业务记录为一个重要结果。 领域规则如何保存：用“领域规则表”沉淀 领域规则是关键领域知识，必须可维护、可追溯。仅靠便利贴或图：\n难长期保存 难版本化管理 难持续更新 更可行的方式是建立一个领域规则表：\n将事件风暴阶段识别出的规则先记录进去 在后续领域建模中补充新规则 与领域模型放在一起，作为领域知识的核心资产共同维护 05 领域建模实践 上 从事件风暴产出的 领域名词 出发做领域建模：先将名词 暂定为实体，再梳理实体间的 关联类型（1:1 / 1:N / M:N）；建模时持续做 抽象提炼 以发现 隐含实体、让模型更贴近业务本质；最后用 注释 与 约束 补齐业务知识，其中 约束必须落到代码或数据库 并纳入业务规则表。\n06 领域建模实践 下 通过引入 关联实体 将 多对多 关系拆成两个 一对多，并为实体补齐必要的 业务操作；当模型复杂时，可按 模块拆分 来提升可理解性。领域模型完成后，还要抓住两项落地 DDD 的关键实践：补齐 业务规则、建立 词汇表（统一语言），它们是确保模型可执行、团队认知一致的重点。\n07 领域建模原理 DDD 的 领域模型 是对领域知识的 提炼抽象，同时兼顾 业务表达 与 技术落地 ；在 模型驱动设计 下要做到 领域模型 ↔ 业务需求一致、系统实现 ↔ 领域模型一致，从而确保 实现 ↔ 需求一致；而 统一语言 以领域模型与词汇表为基础，通过 持续协作 不断维护 模型、语言与实现 三者的 一致性。\n08 数据库设计 数据库三范式（3 Normal Form）。1NF 字段原子性：\n表中的每一列都必须是不可再分的原子值。 不允许在一个字段里存多个值、列表或重复组。 例：主键是(订单ID, 商品ID)，若订单日期只依赖订单ID，就不符合 2NF，应把订单信息拆到订单表。\n2NF 消除对主键的部分依赖：\n在满足 1NF 的基础上，要求非主属性必须完全依赖于整个主键。 主要针对联合主键的情况：不能只依赖主键的一部分。 例：主键是(订单ID, 商品ID)，若订单日期只依赖订单ID，就不符合 2NF，应把订单信息拆到订单表。\n3NF 消除传递依赖\n在满足 2NF 的基础上，要求非主属性不依赖于其他非主属性（即没有传递依赖）。 非主属性应当直接依赖主键。 例：员工ID -\u003e 部门ID -\u003e 部门名称，则部门名称是通过部门ID间接决定的，应拆出部门表存部门ID, 部门名称。\nDDD 强调用 领域模型驱动数据库设计，以保证 业务、代码、数据一致：实体→表、属性→字段（按需求补充），并通过 词汇表/统一语言 规范命名；关系设计上，一对多用外键（云上常见 “虚拟外键”），多对多用关联表；相较“拍脑袋”式建模，这种方式更容易 与业务对齐、更符合 范式，还能把 静态数据结构 与 动态业务逻辑 统一纳入同一套模型中。\n09 分层架构 分层架构的原则是让不稳定的部分依赖稳定的部分：越靠内层越稳定、越靠外层越易变；其中领域层封装领域数据与规则，是系统核心，应用层作为门面把领域能力组织成粗粒度服务并处理事务、日志等横切关注点；外部交互由适配器层承担，主动适配器接收外部请求、被动适配器访问外部资源，二者只是在调用方向上不同，从而把技术细节隔离在外层，使应用层与领域层保持技术无关；数据访问上，仓库以聚合为单位（此处可暂按“一个实体一个仓库”理解），而 DAO 以表为单位；另设 common 层承载工具与框架，为各层提供支撑。\n10 代码实现 要“贫血”还是要“充血” 贫血模型（Anemic Domain Model，Fowler 2003）指领域对象 只有数据没有行为，违背面向对象原则；相对的富/充血模型（Rich Domain Model）强调领域对象应同时包含数据 + 行为，更贴近真正的面向对象（可理解为贫血更偏 面向过程、富模型更偏 面向对象），但企业实践中两者并非非黑即白，应结合多种范式；落到编码，核心要求是 代码与模型一致（发现模型问题要 及时改模型），并解决 层间依赖：将 DTO 移到应用层、用 依赖倒置 让适配器层依赖领域层，同时理解 领域模型 vs 设计模型（UML） 的区别，以便明确哪些和业务讨论、哪些仅在工程内部讨论，从而提升抽象分层下的沟通与效率。\n11 代码实现 创建领域对象、实现领域逻辑 实现领域逻辑时应使用能表达领域知识的命名，即 DDD 表意接口（Intention-Revealing Interfaces）；一旦违背，常见坏味道是 函数过长 与 注释过多，可用 抽取函数 重构解决。需区分 领域逻辑 与 应用逻辑，关键在于是否包含领域专家关心的 领域知识；领域逻辑应优先放入 领域对象，不适合放入对象的则放入 领域服务。复杂对象的创建推荐用 工厂（Factory），参数少可直接调用工厂，参数多可配合 Builder。模块划分有按性质（横切）与按耦合/业务（纵切）两种，建议采用 先横后竖 的策略。\n12 代码实现 更加“面向对象” – EOF –\n","wordCount":"299","inLanguage":"en","datePublished":"2023-03-01T17:00:00+08:00","dateModified":"2023-03-01T17:00:00+08:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zyf.im/2023/03/01/hands-on-ddd/"},"publisher":{"@type":"Organization","name":"ZYF.IM BLOG","logo":{"@type":"ImageObject","url":"https://zyf.im/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://zyf.im/ accesskey=h title="ZYF.IM (Alt + H)"><img src=https://zyf.im/apple-touch-icon.png alt aria-label=logo height=35>ZYF.IM</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://zyf.im/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://zyf.im/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://zyf.im/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://zyf.im/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://zyf.im/>Home</a>&nbsp;»&nbsp;<a href=https://zyf.im/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">手把手教你落地 DDD</h1><div class=post-meta><span title='2023-03-01 17:00:00 +0800 CST'>March 1, 2023</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>299 words</span>&nbsp;·&nbsp;<span>Me</span></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#01-ddd-小传>01 DDD 小传</a></li><li><a href=#02-迭代一-企业管理系统>02 迭代一 企业管理系统</a></li><li><a href=#03-事件风暴-识别领域事件>03 事件风暴 识别领域事件</a><ul><li><a href=#领域事件是什么>领域事件是什么</a></li><li><a href=#领域事件的边界两条关键提醒>领域事件的边界：两条关键提醒</a></li><li><a href=#如何识别领域事件先发散再收敛>如何识别领域事件：先发散，再收敛</a></li><li><a href=#统一语言事件风暴的隐性产出>统一语言：事件风暴的隐性产出</a></li><li><a href=#事件风暴的精髓是协作>事件风暴的精髓是“协作”</a></li></ul></li><li><a href=#04-事件风暴-识别命令和识别领域名词>04 事件风暴 识别命令和识别领域名词</a><ul><li><a href=#命令是什么从领域事件反推>命令是什么：从领域事件反推</a></li><li><a href=#识别领域名词从贴纸里提取名词性概念>识别领域名词：从贴纸里提取“名词性概念”</a></li><li><a href=#领域规则如何保存用领域规则表沉淀>领域规则如何保存：用“领域规则表”沉淀</a></li></ul></li><li><a href=#05-领域建模实践-上>05 领域建模实践 上</a></li><li><a href=#06-领域建模实践-下>06 领域建模实践 下</a></li><li><a href=#07-领域建模原理>07 领域建模原理</a></li><li><a href=#08-数据库设计>08 数据库设计</a></li><li><a href=#09-分层架构>09 分层架构</a></li><li><a href=#10-代码实现-要贫血还是要充血>10 代码实现 要“贫血”还是要“充血”</a></li><li><a href=#11-代码实现-创建领域对象实现领域逻辑>11 代码实现 创建领域对象、实现领域逻辑</a></li><li><a href=#12-代码实现-更加面向对象>12 代码实现 更加“面向对象”</a></li></ul></nav></div></details></div><div class=post-content><h2 id=01-ddd-小传>01 DDD 小传<a hidden class=anchor aria-hidden=true href=#01-ddd-小传>#</a></h2><p>DDD（Domain-Driven Design）由 Eric Evans 于 2003 年提出，本质是一套用于开发复杂软件的系统化方法学与思想，核心关注“领域建模”。它源于面向对象方法学与敏捷开发，可理解为“把面向对象做对”（OO Done right），并将建模、设计与落地实践更体系化。</p><p>传统面向对象在企业应用中常见问题是重技术轻业务、领域建模难以掌握、协作与沟通不足、难以适应频繁变化。DDD 通过模式、原则与实践（如通用语言、限界上下文、模型驱动设计等）促进业务与技术协作沉淀知识，并用“柔性设计/演进”避免过度设计、支持持续重构。</p><p>近年因数字化带来更高复杂度与变化，以及敏捷/DevOps 与 Spring Boot、微服务、整洁架构、事件驱动、CQRS 等生态成熟，DDD 才从“屠龙术”变成广泛可用的方法。</p><h2 id=02-迭代一-企业管理系统>02 迭代一 企业管理系统<a hidden class=anchor aria-hidden=true href=#02-迭代一-企业管理系统>#</a></h2><p>企业为了满足管理诉求，希望员工每周在系统中填报自己在哪些项目上花了多少时间，也就是所谓的报工时。</p><table><thead><tr><th>需求</th><th>核心对象/范围</th><th>主要功能（CRUD/流程）</th><th>关键规则/约束</th><th>关键字段/记录</th></tr></thead><tbody><tr><td>多租户</td><td>租户（企业）</td><td>管理多个租户（企业）</td><td>每个租户代表一个使用 SaaS 的企业</td><td>—</td></tr><tr><td>人员与组织管理</td><td>部门、员工</td><td>部门：增删改查；员工：增删改查；员工分配部门</td><td>员工只能从属于一个部门</td><td>部门层级示例：开发中心 → 开发组；职能部门（人事/财务等）</td></tr><tr><td>项目管理</td><td>客户、合同、项目</td><td>客户：增删改查；合同：增删改查 + 开始/结束；项目：增删改查 + 开始/结束</td><td>客户对应客户经理；合同对应销售；项目对应项目经理；合同下可有多个项目</td><td>合同/项目开始时间、结束时间等</td></tr><tr><td>人员分配</td><td>项目成员关系</td><td>为项目分配人员；人员退出项目</td><td>项目可多人；员工可同时参与多个项目；需记录投入比例</td><td>投入百分比（人-项目）</td></tr><tr><td>工时登记</td><td>工时（周报/日记录）</td><td>员工每周填报工时；查询；修改；填写备注</td><td>仅当员工已分配到项目后，才可在该项目报工时</td><td>日期、项目、投入时长、备注</td></tr></tbody></table><p><img alt=image loading=lazy src=https://github.com/user-attachments/assets/24f28aeb-1862-4289-ad76-3d7c0ba502e7></p><h2 id=03-事件风暴-识别领域事件>03 事件风暴 识别领域事件<a hidden class=anchor aria-hidden=true href=#03-事件风暴-识别领域事件>#</a></h2><p><img alt=image loading=lazy src=https://github.com/user-attachments/assets/a7cef40f-519f-4be2-b514-b577546ca51e></p><h3 id=领域事件是什么>领域事件是什么<a hidden class=anchor aria-hidden=true href=#领域事件是什么>#</a></h3><p>**领域事件（Domain Event）**用来表达：在业务流程的某一步完成后，所引发并被业务关心的“结果”。</p><p>常见表达方式有一个很实用的习惯：</p><ol><li>完成时</li><li>被动语态</li></ol><p>在 DDD 的各种命名中，优先使用约定俗成的业务术语，因为这些词本身就承载着业务知识与共识。</p><p><img alt=image loading=lazy src=https://github.com/user-attachments/assets/552968ac-8fdb-4929-aa7c-deb31693f9ea></p><h3 id=领域事件的边界两条关键提醒>领域事件的边界：两条关键提醒<a hidden class=anchor aria-hidden=true href=#领域事件的边界两条关键提醒>#</a></h3><p>在识别领域事件时，有两点特别容易踩坑：</p><ol><li>不要把技术事件当成领域事件。领域事件强调的是 <strong>业务上发生了什么</strong>，而不是 <strong>系统内部做了什么</strong>。</li><li>查询功能不算领域事件。查询行为通常不会改变业务世界的状态，因此一般 <strong>不构成领域事件</strong>。领域事件应当满足一个直觉标准：<ol><li>对某样事物产生了影响</li><li>该影响是业务要记录/追踪的</li><li>或者它触发了对外通知（发消息给其他人或系统）</li></ol></li></ol><p>换句话说，领域事件通常对应“业务状态发生改变”或“业务需要对外告知”。</p><h3 id=如何识别领域事件先发散再收敛>如何识别领域事件：先发散，再收敛<a hidden class=anchor aria-hidden=true href=#如何识别领域事件先发散再收敛>#</a></h3><ol><li>个人发散：参与者各自写出自己理解的领域事件（尽量不互相干扰）</li><li>集体收敛：一起讨论、对齐含义、合并同类项、澄清歧义</li></ol><p>这种“先发散、后收敛、反复迭代”的方式，本质上就是一种结构化的头脑风暴：先把可能性铺开，再通过讨论把共识沉淀下来。</p><h3 id=统一语言事件风暴的隐性产出>统一语言：事件风暴的隐性产出<a hidden class=anchor aria-hidden=true href=#统一语言事件风暴的隐性产出>#</a></h3><p>在上述讨论过程中，其实已经在生成并强化 统一语言（Ubiquitous Language）。统一语言的核心是：</p><ul><li>业务人员和开发人员使用同一套词。</li><li>同一个词在不同人心里对应同一个概念。</li><li>语言一致意味着领域理解一致（语言是知识的载体）。</li></ul><p>它不是某个阶段的文档，而是贯穿 DDD 全过程的基础设施。</p><h3 id=事件风暴的精髓是协作>事件风暴的精髓是“协作”<a hidden class=anchor aria-hidden=true href=#事件风暴的精髓是协作>#</a></h3><p>事件风暴表面上是在贴事件、理流程，但真正关键的价值在于：</p><ul><li>让不同角色共同参与。</li><li>通过讨论对齐概念与边界。</li><li>在协作中形成统一语言与共同理解。</li></ul><h2 id=04-事件风暴-识别命令和识别领域名词>04 事件风暴 识别命令和识别领域名词<a hidden class=anchor aria-hidden=true href=#04-事件风暴-识别命令和识别领域名词>#</a></h2><h3 id=命令是什么从领域事件反推>命令是什么：从领域事件反推<a hidden class=anchor aria-hidden=true href=#命令是什么从领域事件反推>#</a></h3><p>命令 = 引发领域事件的操作。做法上可以理解为一条简单的逆向链路：</p><ol><li>先有领域事件（结果）</li><li>再问：是谁做了什么，才让这个结果发生？</li></ol><p>除了命令本身，事件风暴里往往还会顺手补齐两类“命令的上下文信息”：</p><ul><li>执行者是谁？命令由谁发起/执行：可能是某个用户、某个岗位角色，也可能是系统内的某个领域对象在扮演某种角色，甚至与权限体系的角色有关。</li><li>执行命令前需要查询什么数据？为了执行该命令，需要先拿到哪些信息（用于校验、决策、填充表单、定位对象等）。</li></ul><h3 id=识别领域名词从贴纸里提取名词性概念>识别领域名词：从贴纸里提取“名词性概念”<a hidden class=anchor aria-hidden=true href=#识别领域名词从贴纸里提取名词性概念>#</a></h3><p>这里的领域名词指：从命令、领域事件、执行者、查询数据中提取出来的名词性概念。举例理解：</p><ul><li>命令：签订合同。被影响的核心名词：合同</li><li>领域事件：合同已签订。本质上是名词“合同”的状态发生变化，并被业务记录为一个重要结果。</li></ul><h3 id=领域规则如何保存用领域规则表沉淀>领域规则如何保存：用“领域规则表”沉淀<a hidden class=anchor aria-hidden=true href=#领域规则如何保存用领域规则表沉淀>#</a></h3><p>领域规则是关键领域知识，必须可维护、可追溯。仅靠便利贴或图：</p><ul><li>难长期保存</li><li>难版本化管理</li><li>难持续更新</li></ul><p>更可行的方式是建立一个领域规则表：</p><ul><li>将事件风暴阶段识别出的规则先记录进去</li><li>在后续领域建模中补充新规则</li><li>与领域模型放在一起，作为领域知识的核心资产共同维护</li></ul><h2 id=05-领域建模实践-上>05 领域建模实践 上<a hidden class=anchor aria-hidden=true href=#05-领域建模实践-上>#</a></h2><p>从事件风暴产出的 <strong>领域名词</strong> 出发做领域建模：先将名词 <strong>暂定为实体</strong>，再梳理实体间的 <strong>关联类型（1:1 / 1:N / M:N）</strong>；建模时持续做 <strong>抽象提炼</strong> 以发现 <strong>隐含实体</strong>、让模型更贴近业务本质；最后用 <strong>注释</strong> 与 <strong>约束</strong> 补齐业务知识，其中 <strong>约束必须落到代码或数据库</strong> 并纳入<strong>业务规则表</strong>。</p><p><img alt=Image loading=lazy src=https://github.com/user-attachments/assets/8614d402-1b43-4249-b549-d39f04558424></p><h2 id=06-领域建模实践-下>06 领域建模实践 下<a hidden class=anchor aria-hidden=true href=#06-领域建模实践-下>#</a></h2><p>通过引入 <strong>关联实体</strong> 将 <strong>多对多</strong> 关系拆成两个 <strong>一对多</strong>，并为实体补齐必要的 <strong>业务操作</strong>；当模型复杂时，可按 <strong>模块拆分</strong> 来提升可理解性。领域模型完成后，还要抓住两项落地 DDD 的关键实践：补齐 <strong>业务规则</strong>、建立 <strong>词汇表（统一语言）</strong>，它们是确保模型可执行、团队认知一致的重点。</p><p><img alt=Image loading=lazy src=https://github.com/user-attachments/assets/8f2c8f7f-115c-48e4-965a-2bf3cb044959></p><h2 id=07-领域建模原理>07 领域建模原理<a hidden class=anchor aria-hidden=true href=#07-领域建模原理>#</a></h2><p>DDD 的 <strong>领域模型</strong> 是对领域知识的 <strong>提炼抽象</strong>，同时兼顾 <strong>业务表达</strong> 与 <strong>技术落地</strong> ；在 <strong>模型驱动设计</strong> 下要做到 <strong>领域模型 ↔ 业务需求一致</strong>、<strong>系统实现 ↔ 领域模型一致</strong>，从而确保 <strong>实现 ↔ 需求一致</strong>；而 <strong>统一语言</strong> 以领域模型与词汇表为基础，通过 <strong>持续协作</strong> 不断维护 <strong>模型、语言与实现</strong> 三者的 <strong>一致性</strong>。</p><h2 id=08-数据库设计>08 数据库设计<a hidden class=anchor aria-hidden=true href=#08-数据库设计>#</a></h2><p>数据库三范式（3 Normal Form）。1NF 字段原子性：</p><ol><li>表中的每一列都必须是不可再分的原子值。</li><li>不允许在一个字段里存多个值、列表或重复组。</li></ol><blockquote><p>例：主键是(订单ID, 商品ID)，若订单日期只依赖订单ID，就不符合 2NF，应把订单信息拆到订单表。</p></blockquote><p>2NF 消除对主键的部分依赖：</p><ol><li>在满足 1NF 的基础上，要求非主属性必须完全依赖于整个主键。</li><li>主要针对联合主键的情况：不能只依赖主键的一部分。</li></ol><blockquote><p>例：主键是(订单ID, 商品ID)，若订单日期只依赖订单ID，就不符合 2NF，应把订单信息拆到订单表。</p></blockquote><p>3NF 消除传递依赖</p><ol><li>在满足 2NF 的基础上，要求非主属性不依赖于其他非主属性（即没有传递依赖）。</li><li>非主属性应当直接依赖主键。</li></ol><blockquote><p>例：员工ID -> 部门ID -> 部门名称，则部门名称是通过部门ID间接决定的，应拆出部门表存部门ID, 部门名称。</p></blockquote><p>DDD 强调用 <strong>领域模型驱动数据库设计</strong>，以保证 <strong>业务、代码、数据一致</strong>：<strong>实体→表</strong>、<strong>属性→字段</strong>（按需求补充），并通过 <strong>词汇表/统一语言</strong> 规范命名；关系设计上，<strong>一对多用外键</strong>（云上常见 <strong>“虚拟外键”</strong>），<strong>多对多用关联表</strong>；相较“拍脑袋”式建模，这种方式更容易 <strong>与业务对齐</strong>、更符合 <strong>范式</strong>，还能把 <strong>静态数据结构</strong> 与 <strong>动态业务逻辑</strong> 统一纳入同一套模型中。</p><h2 id=09-分层架构>09 分层架构<a hidden class=anchor aria-hidden=true href=#09-分层架构>#</a></h2><p>分层架构的原则是让<strong>不稳定的部分依赖稳定的部分</strong>：越靠内层越稳定、越靠外层越易变；其中<strong>领域层</strong>封装领域数据与规则，是系统核心，<strong>应用层</strong>作为门面把领域能力组织成粗粒度服务并处理事务、日志等横切关注点；外部交互由<strong>适配器层</strong>承担，主动适配器接收外部请求、被动适配器访问外部资源，二者只是在调用方向上不同，从而把技术细节隔离在外层，使应用层与领域层保持技术无关；数据访问上，<strong>仓库以聚合为单位</strong>（此处可暂按“一个实体一个仓库”理解），而 <strong>DAO 以表为单位</strong>；另设 <strong>common 层</strong>承载工具与框架，为各层提供支撑。</p><h2 id=10-代码实现-要贫血还是要充血>10 代码实现 要“贫血”还是要“充血”<a hidden class=anchor aria-hidden=true href=#10-代码实现-要贫血还是要充血>#</a></h2><p>贫血模型（<strong>Anemic Domain Model</strong>，Fowler 2003）指领域对象 <strong>只有数据没有行为</strong>，违背面向对象原则；相对的富/充血模型（<strong>Rich Domain Model</strong>）强调领域对象应同时包含<strong>数据 + 行为</strong>，更贴近真正的面向对象（可理解为贫血更偏 <strong>面向过程</strong>、富模型更偏 <strong>面向对象</strong>），但企业实践中两者并非非黑即白，应结合多种范式；落到编码，核心要求是 <strong>代码与模型一致</strong>（发现模型问题要 <strong>及时改模型</strong>），并解决 <strong>层间依赖</strong>：将 <strong>DTO 移到应用层</strong>、用 <strong>依赖倒置</strong> 让适配器层依赖领域层，同时理解 <strong>领域模型 vs 设计模型（UML）</strong> 的区别，以便明确哪些和业务讨论、哪些仅在工程内部讨论，从而提升抽象分层下的沟通与效率。</p><h2 id=11-代码实现-创建领域对象实现领域逻辑>11 代码实现 创建领域对象、实现领域逻辑<a hidden class=anchor aria-hidden=true href=#11-代码实现-创建领域对象实现领域逻辑>#</a></h2><p>实现领域逻辑时应使用能表达领域知识的命名，即 <strong>DDD 表意接口（Intention-Revealing Interfaces）</strong>；一旦违背，常见坏味道是 <strong>函数过长</strong> 与 <strong>注释过多</strong>，可用 <strong>抽取函数</strong> 重构解决。需区分 <strong>领域逻辑</strong> 与 <strong>应用逻辑</strong>，关键在于是否包含领域专家关心的 <strong>领域知识</strong>；领域逻辑应优先放入 <strong>领域对象</strong>，不适合放入对象的则放入 <strong>领域服务</strong>。复杂对象的创建推荐用 <strong>工厂（Factory）</strong>，参数少可直接调用工厂，参数多可配合 <strong>Builder</strong>。模块划分有按性质（<strong>横切</strong>）与按耦合/业务（<strong>纵切</strong>）两种，建议采用 <strong>先横后竖</strong> 的策略。</p><h2 id=12-代码实现-更加面向对象>12 代码实现 更加“面向对象”<a hidden class=anchor aria-hidden=true href=#12-代码实现-更加面向对象>#</a></h2><p>&ndash; EOF &ndash;</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://zyf.im/tags/ddd/>Ddd</a></li><li><a href=https://zyf.im/tags/design-pattern/>Design-Pattern</a></li></ul><nav class=paginav><a class=prev href=https://zyf.im/2023/04/19/mongodb-course/><span class=title>« Prev</span><br><span>MongoDB 高手课</span>
</a><a class=next href=https://zyf.im/2023/03/01/regular-expression-getting-started/><span class=title>Next »</span><br><span>正则表达式</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://zyf.im/>ZYF.IM BLOG</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>