<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Go 语言第一课 | ZYF.IM BLOG</title>
<meta name=keywords content="go"><meta name=description content='02 设计哲学
设计哲学之于编程语言，就好比一个人的价值观之于这个人的行为。

简单：Go 生产力的源泉。
显式：Go 希望开发人员 明确知道自己在做什么；显式的基于值比较的错误处理方案。
组合：类型嵌入(Type Embedding)。
并发：面向多核、原生支持并发、用户层轻量级线程 goroutine。
面向工程：将解决工程问题作为 Go 的 设计原则之一，这些问题包括:程序构建慢、依赖管理失控、代码难于理 解、跨语言构建难等。

03 配好环境

https://go.dev/doc/devel/release
https://golang.google.cn/dl/

安装多个 Go 版本
go get golang.org/dl/go1.15.13
go1.15.13 download
go1.15.13 version
配置 Go
go env
go help environment
04 Go 程序的结构

import "fmt" 一行中 fmt 代表的是包的导入路径(Import)，它表示的是标准库下的 fmt 目录，整个 import 声明语句的含义是导入标准库 fmt 目录下的包
fmt.Println 函数调用一行中的 fmt 代表的则是包名。
通常导入路径的最后一个分段名与包名是相同的，这也很容易让人误解 import 声明语句中的 fmt 指的是包名，其实并不是这样的。

gofmt main.go
Go module
go mod init
go mod tidy
05 Go 项目的布局标准
loccount 工具'><meta name=author content="Me"><link rel=canonical href=https://zyf.im/2023/02/01/go-language-lesson-one/><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://zyf.im/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zyf.im/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://zyf.im/favicon-32x32.png><link rel=apple-touch-icon href=https://zyf.im/apple-touch-icon.png><link rel=mask-icon href=https://zyf.im/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://zyf.im/2023/02/01/go-language-lesson-one/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:url" content="https://zyf.im/2023/02/01/go-language-lesson-one/"><meta property="og:site_name" content="ZYF.IM BLOG"><meta property="og:title" content="Go 语言第一课"><meta property="og:description" content='02 设计哲学 设计哲学之于编程语言，就好比一个人的价值观之于这个人的行为。
简单：Go 生产力的源泉。 显式：Go 希望开发人员 明确知道自己在做什么；显式的基于值比较的错误处理方案。 组合：类型嵌入(Type Embedding)。 并发：面向多核、原生支持并发、用户层轻量级线程 goroutine。 面向工程：将解决工程问题作为 Go 的 设计原则之一，这些问题包括:程序构建慢、依赖管理失控、代码难于理 解、跨语言构建难等。 03 配好环境 https://go.dev/doc/devel/release https://golang.google.cn/dl/ 安装多个 Go 版本 go get golang.org/dl/go1.15.13 go1.15.13 download go1.15.13 version 配置 Go go env go help environment 04 Go 程序的结构 import "fmt" 一行中 fmt 代表的是包的导入路径(Import)，它表示的是标准库下的 fmt 目录，整个 import 声明语句的含义是导入标准库 fmt 目录下的包 fmt.Println 函数调用一行中的 fmt 代表的则是包名。 通常导入路径的最后一个分段名与包名是相同的，这也很容易让人误解 import 声明语句中的 fmt 指的是包名，其实并不是这样的。 gofmt main.go Go module go mod init go mod tidy 05 Go 项目的布局标准 loccount 工具'><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-02-01T11:44:27+00:00"><meta property="article:modified_time" content="2023-02-01T11:44:27+00:00"><meta property="article:tag" content="Go"><meta name=twitter:card content="summary"><meta name=twitter:title content="Go 语言第一课"><meta name=twitter:description content='02 设计哲学
设计哲学之于编程语言，就好比一个人的价值观之于这个人的行为。

简单：Go 生产力的源泉。
显式：Go 希望开发人员 明确知道自己在做什么；显式的基于值比较的错误处理方案。
组合：类型嵌入(Type Embedding)。
并发：面向多核、原生支持并发、用户层轻量级线程 goroutine。
面向工程：将解决工程问题作为 Go 的 设计原则之一，这些问题包括:程序构建慢、依赖管理失控、代码难于理 解、跨语言构建难等。

03 配好环境

https://go.dev/doc/devel/release
https://golang.google.cn/dl/

安装多个 Go 版本
go get golang.org/dl/go1.15.13
go1.15.13 download
go1.15.13 version
配置 Go
go env
go help environment
04 Go 程序的结构

import "fmt" 一行中 fmt 代表的是包的导入路径(Import)，它表示的是标准库下的 fmt 目录，整个 import 声明语句的含义是导入标准库 fmt 目录下的包
fmt.Println 函数调用一行中的 fmt 代表的则是包名。
通常导入路径的最后一个分段名与包名是相同的，这也很容易让人误解 import 声明语句中的 fmt 指的是包名，其实并不是这样的。

gofmt main.go
Go module
go mod init
go mod tidy
05 Go 项目的布局标准
loccount 工具'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zyf.im/posts/"},{"@type":"ListItem","position":2,"name":"Go 语言第一课","item":"https://zyf.im/2023/02/01/go-language-lesson-one/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Go 语言第一课","name":"Go 语言第一课","description":"02 设计哲学 设计哲学之于编程语言，就好比一个人的价值观之于这个人的行为。\n简单：Go 生产力的源泉。 显式：Go 希望开发人员 明确知道自己在做什么；显式的基于值比较的错误处理方案。 组合：类型嵌入(Type Embedding)。 并发：面向多核、原生支持并发、用户层轻量级线程 goroutine。 面向工程：将解决工程问题作为 Go 的 设计原则之一，这些问题包括:程序构建慢、依赖管理失控、代码难于理 解、跨语言构建难等。 03 配好环境 https://go.dev/doc/devel/release https://golang.google.cn/dl/ 安装多个 Go 版本 go get golang.org/dl/go1.15.13 go1.15.13 download go1.15.13 version 配置 Go go env go help environment 04 Go 程序的结构 import \u0026quot;fmt\u0026quot; 一行中 fmt 代表的是包的导入路径(Import)，它表示的是标准库下的 fmt 目录，整个 import 声明语句的含义是导入标准库 fmt 目录下的包 fmt.Println 函数调用一行中的 fmt 代表的则是包名。 通常导入路径的最后一个分段名与包名是相同的，这也很容易让人误解 import 声明语句中的 fmt 指的是包名，其实并不是这样的。 gofmt main.go Go module go mod init go mod tidy 05 Go 项目的布局标准 loccount 工具\n","keywords":["go"],"articleBody":"02 设计哲学 设计哲学之于编程语言，就好比一个人的价值观之于这个人的行为。\n简单：Go 生产力的源泉。 显式：Go 希望开发人员 明确知道自己在做什么；显式的基于值比较的错误处理方案。 组合：类型嵌入(Type Embedding)。 并发：面向多核、原生支持并发、用户层轻量级线程 goroutine。 面向工程：将解决工程问题作为 Go 的 设计原则之一，这些问题包括:程序构建慢、依赖管理失控、代码难于理 解、跨语言构建难等。 03 配好环境 https://go.dev/doc/devel/release https://golang.google.cn/dl/ 安装多个 Go 版本 go get golang.org/dl/go1.15.13 go1.15.13 download go1.15.13 version 配置 Go go env go help environment 04 Go 程序的结构 import \"fmt\" 一行中 fmt 代表的是包的导入路径(Import)，它表示的是标准库下的 fmt 目录，整个 import 声明语句的含义是导入标准库 fmt 目录下的包 fmt.Println 函数调用一行中的 fmt 代表的则是包名。 通常导入路径的最后一个分段名与包名是相同的，这也很容易让人误解 import 声明语句中的 fmt 指的是包名，其实并不是这样的。 gofmt main.go Go module go mod init go mod tidy 05 Go 项目的布局标准 loccount 工具\nhttps://github.com/golang/go\ntree -LF 1 . 06 解决包依赖管理 GOPATH -\u003e Vendor -\u003e Go Module\nGOPATH go env GOPATH=\"/Users/v_yfanzhao/go\" go get github.com/sirupsen/logrus vendor Go 项目必须放在 GOPATH 环境变量配置的路径下，庞大的 vendor 目录需要提交到代码仓库，不仅占用代码仓库空间，减慢仓库下载和更新的速度， 而且还会干扰代码评审，对实施代码统计等开发者效能工具也有比较大影响。 你还需要手工管理 vendor 下面的 Go 依赖包，包括项目依赖包的分析、版本的记 录、依赖包获取和存放，等等，最让开发者头疼的就是这一点。 Go Module Go Module 与 go.mod 是一一对应的。go.mod 文件所在的顶层目录也被称为 module 的根目录，module 根目录以及它子目录 下的所有 Go 包均归属于这个 Go Module，这个 module 也被称为 main module。\npackage main import \"github.com/sirupsen/logrus\" func main() { logrus.Println(\"hello, go module mode\") } go mod init go mod tidy module go-lesson-one go 1.17 require github.com/sirupsen/logrus v1.9.0 require golang.org/x/sys v0.0.0-20220715151400-c0bba94af5f8 // indirect major.minor.patch\nGo 的语义导入版本机制：将包主版本号引入到包导入路径中。v0、v1 时不加入路径。\n因此甚至可以同时依赖一个包的两个不兼容版本：\nimport ( \"github.com/sirupsen/logrus\" logv2 \"github.com/sirupsen/logrus/v2\" ) Go 会在该项目依赖项的所有版本中，选出符合项目整体要求的“最小版本”。这与 PHP Composer 最新最大 (Latest Greatest) 版本 相反。\n07 Go Module 操作 go list -m all go list -m -versions github.com/sirupsen/logrus # 指定版本 升降级 go get github.com/sirupsen/logrus@v1.7.0 # 指定版本 升降级 go mod edit -require=github.com/sirupsen/logrus@v1.7.0 go mod tidy 使用 vendor 机制 go mod vendor go build -mod=verdor # 顶层目录下存在 vendor 目录，那么 go build 默认也会优先基于 vendor 构建，除非： go build -mod=mod 08 Go 程序的执行次序 可执行程序的 main 包必须定义 main 函数，否则 Go 编译器会报错。\n除了 main 包外，其他包也可以拥有自己的名为 main 的函数 或方法。\ninit 函数 除了前面讲过的 main.main 函数之外，Go 语言还有一个特殊函数，它就是用于进行包初始化的 init 函数了。main 函数之前，常量和变量初 始化之后。每个 init 函数在整个 Go 程序生命周期内仅会被执行一次。Go 包可以拥有不止一个 init 函数。\nGo 在进行包初始化的过程中，会采用“深度优先”的原则，递归初始化各个包的 依赖包。\npackage main |- import pkg1 |- import pkg2 |- const |- var |- init() |- const |- var |- init() |- const |- var |- init() |- main() init 函数的用途 重置包级变量值。被用于检查包级变量的初始状态。 实现对包级变量的复杂初始化。 在 init 函数中实现“注册模式”。通过在 init 函数中注册自己的实现的模式，就有效降低了 Go 包对外的直接 暴露，尤其是包级变量的暴露，从而避免了外部通过包级变量对包状态的改动。 09 构建一个 Web 服务 package main import ( \"net/http\" ) func main() { http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) { w.Write([]byte(\"Hello World\")) }) http.ListenAndServe(\":8888\", nil) } curl localhost:8888 Hello World https://github.com/imzyf/go-bookstore\n10 变量声明 var a int = 10 // 将变量名放在了类型的前面 // 修饰关键字 变量名 类型 初值 // 省略类型信息的声明 var b = 12 // 显式赋予变量初值 var b = int32(13) // 声明多个 var a, b, c = 12, 'A', \"hello\" // 短变量声明 a := 12 b := 'A' c := \"hello\" // 声明多个 a, b, c := 12, 'A', \"hello\" Go 语言的两类变量 包级变量 (package varible) 局部变量 (local varible) 包级变量的声明形式 包级变量只能使用带有 var 关键字的变量声明形式，不能使用短变量声明形式，但在形式细节上可以有一定灵活度。\nvar b int32 = 17 // 显式指定类型 var f float32 = 3.14 // 显式指定类型 var a = 13 // 使用默认类型 var b = int32(17) // 显式指定类型 var f = float32(3.14) // 显式指定类型 var a int32 var f float64 // 声明聚类 var ( netGo bool netCgo bool ) var ( aLongTimeAgo = time.Unix(1, 0) noDeadline = time.Time{} noCancel = (chan struct{})(nil) ) // 就近原则 // 尽可能在靠近第一次使用变量的位置声明这个变量 局部变量的声明形式 // 延迟初始化的局部变量 var err error // 显式初始化的局部变量 a := 17 f := float32(3.14) s := []byte(\"hello, gopher!\") // 尽量在分支控制时使用短变量声明形式 11 代码块 Block 与作用域 Scope // 变量遮蔽 var a = 11 func foo(n int) { a := 1 a += n } func main() { fmt.Println(\"a =\", a) // 11 foo(5) fmt.Println(\"after calling foo, a =\", a) // 11 } 宇宙代码块(Universe Block) 包代码块(Package Block) 文件代码块(File Block) 分支控制语句隐式代码块 switch/select 的子句隐式代码块 一个标识符的作用域就是指：这个标识符在被声明后可以被有效使用的源码区域。\n导出标识符：\n声明在包代码块中 它名字第一个字符是一个大写的 Unicode 字符 https://github.com/imzyf/go-lesson-one/blob/main/cmd/chapter11/main.go\n12 数值类型 整型 Go 采用补码(2’s complement)作为整型的比特位编码方法。Go 的补码是通过原码逐位取反后再加 1 得到的。\nunit8 1 0 0 0 0 0 0 1 = 129 int8 1 0 0 0 0 0 0 1 = -127 0 1 1 1 1 1 1 1 127 1 0 0 0 0 0 0 0 取反 1 0 0 0 0 0 0 1 +1 -127 整型的溢出问题 https://github.com/imzyf/go-lesson-one/blob/main/cmd/chapter12/main.go\n这个问题最容易发生在循环语句的结束条件判断中，因为这也是经常使用整型变量的地方。\n浮点型 IEEE 754 符号位Sign 阶码Exponent 尾数Maintissa \\bit 位\\ 符号位 阶码 阶码偏移值 尾数 单精度 float32 1 8 127 23 双精度 float64 1 11 1023 52 eg:129.8125\n步骤一:我们要把这个浮点数值的整数部分和小数部分，分别转换为二进制形式(后缀 d 表示十进制数，后缀 b 表示二进制数): 整数部分:139d =\u003e 10001011b; 小数部分:0.8125d =\u003e 0.1101b(十进制小数转换为二进制可采用“乘 2 取整”的竖式计算)。 0.8125 * 2 = 1.625 …… 1 0.625 * 2 = 1.25 …… 1 0.25 * 2 = 0.5 …… 0 0.5 * 2 = 1 …… 1 139.8125d -\u003e 10001011.1101b 步骤二:移动小数点，直到整数部分仅有一个 1。 10001011.1101b -\u003e 1.00010111101b 小数点向左移了 7 位，这样 指数就为 `7`，尾数为 `00010111101b`。 步骤三:计算阶码。对于 float32 的单精度浮点数而言： 阶码 = 指数 + 偏移值 偏移值的计算公式为 2^(e-1)-1，其中 e 为阶码部分的 bit 位数，这里为 8，于是单精度浮点数的阶码偏移 值就为 2^(8-1)-1 = 127。 阶码 = `7` + 127 = 134d = `10000110b`。 步骤四:将符号位、阶码和尾数填到各自位置，得到最终浮点数的二进制表示 符号位 0 阶码 10000110 尾数 00010111101 不足 23 位补零 `0_0010111101_00_0000000000` 139.8125 -\u003e 0_10000110_00010111101_000000000000\nGo Float32bit() result not expected | stackoverflow 复数型 矢量计算。\n创建自定义的数值类型 type MyInt int32 var m int = 5 var n int32 = 6 var a MyInt = m // error var a MyInt = n // error var a = MyInt(m) // ok var a = MyInt(n) // ok MyInt 类型的底层类型是 int32，所以它的数值性质与 int32 完全相同，但它 们仍然是完全不同的两种类型。\n类型别名(Type Alias) type MyInt = int32 var n int32 = 6 var a MyInt = n 通过类型别名语法定义的新类型与原类型别无二致，可以完全相互替代。\n13 字符串类型 why-what-how\n非原生字符串：\n不是原生类型，编译器不会对它进行类型校验，导致类型安全性差; 字符串操作时要时刻考虑结尾的 \\0，防止缓冲区溢出; 以字符数组形式定义的“字符串”，它的值是可变的，在并发场景中需要考虑同步问题; 获取一个字符串的长度代价较大，通常是 O(n) 时间复杂度; C 语言没有内置对非 ASCII 字符(如中文字符)的支持。 string 类型的数据是不可变的，提高了字符串的并发安全性和存储利用率（同一个字符串值分配同一块存储）。\nvar s string = \"hello\" s[0] = 'k' // cannot assign to s[0] (value of type byte) s = \"gopher\" // ok 没有结尾 \\0，而且获取长度的时间复杂度是常数时间，消除了获取字符串长度的开销。\n反引号原生支持“所见即所得”的原始字符串，大大降低构造多行字符串时的心智负担。\n对非 ASCII 字符提供原生支持，消除了源码在不同环境下显示乱码的可能。Unicode 字符是以 UTF-8 编码格式存储在内存。\n通过单引号括起的字符字面值：\nhttps://github.com/imzyf/go-lesson-one/blob/main/cmd/chapter13/main.go\nUTF-8 编码解决的是 Unicode 码点值在计算机中如何存储和表示(位模式)的问题。UTF-8 方案使用变长度字节，从 1 个到 4 个不等。\n一个 rune 存储一个 unicode 码点或 utf-32 的四字节编码；从字节视角，string 对应的底层存储存放的是 utf8 编码。\nGo 字符串类型的内部标示\n// StringHeader 是一个 string 的运行时表示 // string 类型其实是一个“描述符” type StringHeader struct { // 一个指向底层存储的指针 Data uintptr // 字符串的长度 Len int } 直接将 string 类型通过函数或方法参数传入也不会带来太多的开销。因为传入的仅仅是一个“描述符”，而不是真正的字符串数据。\nGo 字符串类型的常见操作 下标操作；下标操作，我们获取的是字符串中特定下标上的字节，而不是字符。\n字符迭代：\nor 迭代，字节视角的迭代 字符串中 Unicode 字符的码点值，以及该字符在字符串中的偏移值（字节视角） 字符串连接；+ += strings.Builder strings.Join fmt.Sprintf。\n字符串比较；= =、!= 、\u003e=、\u003c=、\u003e 和 \u003c。\n字符串转换；string -\u003e []rune []byte\n14 常量 支持无类型常量 支持隐式自动转型 可用于实现枚举 type myInt int // 无类型常量(Untyped Constant) const n = 13 func main() { var a myInt = 5 // 隐式转型 fmt.Println(a + n) } // 无类型常量 + 隐式转型：使得在 Go 这样的具有强类型系统的语言，在处理表达式混合数据类型运算的时候具有比较大的灵活性，代码编写也得到了一定程度的简化。 Go 的 const 语法提供了“隐式重复前一个非空表达式”的机制。\nconst ( Apple, Banana = iota, iota + 10 // 0, 10 (iota = 0) Strawberry, Grape // 1, 11 (iota = 1) Pear, Watermelon // 2, 12 (iota = 2) ) const ( _ = iota // 略过 iota = 0 IPV6_V6ONLY // 1 SOMAXCONN // 2 SO_ERROR // 3 ) 15 数组与切片 数组是一个固定长度的、由同构类型元素组成的连续序列。不仅是逻辑上的连续序列，而且在实际内存分配时也占据着一整块内存。\n切片不定长同构数据类型。切片可以看成是数组的“描述符”（句柄），为数组打开了一个访问与修改的“窗口”。\n// 切片 type slice struct { array unsafe.Pointer // 指向底层数组的指针 len int // 切片的长度，即切片中当前元素的个数 cap int // 底层数组的长度，也是切片的最大容量，cap 值永远大于等于 len 值 } var sl1 []int // 是声明，未初始化，是nil值，底层没有分配内存空间 var sl2 = []int{} // 初始化了，不是nil值，底层分配了内存空间，有地址。 16 map 类型 一组无序的键值对。\nmap[key_type]value_type key 的类型必须支持“==”和“!=”两种比较操作符。\nReferences The Go Playground – EOF —\n","wordCount":"1061","inLanguage":"en","datePublished":"2023-02-01T11:44:27Z","dateModified":"2023-02-01T11:44:27Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zyf.im/2023/02/01/go-language-lesson-one/"},"publisher":{"@type":"Organization","name":"ZYF.IM BLOG","logo":{"@type":"ImageObject","url":"https://zyf.im/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://zyf.im/ accesskey=h title="ZYF.IM (Alt + H)"><img src=https://zyf.im/apple-touch-icon.png alt aria-label=logo height=35>ZYF.IM</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://zyf.im/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://zyf.im/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://zyf.im/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://zyf.im/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://zyf.im/>Home</a>&nbsp;»&nbsp;<a href=https://zyf.im/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Go 语言第一课</h1><div class=post-meta><span title='2023-02-01 11:44:27 +0000 UTC'>February 1, 2023</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;1061 words&nbsp;·&nbsp;Me</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#02-设计哲学>02 设计哲学</a></li><li><a href=#03-配好环境>03 配好环境</a><ul><li><a href=#安装多个-go-版本>安装多个 Go 版本</a></li><li><a href=#配置-go>配置 Go</a></li></ul></li><li><a href=#04-go-程序的结构>04 Go 程序的结构</a><ul><li><a href=#go-module>Go module</a></li></ul></li><li><a href=#05-go-项目的布局标准>05 Go 项目的布局标准</a></li><li><a href=#06-解决包依赖管理>06 解决包依赖管理</a><ul><li><a href=#gopath>GOPATH</a></li><li><a href=#vendor>vendor</a></li><li><a href=#go-module-1>Go Module</a></li></ul></li><li><a href=#07-go-module-操作>07 Go Module 操作</a><ul><li><a href=#使用-vendor-机制>使用 vendor 机制</a></li></ul></li><li><a href=#08-go-程序的执行次序>08 Go 程序的执行次序</a><ul><li><a href=#init-函数>init 函数</a></li><li><a href=#init-函数的用途>init 函数的用途</a></li></ul></li><li><a href=#09-构建一个-web-服务>09 构建一个 Web 服务</a></li><li><a href=#10-变量声明>10 变量声明</a><ul><li><a href=#go-语言的两类变量>Go 语言的两类变量</a></li><li><a href=#包级变量的声明形式>包级变量的声明形式</a></li><li><a href=#局部变量的声明形式>局部变量的声明形式</a></li></ul></li><li><a href=#11-代码块-block-与作用域-scope>11 代码块 Block 与作用域 Scope</a></li><li><a href=#12-数值类型>12 数值类型</a><ul><li><a href=#整型>整型</a></li><li><a href=#整型的溢出问题>整型的溢出问题</a></li><li><a href=#浮点型>浮点型</a></li><li><a href=#复数型>复数型</a></li><li><a href=#创建自定义的数值类型>创建自定义的数值类型</a></li><li><a href=#类型别名type-alias>类型别名(Type Alias)</a></li></ul></li><li><a href=#13-字符串类型>13 字符串类型</a><ul><li><a href=#go-字符串类型的常见操作>Go 字符串类型的常见操作</a></li></ul></li><li><a href=#14-常量>14 常量</a></li><li><a href=#15-数组与切片>15 数组与切片</a></li><li><a href=#16-map-类型>16 map 类型</a></li><li><a href=#references>References</a></li></ul></nav></div></details></div><div class=post-content><h2 id=02-设计哲学>02 设计哲学<a hidden class=anchor aria-hidden=true href=#02-设计哲学>#</a></h2><p>设计哲学之于编程语言，就好比一个人的价值观之于这个人的行为。</p><ul><li>简单：Go 生产力的源泉。</li><li>显式：Go 希望开发人员 明确知道自己在做什么；显式的基于值比较的错误处理方案。</li><li>组合：类型嵌入(Type Embedding)。</li><li>并发：面向多核、原生支持并发、用户层轻量级线程 goroutine。</li><li>面向工程：将解决工程问题作为 Go 的 设计原则之一，这些问题包括:程序构建慢、依赖管理失控、代码难于理 解、跨语言构建难等。</li></ul><h2 id=03-配好环境>03 配好环境<a hidden class=anchor aria-hidden=true href=#03-配好环境>#</a></h2><ul><li><a href=https://go.dev/doc/devel/release>https://go.dev/doc/devel/release</a></li><li><a href=https://golang.google.cn/dl/>https://golang.google.cn/dl/</a></li></ul><h3 id=安装多个-go-版本>安装多个 Go 版本<a hidden class=anchor aria-hidden=true href=#安装多个-go-版本>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>go get golang.org/dl/go1.15.13
</span></span><span class=line><span class=cl>go1.15.13 download
</span></span><span class=line><span class=cl>go1.15.13 version
</span></span></code></pre></div><h3 id=配置-go>配置 Go<a hidden class=anchor aria-hidden=true href=#配置-go>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>go env
</span></span><span class=line><span class=cl>go <span class=nb>help</span> environment
</span></span></code></pre></div><h2 id=04-go-程序的结构>04 Go 程序的结构<a hidden class=anchor aria-hidden=true href=#04-go-程序的结构>#</a></h2><ul><li><code>import "fmt"</code> 一行中 <code>fmt</code> 代表的是包的导入路径(Import)，它表示的是标准库下的 fmt 目录，整个 import 声明语句的含义是导入标准库 fmt 目录下的包</li><li><code>fmt.Println</code> 函数调用一行中的 <code>fmt</code> 代表的则是包名。</li><li>通常导入路径的最后一个分段名与包名是相同的，这也很容易让人误解 import 声明语句中的 <code>fmt</code> 指的是包名，其实并不是这样的。</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-php data-lang=php><span class=line><span class=cl><span class=nx>gofmt</span> <span class=nx>main</span><span class=o>.</span><span class=nx>go</span>
</span></span></code></pre></div><h3 id=go-module>Go module<a hidden class=anchor aria-hidden=true href=#go-module>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>go mod init
</span></span><span class=line><span class=cl>go mod tidy
</span></span></code></pre></div><h2 id=05-go-项目的布局标准>05 Go 项目的布局标准<a hidden class=anchor aria-hidden=true href=#05-go-项目的布局标准>#</a></h2><p>loccount 工具</p><p><a href=https://github.com/golang/go>https://github.com/golang/go</a></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>tree -LF <span class=m>1</span> .
</span></span></code></pre></div><h2 id=06-解决包依赖管理>06 解决包依赖管理<a hidden class=anchor aria-hidden=true href=#06-解决包依赖管理>#</a></h2><p>GOPATH -> Vendor -> Go Module</p><h3 id=gopath>GOPATH<a hidden class=anchor aria-hidden=true href=#gopath>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>go env
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>GOPATH</span><span class=o>=</span><span class=s2>&#34;/Users/v_yfanzhao/go&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>go get github.com/sirupsen/logrus
</span></span></code></pre></div><h3 id=vendor>vendor<a hidden class=anchor aria-hidden=true href=#vendor>#</a></h3><ul><li>Go 项目必须放在 GOPATH 环境变量配置的路径下，庞大的 vendor 目录需要提交到代码仓库，不仅占用代码仓库空间，减慢仓库下载和更新的速度， 而且还会干扰代码评审，对实施代码统计等开发者效能工具也有比较大影响。</li><li>你还需要手工管理 vendor 下面的 Go 依赖包，包括项目依赖包的分析、版本的记 录、依赖包获取和存放，等等，最让开发者头疼的就是这一点。</li></ul><h3 id=go-module-1>Go Module<a hidden class=anchor aria-hidden=true href=#go-module-1>#</a></h3><p>Go Module 与 go.mod 是一一对应的。go.mod 文件所在的顶层目录也被称为 module 的根目录，module 根目录以及它子目录 下的所有 Go 包均归属于这个 Go Module，这个 module 也被称为 main module。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;github.com/sirupsen/logrus&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=nx>logrus</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;hello, go module mode&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>go mod init
</span></span><span class=line><span class=cl>go mod tidy
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>module</span> <span class=k>go</span><span class=o>-</span><span class=nx>lesson</span><span class=o>-</span><span class=nx>one</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>go</span> <span class=mf>1.17</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>require</span> <span class=nx>github</span><span class=p>.</span><span class=nx>com</span><span class=o>/</span><span class=nx>sirupsen</span><span class=o>/</span><span class=nx>logrus</span> <span class=nx>v1</span><span class=mf>.9.0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>require</span> <span class=nx>golang</span><span class=p>.</span><span class=nx>org</span><span class=o>/</span><span class=nx>x</span><span class=o>/</span><span class=nx>sys</span> <span class=nx>v0</span><span class=mf>.0.0</span><span class=o>-</span><span class=mi>20220715151400</span><span class=o>-</span><span class=nx>c0bba94af5f8</span> <span class=c1>// indirect</span>
</span></span></code></pre></div><p>major.minor.patch</p><p>Go 的语义导入版本机制：将包主版本号引入到包导入路径中。v0、v1 时不加入路径。</p><p>因此甚至可以同时依赖一个包的两个不兼容版本：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>  <span class=s>&#34;github.com/sirupsen/logrus&#34;</span>
</span></span><span class=line><span class=cl>  <span class=nx>logv2</span> <span class=s>&#34;github.com/sirupsen/logrus/v2&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span></code></pre></div><p>Go 会在该项目依赖项的所有版本中，选出符合项目整体要求的“最小版本”。这与 PHP Composer 最新最大 (Latest Greatest) 版本 相反。</p><h2 id=07-go-module-操作>07 Go Module 操作<a hidden class=anchor aria-hidden=true href=#07-go-module-操作>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>go list -m all
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>go list -m -versions github.com/sirupsen/logrus
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 指定版本 升降级</span>
</span></span><span class=line><span class=cl>go get github.com/sirupsen/logrus@v1.7.0
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 指定版本 升降级</span>
</span></span><span class=line><span class=cl>go mod edit -require<span class=o>=</span>github.com/sirupsen/logrus@v1.7.0
</span></span><span class=line><span class=cl>go mod tidy
</span></span></code></pre></div><h3 id=使用-vendor-机制>使用 vendor 机制<a hidden class=anchor aria-hidden=true href=#使用-vendor-机制>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>go mod vendor
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>go build -mod<span class=o>=</span>verdor
</span></span><span class=line><span class=cl><span class=c1># 顶层目录下存在 vendor 目录，那么 go build 默认也会优先基于 vendor 构建，除非：</span>
</span></span><span class=line><span class=cl>go build -mod<span class=o>=</span>mod
</span></span></code></pre></div><h2 id=08-go-程序的执行次序>08 Go 程序的执行次序<a hidden class=anchor aria-hidden=true href=#08-go-程序的执行次序>#</a></h2><p>可执行程序的 main 包必须定义 main 函数，否则 Go 编译器会报错。</p><p>除了 main 包外，其他包也可以拥有自己的名为 main 的函数 或方法。</p><h3 id=init-函数>init 函数<a hidden class=anchor aria-hidden=true href=#init-函数>#</a></h3><p>除了前面讲过的 main.main 函数之外，Go 语言还有一个特殊函数，它就是用于进行包初始化的 init 函数了。main 函数之前，常量和变量初 始化之后。每个 init 函数在整个 Go 程序生命周期内仅会被执行一次。Go 包可以拥有不止一个 init 函数。</p><p>Go 在进行包初始化的过程中，会采用“深度优先”的原则，递归初始化各个包的 依赖包。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>package main
</span></span><span class=line><span class=cl><span class=p>|</span>- import pkg1
</span></span><span class=line><span class=cl>    <span class=p>|</span>- import pkg2
</span></span><span class=line><span class=cl>        <span class=p>|</span>- const
</span></span><span class=line><span class=cl>        <span class=p>|</span>- var
</span></span><span class=line><span class=cl>        <span class=p>|</span>- init<span class=o>()</span>
</span></span><span class=line><span class=cl>    <span class=p>|</span>- const
</span></span><span class=line><span class=cl>    <span class=p>|</span>- var
</span></span><span class=line><span class=cl>    <span class=p>|</span>- init<span class=o>()</span>
</span></span><span class=line><span class=cl><span class=p>|</span>- const
</span></span><span class=line><span class=cl><span class=p>|</span>- var
</span></span><span class=line><span class=cl><span class=p>|</span>- init<span class=o>()</span>
</span></span><span class=line><span class=cl><span class=p>|</span>- main<span class=o>()</span>
</span></span></code></pre></div><h3 id=init-函数的用途>init 函数的用途<a hidden class=anchor aria-hidden=true href=#init-函数的用途>#</a></h3><ul><li>重置包级变量值。被用于检查包级变量的初始状态。</li><li>实现对包级变量的复杂初始化。</li><li>在 init 函数中实现“注册模式”。通过在 init 函数中注册自己的实现的模式，就有效降低了 Go 包对外的直接 暴露，尤其是包级变量的暴露，从而避免了外部通过包级变量对包状态的改动。</li></ul><h2 id=09-构建一个-web-服务>09 构建一个 Web 服务<a hidden class=anchor aria-hidden=true href=#09-构建一个-web-服务>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl> <span class=s>&#34;net/http&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=nx>http</span><span class=p>.</span><span class=nf>HandleFunc</span><span class=p>(</span><span class=s>&#34;/&#34;</span><span class=p>,</span> <span class=kd>func</span><span class=p>(</span><span class=nx>w</span> <span class=nx>http</span><span class=p>.</span><span class=nx>ResponseWriter</span><span class=p>,</span> <span class=nx>r</span> <span class=o>*</span><span class=nx>http</span><span class=p>.</span><span class=nx>Request</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>w</span><span class=p>.</span><span class=nf>Write</span><span class=p>([]</span><span class=nb>byte</span><span class=p>(</span><span class=s>&#34;Hello World&#34;</span><span class=p>))</span>
</span></span><span class=line><span class=cl> <span class=p>})</span>
</span></span><span class=line><span class=cl> <span class=nx>http</span><span class=p>.</span><span class=nf>ListenAndServe</span><span class=p>(</span><span class=s>&#34;:8888&#34;</span><span class=p>,</span> <span class=kc>nil</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>curl localhost:8888
</span></span><span class=line><span class=cl>Hello World
</span></span></code></pre></div><blockquote><p><a href=https://github.com/imzyf/go-bookstore>https://github.com/imzyf/go-bookstore</a></p></blockquote><h2 id=10-变量声明>10 变量声明<a hidden class=anchor aria-hidden=true href=#10-变量声明>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>a</span> <span class=kt>int</span> <span class=p>=</span> <span class=mi>10</span>
</span></span><span class=line><span class=cl><span class=c1>// 将变量名放在了类型的前面</span>
</span></span><span class=line><span class=cl><span class=c1>// 修饰关键字 变量名 类型 初值</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 省略类型信息的声明</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>b</span> <span class=p>=</span> <span class=mi>12</span>
</span></span><span class=line><span class=cl><span class=c1>// 显式赋予变量初值</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>b</span> <span class=p>=</span> <span class=nb>int32</span><span class=p>(</span><span class=mi>13</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>// 声明多个</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>a</span><span class=p>,</span> <span class=nx>b</span><span class=p>,</span> <span class=nx>c</span> <span class=p>=</span> <span class=mi>12</span><span class=p>,</span> <span class=sc>&#39;A&#39;</span><span class=p>,</span> <span class=s>&#34;hello&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 短变量声明</span>
</span></span><span class=line><span class=cl><span class=nx>a</span> <span class=o>:=</span> <span class=mi>12</span>
</span></span><span class=line><span class=cl><span class=nx>b</span> <span class=o>:=</span> <span class=sc>&#39;A&#39;</span>
</span></span><span class=line><span class=cl><span class=nx>c</span> <span class=o>:=</span> <span class=s>&#34;hello&#34;</span>
</span></span><span class=line><span class=cl><span class=c1>// 声明多个</span>
</span></span><span class=line><span class=cl><span class=nx>a</span><span class=p>,</span> <span class=nx>b</span><span class=p>,</span> <span class=nx>c</span> <span class=o>:=</span> <span class=mi>12</span><span class=p>,</span> <span class=sc>&#39;A&#39;</span><span class=p>,</span> <span class=s>&#34;hello&#34;</span>
</span></span></code></pre></div><h3 id=go-语言的两类变量>Go 语言的两类变量<a hidden class=anchor aria-hidden=true href=#go-语言的两类变量>#</a></h3><ul><li>包级变量 (package varible)</li><li>局部变量 (local varible)</li></ul><h3 id=包级变量的声明形式>包级变量的声明形式<a hidden class=anchor aria-hidden=true href=#包级变量的声明形式>#</a></h3><p>包级变量只能使用带有 var 关键字的变量声明形式，不能使用短变量声明形式，但在形式细节上可以有一定灵活度。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>b</span> <span class=kt>int32</span> <span class=p>=</span> <span class=mi>17</span> <span class=c1>// 显式指定类型</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>f</span> <span class=kt>float32</span> <span class=p>=</span> <span class=mf>3.14</span> <span class=c1>// 显式指定类型</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>a</span> <span class=p>=</span> <span class=mi>13</span> <span class=c1>// 使用默认类型</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>b</span> <span class=p>=</span> <span class=nb>int32</span><span class=p>(</span><span class=mi>17</span><span class=p>)</span> <span class=c1>// 显式指定类型</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>f</span> <span class=p>=</span> <span class=nb>float32</span><span class=p>(</span><span class=mf>3.14</span><span class=p>)</span> <span class=c1>// 显式指定类型</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>a</span> <span class=kt>int32</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>f</span> <span class=kt>float64</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// 声明聚类</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=nx>netGo</span> <span class=kt>bool</span>
</span></span><span class=line><span class=cl>    <span class=nx>netCgo</span> <span class=kt>bool</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=nx>aLongTimeAgo</span> <span class=p>=</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Unix</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>noDeadline</span> <span class=p>=</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Time</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=nx>noCancel</span> <span class=p>=</span> <span class=p>(</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>{})(</span><span class=kc>nil</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 就近原则</span>
</span></span><span class=line><span class=cl><span class=c1>// 尽可能在靠近第一次使用变量的位置声明这个变量</span>
</span></span></code></pre></div><h3 id=局部变量的声明形式>局部变量的声明形式<a hidden class=anchor aria-hidden=true href=#局部变量的声明形式>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// 延迟初始化的局部变量</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>err</span> <span class=kt>error</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 显式初始化的局部变量</span>
</span></span><span class=line><span class=cl><span class=nx>a</span> <span class=o>:=</span> <span class=mi>17</span>
</span></span><span class=line><span class=cl><span class=nx>f</span> <span class=o>:=</span> <span class=nb>float32</span><span class=p>(</span><span class=mf>3.14</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>s</span> <span class=o>:=</span> <span class=p>[]</span><span class=nb>byte</span><span class=p>(</span><span class=s>&#34;hello, gopher!&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>// 尽量在分支控制时使用短变量声明形式</span>
</span></span></code></pre></div><h2 id=11-代码块-block-与作用域-scope>11 代码块 Block 与作用域 Scope<a hidden class=anchor aria-hidden=true href=#11-代码块-block-与作用域-scope>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// 变量遮蔽</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>a</span> <span class=p>=</span> <span class=mi>11</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>foo</span><span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>a</span> <span class=o>:=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=nx>a</span> <span class=o>+=</span> <span class=nx>n</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;a =&#34;</span><span class=p>,</span> <span class=nx>a</span><span class=p>)</span> <span class=c1>// 11</span>
</span></span><span class=line><span class=cl>    <span class=nf>foo</span><span class=p>(</span><span class=mi>5</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;after calling foo, a =&#34;</span><span class=p>,</span> <span class=nx>a</span><span class=p>)</span> <span class=c1>// 11</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li>宇宙代码块(Universe Block)</li><li>包代码块(Package Block)</li><li>文件代码块(File Block)</li><li>分支控制语句隐式代码块</li><li>switch/select 的子句隐式代码块</li></ul><p>一个标识符的作用域就是指：这个标识符在被声明后可以被有效使用的源码区域。</p><p>导出标识符：</p><ul><li>声明在包代码块中</li><li>它名字第一个字符是一个大写的 Unicode 字符</li></ul><blockquote><p><a href=https://github.com/imzyf/go-lesson-one/blob/main/cmd/chapter11/main.go>https://github.com/imzyf/go-lesson-one/blob/main/cmd/chapter11/main.go</a></p></blockquote><h2 id=12-数值类型>12 数值类型<a hidden class=anchor aria-hidden=true href=#12-数值类型>#</a></h2><h3 id=整型>整型<a hidden class=anchor aria-hidden=true href=#整型>#</a></h3><p>Go 采用补码(2&rsquo;s complement)作为整型的比特位编码方法。Go 的补码是通过原码逐位取反后再加 1 得到的。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>unit8  <span class=m>1</span> <span class=m>0</span> <span class=m>0</span> <span class=m>0</span> <span class=m>0</span> <span class=m>0</span> <span class=m>0</span> <span class=nv>1</span> <span class=o>=</span> <span class=m>129</span>
</span></span><span class=line><span class=cl>int8   <span class=m>1</span> <span class=m>0</span> <span class=m>0</span> <span class=m>0</span> <span class=m>0</span> <span class=m>0</span> <span class=m>0</span> <span class=nv>1</span> <span class=o>=</span> -127
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=m>0</span> <span class=m>1</span> <span class=m>1</span> <span class=m>1</span> <span class=m>1</span> <span class=m>1</span> <span class=m>1</span> <span class=m>1</span>     <span class=m>127</span>
</span></span><span class=line><span class=cl><span class=m>1</span> <span class=m>0</span> <span class=m>0</span> <span class=m>0</span> <span class=m>0</span> <span class=m>0</span> <span class=m>0</span> <span class=m>0</span>     取反
</span></span><span class=line><span class=cl><span class=m>1</span> <span class=m>0</span> <span class=m>0</span> <span class=m>0</span> <span class=m>0</span> <span class=m>0</span> <span class=m>0</span> <span class=m>1</span>     +1    -127
</span></span></code></pre></div><h3 id=整型的溢出问题>整型的溢出问题<a hidden class=anchor aria-hidden=true href=#整型的溢出问题>#</a></h3><blockquote><p><a href=https://github.com/imzyf/go-lesson-one/blob/main/cmd/chapter12/main.go>https://github.com/imzyf/go-lesson-one/blob/main/cmd/chapter12/main.go</a></p></blockquote><p>这个问题最容易发生在循环语句的结束条件判断中，因为这也是经常使用整型变量的地方。</p><h3 id=浮点型>浮点型<a hidden class=anchor aria-hidden=true href=#浮点型>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>IEEE <span class=m>754</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>符号位Sign  阶码Exponent  尾数Maintissa
</span></span></code></pre></div><table><thead><tr><th>\bit 位\</th><th>符号位</th><th>阶码</th><th>阶码偏移值</th><th>尾数</th></tr></thead><tbody><tr><td>单精度 float32</td><td>1</td><td>8</td><td>127</td><td>23</td></tr><tr><td>双精度 float64</td><td>1</td><td>11</td><td>1023</td><td>52</td></tr></tbody></table><p>eg:129.8125</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>步骤一:我们要把这个浮点数值的整数部分和小数部分，分别转换为二进制形式<span class=o>(</span>后缀 d 表示十进制数，后缀 b 表示二进制数<span class=o>)</span>:
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>整数部分:139d <span class=o>=</span>&gt; 10001011b<span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>小数部分:0.8125d <span class=o>=</span>&gt; 0.1101b<span class=o>(</span>十进制小数转换为二进制可采用“乘 <span class=m>2</span> 取整”的竖式计算<span class=o>)</span>。
</span></span><span class=line><span class=cl>0.8125 * <span class=nv>2</span> <span class=o>=</span> 1.625 …… <span class=m>1</span>
</span></span><span class=line><span class=cl>0.625 * <span class=nv>2</span> <span class=o>=</span> 1.25   …… <span class=m>1</span>
</span></span><span class=line><span class=cl>0.25 * <span class=nv>2</span> <span class=o>=</span> 0.5     …… <span class=m>0</span>
</span></span><span class=line><span class=cl>0.5 * <span class=nv>2</span> <span class=o>=</span> <span class=m>1</span>        …… <span class=m>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>139.8125d -&gt; 10001011.1101b
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>步骤二:移动小数点，直到整数部分仅有一个 1。
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>10001011.1101b -&gt; 1.00010111101b
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>小数点向左移了 <span class=m>7</span> 位，这样 指数就为 <span class=sb>`</span>7<span class=sb>`</span>，尾数为 <span class=sb>`</span>00010111101b<span class=sb>`</span>。
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>步骤三:计算阶码。对于 float32 的单精度浮点数而言：
</span></span><span class=line><span class=cl><span class=nv>阶码</span> <span class=o>=</span> 指数 + 偏移值
</span></span><span class=line><span class=cl>偏移值的计算公式为 2^<span class=o>(</span>e-1<span class=o>)</span>-1，其中 e 为阶码部分的 bit 位数，这里为 8，于是单精度浮点数的阶码偏移 值就为 2^<span class=o>(</span>8-1<span class=o>)</span>-1 <span class=o>=</span> 127。
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>阶码</span> <span class=o>=</span> <span class=sb>`</span>7<span class=sb>`</span> + <span class=nv>127</span> <span class=o>=</span> <span class=nv>134d</span> <span class=o>=</span> <span class=sb>`</span>10000110b<span class=sb>`</span>。
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>步骤四:将符号位、阶码和尾数填到各自位置，得到最终浮点数的二进制表示
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>符号位 <span class=m>0</span>
</span></span><span class=line><span class=cl>阶码 <span class=m>10000110</span>
</span></span><span class=line><span class=cl>尾数 <span class=m>00010111101</span> 不足 <span class=m>23</span> 位补零 <span class=sb>`</span>0_0010111101_00_0000000000<span class=sb>`</span>
</span></span></code></pre></div><p><code>139.8125</code> -> <code>0_10000110_00010111101_000000000000</code></p><ul><li><a href=https://stackoverflow.com/questions/75357159/go-float32bit-result-not-expected>Go Float32bit() result not expected | stackoverflow</a></li></ul><h3 id=复数型>复数型<a hidden class=anchor aria-hidden=true href=#复数型>#</a></h3><p>矢量计算。</p><h3 id=创建自定义的数值类型>创建自定义的数值类型<a hidden class=anchor aria-hidden=true href=#创建自定义的数值类型>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>MyInt</span> <span class=kt>int32</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>m</span> <span class=kt>int</span> <span class=p>=</span> <span class=mi>5</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>n</span> <span class=kt>int32</span> <span class=p>=</span> <span class=mi>6</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>a</span> <span class=nx>MyInt</span> <span class=p>=</span> <span class=nx>m</span> <span class=c1>// error</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>a</span> <span class=nx>MyInt</span> <span class=p>=</span> <span class=nx>n</span> <span class=c1>// error</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>a</span> <span class=p>=</span> <span class=nf>MyInt</span><span class=p>(</span><span class=nx>m</span><span class=p>)</span> <span class=c1>// ok</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>a</span> <span class=p>=</span> <span class=nf>MyInt</span><span class=p>(</span><span class=nx>n</span><span class=p>)</span> <span class=c1>// ok</span>
</span></span></code></pre></div><p>MyInt 类型的底层类型是 int32，所以它的数值性质与 int32 完全相同，但它 们仍然是完全不同的两种类型。</p><h3 id=类型别名type-alias>类型别名(Type Alias)<a hidden class=anchor aria-hidden=true href=#类型别名type-alias>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>MyInt</span> <span class=p>=</span> <span class=kt>int32</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>n</span> <span class=kt>int32</span> <span class=p>=</span> <span class=mi>6</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>a</span> <span class=nx>MyInt</span> <span class=p>=</span> <span class=nx>n</span>
</span></span></code></pre></div><p>通过类型别名语法定义的新类型与原类型别无二致，可以完全相互替代。</p><h2 id=13-字符串类型>13 字符串类型<a hidden class=anchor aria-hidden=true href=#13-字符串类型>#</a></h2><p>why-what-how</p><p>非原生字符串：</p><ul><li>不是原生类型，编译器不会对它进行类型校验，导致类型安全性差;</li><li>字符串操作时要时刻考虑结尾的 <code>\0</code>，防止缓冲区溢出;</li><li>以字符数组形式定义的“字符串”，它的值是可变的，在并发场景中需要考虑同步问题;</li><li>获取一个字符串的长度代价较大，通常是 O(n) 时间复杂度;</li><li>C 语言没有内置对非 ASCII 字符(如中文字符)的支持。</li></ul><p>string 类型的数据是不可变的，提高了字符串的并发安全性和存储利用率（同一个字符串值分配同一块存储）。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>s</span> <span class=kt>string</span> <span class=p>=</span> <span class=s>&#34;hello&#34;</span>
</span></span><span class=line><span class=cl><span class=nx>s</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=p>=</span> <span class=sc>&#39;k&#39;</span> <span class=c1>// cannot assign to s[0] (value of type byte)</span>
</span></span><span class=line><span class=cl><span class=nx>s</span> <span class=p>=</span> <span class=s>&#34;gopher&#34;</span> <span class=c1>// ok</span>
</span></span></code></pre></div><p>没有结尾 <code>\0</code>，而且获取长度的时间复杂度是常数时间，消除了获取字符串长度的开销。</p><p>反引号原生支持“所见即所得”的原始字符串，大大降低构造多行字符串时的心智负担。</p><p>对非 ASCII 字符提供原生支持，消除了源码在不同环境下显示乱码的可能。Unicode 字符是以 UTF-8 编码格式存储在内存。</p><p>通过单引号括起的字符字面值：</p><p><a href=https://github.com/imzyf/go-lesson-one/blob/main/cmd/chapter13/main.go>https://github.com/imzyf/go-lesson-one/blob/main/cmd/chapter13/main.go</a></p><p>UTF-8 编码解决的是 Unicode 码点值在计算机中如何存储和表示(位模式)的问题。UTF-8 方案使用变长度字节，从 1 个到 4 个不等。</p><p>一个 rune 存储一个 unicode 码点或 utf-32 的四字节编码；从字节视角，string 对应的底层存储存放的是 utf8 编码。</p><p>Go 字符串类型的内部标示</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// StringHeader 是一个 string 的运行时表示</span>
</span></span><span class=line><span class=cl><span class=c1>// string 类型其实是一个“描述符”</span>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>StringHeader</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 一个指向底层存储的指针</span>
</span></span><span class=line><span class=cl>  <span class=nx>Data</span> <span class=kt>uintptr</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 字符串的长度</span>
</span></span><span class=line><span class=cl>  <span class=nx>Len</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>直接将 string 类型通过函数或方法参数传入也不会带来太多的开销。因为传入的仅仅是一个“描述符”，而不是真正的字符串数据。</p><h3 id=go-字符串类型的常见操作>Go 字符串类型的常见操作<a hidden class=anchor aria-hidden=true href=#go-字符串类型的常见操作>#</a></h3><p>下标操作；下标操作，我们获取的是字符串中特定下标上的字节，而不是字符。</p><p>字符迭代：</p><ul><li>or 迭代，字节视角的迭代</li><li>字符串中 Unicode 字符的码点值，以及该字符在字符串中的偏移值（字节视角）</li></ul><p>字符串连接；<code>+</code> <code>+=</code> <code>strings.Builder</code> <code>strings.Join</code> <code>fmt.Sprintf</code>。</p><p>字符串比较；= =、!= 、>=、&lt;=、> 和 &lt;。</p><p>字符串转换；string -> <code>[]rune</code> <code>[]byte</code></p><h2 id=14-常量>14 常量<a hidden class=anchor aria-hidden=true href=#14-常量>#</a></h2><ul><li>支持无类型常量</li><li>支持隐式自动转型</li><li>可用于实现枚举</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>myInt</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=c1>// 无类型常量(Untyped Constant)</span>
</span></span><span class=line><span class=cl><span class=kd>const</span> <span class=nx>n</span> <span class=p>=</span> <span class=mi>13</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kd>var</span> <span class=nx>a</span> <span class=nx>myInt</span> <span class=p>=</span> <span class=mi>5</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 隐式转型</span>
</span></span><span class=line><span class=cl>  <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>a</span> <span class=o>+</span> <span class=nx>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 无类型常量 + 隐式转型：使得在 Go 这样的具有强类型系统的语言，在处理表达式混合数据类型运算的时候具有比较大的灵活性，代码编写也得到了一定程度的简化。</span>
</span></span></code></pre></div><p>Go 的 const 语法提供了“隐式重复前一个非空表达式”的机制。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>const</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>  <span class=nx>Apple</span><span class=p>,</span> <span class=nx>Banana</span> <span class=p>=</span> <span class=kc>iota</span><span class=p>,</span> <span class=kc>iota</span> <span class=o>+</span> <span class=mi>10</span> <span class=c1>// 0, 10 (iota = 0)</span>
</span></span><span class=line><span class=cl>  <span class=nx>Strawberry</span><span class=p>,</span> <span class=nx>Grape</span> <span class=c1>// 1, 11 (iota = 1)</span>
</span></span><span class=line><span class=cl>  <span class=nx>Pear</span><span class=p>,</span> <span class=nx>Watermelon</span> <span class=c1>// 2, 12 (iota = 2)</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=kd>const</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>  <span class=nx>_</span> <span class=p>=</span> <span class=kc>iota</span> <span class=c1>// 略过 iota = 0</span>
</span></span><span class=line><span class=cl>  <span class=nx>IPV6_V6ONLY</span> <span class=c1>// 1</span>
</span></span><span class=line><span class=cl>  <span class=nx>SOMAXCONN</span> <span class=c1>// 2</span>
</span></span><span class=line><span class=cl>  <span class=nx>SO_ERROR</span> <span class=c1>// 3</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span></code></pre></div><h2 id=15-数组与切片>15 数组与切片<a hidden class=anchor aria-hidden=true href=#15-数组与切片>#</a></h2><p>数组是一个固定长度的、由同构类型元素组成的连续序列。不仅是逻辑上的连续序列，而且在实际内存分配时也占据着一整块内存。</p><p>切片不定长同构数据类型。切片可以看成是数组的“描述符”（句柄），为数组打开了一个访问与修改的“窗口”。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// 切片</span>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>slice</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>array</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span> <span class=c1>// 指向底层数组的指针</span>
</span></span><span class=line><span class=cl>  <span class=nx>len</span> <span class=kt>int</span> <span class=c1>// 切片的长度，即切片中当前元素的个数</span>
</span></span><span class=line><span class=cl>  <span class=nx>cap</span> <span class=kt>int</span> <span class=c1>// 底层数组的长度，也是切片的最大容量，cap 值永远大于等于 len 值</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>sl1</span> <span class=p>[]</span><span class=kt>int</span> <span class=c1>// 是声明，未初始化，是nil值，底层没有分配内存空间</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>sl2</span> <span class=p>=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{}</span> <span class=c1>// 初始化了，不是nil值，底层分配了内存空间，有地址。</span>
</span></span></code></pre></div><h2 id=16-map-类型>16 map 类型<a hidden class=anchor aria-hidden=true href=#16-map-类型>#</a></h2><p>一组无序的键值对。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>map</span><span class=p>[</span><span class=nx>key_type</span><span class=p>]</span><span class=nx>value_type</span>
</span></span></code></pre></div><p>key 的类型必须支持“==”和“!=”两种比较操作符。</p><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><ul><li><a href=https://go.dev/play/>The Go Playground</a></li></ul><p>&ndash; EOF &mdash;</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://zyf.im/tags/go/>Go</a></li></ul><nav class=paginav><a class=prev href=https://zyf.im/2023/02/15/kubernetes-getting-started-part1/><span class=title>« Prev</span><br><span>Kubernetes 入门实战 Part1</span>
</a><a class=next href=https://zyf.im/2022/12/31/review-2022/><span class=title>Next »</span><br><span>回顾 2022</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://zyf.im/>ZYF.IM BLOG</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>