<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Nginx on ZYF.IM BLOG</title>
    <link>https://zyf.im/tags/nginx/</link>
    <description>Recent content in Nginx on ZYF.IM BLOG</description>
    <generator>Hugo -- 0.147.9</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 26 Jun 2025 12:00:00 +0000</lastBuildDate>
    <atom:link href="https://zyf.im/tags/nginx/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>在本地环境使用 HTTPS</title>
      <link>https://zyf.im/2025/06/26/use-https-in-local-environment/</link>
      <pubDate>Thu, 26 Jun 2025 12:00:00 +0000</pubDate>
      <guid>https://zyf.im/2025/06/26/use-https-in-local-environment/</guid>
      <description>&lt;h2 id=&#34;配置&#34;&gt;配置&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/FiloSottile/mkcert&#34;&gt;mkcert&lt;/a&gt; 会在本地生成一套根 CA（包含根证书和私钥），并把根证书导入系统/浏览器的信任列表。随后，它用这套 CA 的私钥为 localhost 等域名签发服务器证书；因为根证书已被信任，浏览器访问时就会把服务器证书视为可信。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;brew install mkcert
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;mkcert -install
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;mkcert localhost
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# The certificate is at &amp;#34;./localhost.pem&amp;#34; and the key at &amp;#34;./localhost-key.pem&amp;#34; ✅&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# vi default.conf&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;server &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    listen &lt;span class=&#34;m&#34;&gt;443&lt;/span&gt; ssl&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    server_name localhost&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    ssl_certificate /etc/ssl/certs/localhost.pem&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    ssl_certificate_key /etc/ssl/certs/localhost-key.pem&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;# 只允许 TLSv1.2 和 TLSv1.3 协议，显示禁止 TLSv1.0 和 TLSv1.1 协议&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    ssl_protocols TLSv1.2 TLSv1.3&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;# 只保留高强度、带身份验证、且不使用 MD5 的 TLS 1.2（及以下）套件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    ssl_ciphers HIGH:!aNULL:!MD5&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;# 优先使用服务器端加密套件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    ssl_prefer_server_ciphers on&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    location / &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        root /usr/share/nginx/html&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        index  index.html index.htm&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker run -d --name nginx-ssl &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  -p 8443:443 &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  -v ./default.conf:/etc/nginx/conf.d/default.conf:ro &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  -v ./localhost.pem:/etc/ssl/certs/localhost.pem:ro &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  -v ./localhost-key.pem:/etc/ssl/certs/localhost-key.pem:ro &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  nginx:alpine
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# docker rm -f nginx-ssl&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# docker container restart nginx-ssl&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;测试&#34;&gt;测试&lt;/h2&gt;
&lt;h3 id=&#34;游览器&#34;&gt;游览器&lt;/h3&gt;
&lt;p&gt;游览器访问 &lt;code&gt;https://localhost:8443/&lt;/code&gt;，如果证书是绿色的，说明成功了。&lt;/p&gt;</description>
    </item>
    <item>
      <title>NGINX 前后端分离配置</title>
      <link>https://zyf.im/2020/03/17/nginx-front-back-end-config/</link>
      <pubDate>Tue, 17 Mar 2020 11:33:24 +0000</pubDate>
      <guid>https://zyf.im/2020/03/17/nginx-front-back-end-config/</guid>
      <description>&lt;p&gt;前后端分离的开发已是主流，本文主要是记录前后端分离项目的 NGINX 配置。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;ul&gt;
&lt;li&gt;前端 Vue web 入口 &lt;code&gt;host.test&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;后端 PHP Yii service 入口 &lt;code&gt;host.test/api&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-conf&#34; data-lang=&#34;conf&#34;&gt;server {
  listen 80;
  server_name host.test;
  root /data/project/web/dist/;
  index index.html index.php;

  location ^~/api {
    root           /data/project/service/web/;

    access_log     logs/service-access.log;
    error_log      logs/service-error.log;

    fastcgi_pass   127.0.0.1:9000;
    include        fastcgi.conf;
    fastcgi_param  SCRIPT_FILENAME   /data/project/service/web/index.php;
    fastcgi_param  SCRIPT_NAME       /api/index.php;
  }

  location /index.html {
    add_header Cache-Control &amp;#34;no-cache, no-store&amp;#34;;
  }

  location ^~ / {
    alias /data/project/web/dist/;
    access_log logs/web-access.log;
    error_log logs/web-error.log;
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;负载均衡场景&#34;&gt;负载均衡场景&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;前端 Vue web 入口 &lt;code&gt;host.test&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;后端 PHP Yii service 入口 &lt;code&gt;host.test/api&lt;/code&gt; 代理到 &lt;code&gt;api.host.test&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;web&#34;&gt;WEB&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-conf&#34; data-lang=&#34;conf&#34;&gt;server {
  listen 80;
  server_name host.test;
  root /data/project/web/dist/;

  access_log logs/web-access.log;
  error_log logs/web-error.log;

  location /index.html {
    add_header Cache-Control &amp;#34;no-cache, no-store&amp;#34;;
  }

  location / {
    index index.php index.html index.htm;
    try_files $uri $uri/ /index.html;
  }

  location ^~/api/ {
    proxy_set_header Host             api.host.test;
    proxy_set_header X-Real-IP        $remote_addr;
    proxy_set_header X-Forwarded-For  $proxy_add_x_forwarded_for;
    proxy_set_header X-NginX-Proxy    true;
    proxy_pass http://api.host.test/;
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;service&#34;&gt;SERVICE&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-conf&#34; data-lang=&#34;conf&#34;&gt;server {
  listen 80;
  server_name api.host.test;
  root /data/project/service/web/;

  location / {
    access_log logs/service-access.log;
    error_log logs/service-error.log;

    index index.php index.html;
    try_files $uri $uri/ /index.php$is_args$args;
  }

  location ~ \.php$ {
    fastcgi_pass    127.0.0.1:10071;

    fastcgi_index   index.php;
    include         fastcgi_params;
    fastcgi_param   SCRIPT_FILENAME   $document_root$fastcgi_script_name;
    fastcgi_param   SERVER_NAME       $http_host;
    fastcgi_ignore_client_abort       on;
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;nginx-配置转发&#34;&gt;NGINX 配置转发&lt;/h2&gt;
&lt;p&gt;location 进行的是模糊匹配。&lt;/p&gt;</description>
    </item>
    <item>
      <title>NGINX 禁止 IP 访问</title>
      <link>https://zyf.im/2018/05/20/nginx-ip-forbidden/</link>
      <pubDate>Sun, 20 May 2018 21:00:00 +0000</pubDate>
      <guid>https://zyf.im/2018/05/20/nginx-ip-forbidden/</guid>
      <description>&lt;p&gt;禁止 IP 访问，其他域名跳转到 &lt;code&gt;www.xxx.com&lt;/code&gt;：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-conf&#34; data-lang=&#34;conf&#34;&gt;server {
    listen 80;
    server_name 55.66.77.88;
    deny all;
}

server {
    listen 80;
    server_name www.xxx.com xxx.com;

    return 301 https://www.xxx.com$request_uri;
}

server {
    listen 443 ssl http2;

    #...

    if ($host = 55.66.77.88) {
        return 403;
    }
    if ($host != &amp;#39;www.xxx.com&amp;#39;){
        rewrite ^/(.*)$ https://www.xxx.com/$1 permanent;
    }

    #...
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&amp;ndash; EOF &amp;ndash;&lt;/p&gt;</description>
    </item>
    <item>
      <title>使用 Let&#39;s Encrypt 通配符证书</title>
      <link>https://zyf.im/2018/04/26/lets-encrypt-wildcard-certificates/</link>
      <pubDate>Thu, 26 Apr 2018 16:00:00 +0000</pubDate>
      <guid>https://zyf.im/2018/04/26/lets-encrypt-wildcard-certificates/</guid>
      <description>&lt;p&gt;一直在使用 &lt;a href=&#34;https://letsencrypt.org/&#34;&gt;Let&amp;rsquo;s Encrypt&lt;/a&gt; 的免费 SSL 证书，但是一直没做笔记。今天看到 Let&amp;rsquo;s Encrypt 支持了通配符证书（Wildcard Certificates），也就是说二级子域名和主域名可以共用一个证书。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;申请证书&#34;&gt;申请证书&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 下载证书申请客户端&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; /opt
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git clone https://github.com/certbot/certbot
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; /opt/certbot
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 注意通配符并不包含主域名，所以要配置两个&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;./certbot-auto certonly -d *.zyf.im -d zyf.im --manual --preferred-challenges dns --server &lt;span class=&#34;s2&#34;&gt;&amp;#34;https://acme-v02.api.letsencrypt.org/directory&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;-preferred-challenges dns&lt;/code&gt; 使用 DNS 方式校验域名所有权，所以会遇到：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;-------------------------------------------------------------------------------
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Please deploy a DNS TXT record under the name
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;_acme-challenge.zyf.im with the following value:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;YZ2unEViXH8nYZ2unEViIbW52LhIEViIbW52Lh
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Before continuing, verify the record is deployed.
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;-------------------------------------------------------------------------------
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Press Enter to Continue
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;要在域名服务商那里将 &lt;code&gt;_acme-challenge.zyf.im&lt;/code&gt; 配置 DNS TXT 记录，从而校验域名所有权。&lt;/p&gt;</description>
    </item>
    <item>
      <title>NGINX 启用 HTTP/2</title>
      <link>https://zyf.im/2017/06/06/nginx-enable-http2/</link>
      <pubDate>Tue, 06 Jun 2017 21:00:00 +0000</pubDate>
      <guid>https://zyf.im/2017/06/06/nginx-enable-http2/</guid>
      <description>&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;p&gt;HTTP/2（RFC 7540，2015 年发布）是自 1999 年 HTTP/1.1 以来的第一次重大升级，目标是在 不改变应用语义 的前提下，改善延迟、并发和网络效率。浏览器端基本只在 TLS 上启用（h2），明文版本 h2c 仅用于内部服务间通信。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;h2：HTTP/2 over TLS（最常见，浏览器只支持这一种）&lt;/li&gt;
&lt;li&gt;h2c：HTTP/2 over TCP（无加密）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;设计背景&#34;&gt;设计背景&lt;/h3&gt;
&lt;p&gt;移动端和富媒体时代，请求量激增，HTTP/1.1 的队头阻塞、多个 TCP 连接并行带来的 慢启动/拥塞竞争 成为瓶颈。&lt;/p&gt;
&lt;p&gt;谷歌的 SPDY 原型验证了“单连接、多路复用、压缩头部”等思路；IETF 在 SPDY 3.1 基础上标准化为 HTTP/2。&lt;/p&gt;
&lt;h3 id=&#34;核心特性&#34;&gt;核心特性&lt;/h3&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;特性&lt;/th&gt;
          &lt;th&gt;作用&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;二进制分帧 (Binary Framing)&lt;/td&gt;
          &lt;td&gt;把 HTTP 报文拆成小型 Frame；机器易解析、可并行&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;多路复用 (Multiplexing)&lt;/td&gt;
          &lt;td&gt;多个请求/响应 共享一个 TCP 连接，互不阻塞&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;流与优先级 (Stream &amp;amp; Priority)&lt;/td&gt;
          &lt;td&gt;每个请求是双向 Stream，可指定权重与依赖&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;头部压缩 (HPACK)&lt;/td&gt;
          &lt;td&gt;静态 Huffman + 动态表，大幅减少重复的 Header 字节&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;服务器推送 (Server Push)&lt;/td&gt;
          &lt;td&gt;服务器可在请求外预送资源 (已被多数浏览器弱化/关闭)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;流量控制&lt;/td&gt;
          &lt;td&gt;端到端窗口，避免单个大文件占满带宽&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;配置&#34;&gt;配置&lt;/h2&gt;
&lt;p&gt;启用 HTTP/2 需要使用 HTTPS，请先参考 &lt;a href=&#34;https://zyf.im/2025/06/26/use-https-in-local-environment/&#34;&gt;在本地环境使用 HTTPS ｜ ZYF.IM&lt;/a&gt;。&lt;/p&gt;</description>
    </item>
    <item>
      <title>PHP 中获取 Nginx 使用反向代理或 CDN 后的客户端真实 IP</title>
      <link>https://zyf.im/2017/06/02/php-get-real-ip-after-nginx-using-reverse-proxy-or-cdn/</link>
      <pubDate>Fri, 02 Jun 2017 16:00:00 +0000</pubDate>
      <guid>https://zyf.im/2017/06/02/php-get-real-ip-after-nginx-using-reverse-proxy-or-cdn/</guid>
      <description>&lt;p&gt;获取 Nginx 反向代理后的客户端 IP，基本是按一定顺序检测以下参数中的信息：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HTTP_CLIENT_IP&lt;/li&gt;
&lt;li&gt;HTTP_X_REAL_FORWARDED_FOR&lt;/li&gt;
&lt;li&gt;HTTP_X_FORWARDED_FOR&lt;/li&gt;
&lt;li&gt;REMOTE_ADDR&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;在未使用-cdn-和反向代理情况下&#34;&gt;在未使用 CDN 和反向代理情况下&lt;/h2&gt;
&lt;p&gt;当业务服务器直接暴露在公网上，并且未使用 CDN 和反向代理服务器时，可以直接使用 &lt;code&gt;remote_addr&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-php&#34; data-lang=&#34;php&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;$_SERVER&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;REMOTE_ADDR&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这时候 &lt;code&gt;HTTP_X_FORWARDED_FOR&lt;/code&gt; 和 &lt;code&gt;HTTP_X_REAL_IP&lt;/code&gt; 都是可以被伪造的，但 &lt;code&gt;REMOTE_ADDR&lt;/code&gt; 是客户端和服务器的握手 IP，即 client 的出口 IP，伪造不了。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;在使用-cdn-和反向代理情况下&#34;&gt;在使用 CDN 和反向代理情况下&lt;/h2&gt;
&lt;h3 id=&#34;铁律&#34;&gt;铁律&lt;/h3&gt;
&lt;p&gt;当多层代理或使用 CDN 时，如果代理服务器不把用户的真实 IP 传递下去，那么业务服务器将永远不可能获取到用户的真实 IP。&lt;/p&gt;
&lt;p&gt;如果 WEB 服务器上层也是使用 Nginx 做代理或负载均衡，则需要在代理层的 Nginx 配置中明确 XFF 参数，累加传递上一个请求方的 IP 到 header 请求中。以下是代理层的 Nginx 配置参数。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-conf&#34; data-lang=&#34;conf&#34;&gt;proxy_set_header X-Real-IP $remote_addr;
proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
proxy_set_header Host $http_host;
proxy_set_header X-NginX-Proxy true;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;只有一层代理的情况&#34;&gt;只有一层代理的情况&lt;/h3&gt;
&lt;p&gt;我们按上面的配置发起一个伪造请求，10.100.11.25 是我电脑的 IP，链路为：&lt;/p&gt;</description>
    </item>
    <item>
      <title>区分 NGINX 中 fastcgi_params fastcgi fastcgi-php</title>
      <link>https://zyf.im/2017/04/22/nginx-fastcgi-params-fastcgi-fastcgi-php/</link>
      <pubDate>Sat, 22 Apr 2017 12:00:00 +0000</pubDate>
      <guid>https://zyf.im/2017/04/22/nginx-fastcgi-params-fastcgi-fastcgi-php/</guid>
      <description>&lt;p&gt;NGNIX 有两份 fastcgi 配置文件，分别是 &lt;code&gt;fastcgi_params&lt;/code&gt; 和 &lt;code&gt;fastcgi.conf&lt;/code&gt;，其区别只有一点点。到目前为止，由于 package managers，他们仍然引起新用户的混淆。&lt;/p&gt;
&lt;p&gt;在自己系统中还有份 &lt;code&gt;snippets/fastcgi-php.conf&lt;/code&gt;，这个又是啥？&lt;/p&gt;
&lt;h2 id=&#34;fastcgi_params-vs-fastcgiconf&#34;&gt;fastcgi_params vs fastcgi.conf&lt;/h2&gt;
&lt;p&gt;它们都是用于配置 NGINX 与 FastCGI 应用程序通信的参数文件。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;fastcgi_params: 包含了FastCGI应用程序所需的最基本参数，如SCRIPT_FILENAME、QUERY_STRING等。这些参数通常不需要修改。&lt;/li&gt;
&lt;li&gt;fastcgi.conf: 包含了更高级的FastCGI参数，可以用于优化FastCGI应用程序的性能，如设置连接超时时间、缓冲区大小等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;fastcgi.conf&lt;/code&gt; 比 &lt;code&gt;fastcgi_params&lt;/code&gt; 多了一行 &lt;code&gt;SCRIPT_FILENAME&lt;/code&gt; 的定义&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-conf&#34; data-lang=&#34;conf&#34;&gt;fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注意：&lt;code&gt;$document_root&lt;/code&gt; 和 &lt;code&gt;$fastcgi_script_name&lt;/code&gt; 之间没有 &lt;code&gt;/&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;原本 NGNIX 只有 &lt;code&gt;fastcgi_params&lt;/code&gt;，后来发现很多人在定义 &lt;code&gt;SCRIPT_FILENAME&lt;/code&gt; 时使用了硬编码的方式，于是为了规范用法便引入了 &lt;code&gt;fastcgi.conf&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;不过这样的话就产生一个疑问：为什么一定要引入一个新的配置文件，而不是修改旧的配置文件？&lt;/p&gt;
&lt;p&gt;这是因为&lt;code&gt;fastcgi_param&lt;/code&gt; 指令是数组型的，和普通指令相同的是：内层替换外层；和普通指令不同的是：当在同级多次使用的时候，是新增而不是替换。&lt;/p&gt;
&lt;p&gt;换句话说，如果在同级定义两次 &lt;code&gt;SCRIPT_FILENAME&lt;/code&gt;，那么它们都会被发送到后端，这可能会导致一些潜在的问题，为了避免此类情况，便引入了一个新的配置文件。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-conf&#34; data-lang=&#34;conf&#34;&gt;server {
    listen 80;
    server_name foo.com;

    root /path;
    index index.html index.htm index.php;

    location / {
        try_files $uri $uri/ /index.php$is_args$args;
    }

    location ~ \.php$ {
        try_files $uri =404;

        include fastcgi.conf;
        fastcgi_pass 127.0.0.1:9000;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;fastcgi-phpconf&#34;&gt;fastcgi-php.conf&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;fastcgi-php.conf&lt;/code&gt; 是一个 Nginx 配置文件片段，用于配置 Nginx 服务器与 PHP FastCGI 进程之间的通信。它定义了 FastCGI 连接的参数和选项，以及如何处理 PHP 脚本。通常，这个文件是在 Nginx 的主配置文件中包含的，以确保 Nginx 能够正确地将请求发送到 PHP FastCGI 进程。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
