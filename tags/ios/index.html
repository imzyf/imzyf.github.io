<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Ios | ZYF.IM BLOG</title><meta name=keywords content><meta name=description content="Code. Create. Conquer."><meta name=author content="Me"><link rel=canonical href=https://zyf.im/tags/ios/><link crossorigin=anonymous href=/assets/css/stylesheet.63618a0fd0c7dd946ad6f368012c097fc6e5a8464cefd289c140dd28c01ec58d.css integrity="sha256-Y2GKD9DH3ZRq1vNoASwJf8blqEZM79KJwUDdKMAexY0=" rel="preload stylesheet" as=style><link rel=icon href=https://zyf.im/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zyf.im/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://zyf.im/favicon-32x32.png><link rel=apple-touch-icon href=https://zyf.im/apple-touch-icon.png><link rel=mask-icon href=https://zyf.im/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://zyf.im/tags/ios/index.xml><link rel=alternate hreflang=en href=https://zyf.im/tags/ios/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-6DVZ6E58DG"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-6DVZ6E58DG")}</script><meta property="og:url" content="https://zyf.im/tags/ios/"><meta property="og:site_name" content="ZYF.IM BLOG"><meta property="og:title" content="Ios"><meta property="og:description" content="Code. Create. Conquer."><meta property="og:locale" content="en-us"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Ios"><meta name=twitter:description content="Code. Create. Conquer."></head><body class="list dark" id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://zyf.im/ accesskey=h title="ZYF.IM (Alt + H)"><img src=https://zyf.im/apple-touch-icon.png alt aria-label=logo height=35>ZYF.IM</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://zyf.im/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://zyf.im/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://zyf.im/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://zyf.im/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://zyf.im/>Home</a>&nbsp;»&nbsp;<a href=https://zyf.im/tags/>Tags</a></div><h1>Ios
<a href=/tags/ios/index.xml title=RSS aria-label=RSS><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>fastlane 入门使用</h2></header><div class=entry-content><p>这次以 fastlane 为例，尝试项目中有什么事情可以被自动完成。
fastlane 是 Ruby scripts 的集合，安装方法不多说了见 官网文档。
fastlane 中有但不限于以下工具集：
produce 同时在 Apple Developer Portal 和 App Store Connect 中创建新的 iOS apps。 cert 自动创建和维护 iOS 签名证书。 sigh 创建，更新，下载和修复配置文件。 snapshot 自动在每台设备上获取 iOS 应用的本地化屏幕截图。 frameit 将您的屏幕截图放入正确的设备框架中。 gym 构建和打包您的 iOS apps。 deliver 将截图，元数据和您的应用上传到 App Store。 pem 自动生成并更新推送通知配置文件。 spaceship 一个 Ruby 库能够访问苹果开发者中心和应用商店连接 api。 pilot 自动化 TestFlight 部署并管理测试用户。 boarding 邀请 beta 测试人员。 match 使用 Git 同步整个团队的证书和配置文件。 scan 运行 app 测试。 实验环境：Xcode 10.1、Swift 4.2、fastlane 2.116.1、$99 开发者账户
...</p></div><footer class=entry-footer><span title='2019-02-28 10:00:00 +0800 CST'>February 28, 2019</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;657 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to fastlane 入门使用" href=https://zyf.im/2019/02/28/fastlane-getting-started/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>【Swifter - Swift 开发者必备 Tips】笔记</h2></header><div class=entry-content><p>再读王巍的【Swifter - Swift 开发者必备 Tips】，看看有什么新收获。
柯里化（Currying） 柯里化 是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术，这个词自己是第一次见到。
自己的理解就是：把接受多个参数的函数变换为，先接受一个参数，然后返回一个函数，这个函数再接受其他参数。
两个细节：
只有一个参数，并且这个参数是该函数的第一个参数。必须按照参数的定义顺序来调用柯里化函数。 柯里化函数的函数体只会执行一次，只会在调用完最后一个参数的时候执行柯里化函数体。 /// 一个数加 x 的函数 func addTo(_ adder: Int) -> (Int) -> Int { return { adder + $0 } } // +2 let addTwo = addTo(2) let result = addTwo(6) // 8 // +10 let addTen = addTo(10) addTen(6) // 16 柯里化是一种量产相似方法的好办法，可以通过柯里化一个方法模板来避免写出很多重复代码，也方便了今后维护。
书中还提到了一个封装 Selector 的例子，但是没懂，欢迎指教。
Reference:
Swift 函数柯里化介绍及使用场景 将 protocol 的方法声明为 mutating protocol 不仅可以被 class 类型实现，也适用于 struct 和 enum。因为这个原因就要考虑定义的方法是否应该使用 mutating 来修饰。在 protocl 中使用 mutating 修饰的方法，对于 class 的实现是完全透明的。
多元组（Tuple） python 中有见过类似。
/// 交互数据 func swapMe&lt;T>(_ a: inout T, _ b: inout T) { (a, b) = (b, a) } var a = 10 var b = 20 swapMe(&amp;a, &amp;b) // a: 20 b: 10 /// 可读的返回值 let rect = CGRect(x: 0, y: 0, width: 100, height: 100) let (slice, remainder) = rect.divided(atDistance: 20, from: .minYEdge) // slice {x 0 y 0 w 100 h 20} // remainder {x 0 y 20 w 100 h 80} @autoclosure 和 ?? @autoclosure 做的事情就是把一句表达式自动的封装成一个闭包（closure）。这样有时候在语法上看起来就会非常漂亮。
...</p></div><footer class=entry-footer><span title='2019-02-15 17:00:00 +0800 CST'>February 15, 2019</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;402 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 【Swifter - Swift 开发者必备 Tips】笔记" href=https://zyf.im/2019/02/15/swifter-tips-reading-notes/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>PromiseKit 入门使用</h2></header><div class=entry-content><p>在 GitHub Trending 中总是看到 mxcl/PromiseKit 它是主要解决的是 “回调地狱” 的问题，决定尝试用一下。
环境：Swift 4.2、PromiseKit 6
then and done 下面是一个典型的 promise 链式（chain）调用：
firstly { login() }.then { creds in fetch(avatar: creds.user) }.done { image in self.imageView = image } 如果这段代码使用完成回调（completion handler）实现，他将是：
login { creds, error in if let creds = creds { fetch(avatar: creds.user) { image, error in if let image = image { self.imageView = image } } } } then 是完成回调的另一种方式，但是它更丰富。在处级阶段的理解，它更具有可读性。上面的 promise chain 更容易阅读和理解：一个异步操作接着另一个，一行接一行。它与程序代码非常接近，因为我们很容易得到 Swift 的当前状态。
...</p></div><footer class=entry-footer><span title='2019-01-19 14:00:00 +0800 CST'>January 19, 2019</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;749 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to PromiseKit 入门使用" href=https://zyf.im/2019/01/19/promisekit-getting-started/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>解决 Too many symbol files</h2></header><div class=entry-content><p>在上传 App 到 App Store 后收到邮件，有 issues Too many symbol files。在之前看到 Your delivery was successful，此 issues 不影响发布，所以一直搁置了。
今天决定彻底处理下。
背景 先说 *.symbols 这文件是干嘛的，我现在（2018-10）对此的理解：
symbols 为符号表文件 符号表是内存地址与函数名、文件名、行号的映射表 &lt;起始地址> &lt;结束地址> &lt;函数> [&lt;文件名:行号>] 为什么要配置符号表？
为了能快速并准确地定位用户 App 发生 Crash 的代码位置，使用符号表对 App 发生 Crash 的程序 堆栈 进行 解析 和 还原。
项目情况 再说下项目情况，因为数字都是用了的是 Int，为防止 32 位设备发生越界情况（理由好像有点扯），所以项目端设置了设备限制 arm64，也就是 5s 之前的设备不可以安装。
因为使用了三方库，但是三方库是支持 32 位设备的，所以生成了冗余的 symbols 文件。
查询 symbols 文件的生成情况：Xcode Window -> Organizer 选择有问题的 archive，右击选择 Show in finder，命令行进入 *.app 中的 dSYMs 文件夹，执行 dwarfdump --uuid * 可以查询到是否生成了多余的文件。
...</p></div><footer class=entry-footer><span title='2018-10-30 14:00:00 +0800 CST'>October 30, 2018</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;142 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 解决 Too many symbol files" href=https://zyf.im/2018/10/30/correct-too-many-symbol-files-issues/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Swift 初始化</h2></header><div class=entry-content><p>因为自己是直接从 Swift 进入的 iOS 开发，Swift 与 Objective-C 初始化的对比就不多提了。感觉上 Swift 初始化的方式像 Java，自己也只这样套着 Java 去理解，但也发现了不相同的地方。
初始化顺序 class Blog: NSObject { let param: String override init() { } } 这里有条错误 error: property 'self.param' not initialized at implicitly generated super.init call 说明：param 参数没有在隐式生成 super.init 调用之前完成初始化。
Swift 中并不是不调用 super.init 而是为了方便开发者由编译器完成了这一步，但是要求调用 super.init 之前要完成成员变量的初始化。
class Blog: NSObject { let param: String override init() { param = "swift init" } } 对于需要修改父类中成员变量值，我们需要在调用 super.init 之后再进行修改：
class Cat { var name: String init() { name = "cat" } } class Tiger: Cat { let power: Int override init() { power = 10 super.init() name = "tiger" } } Swift 中类的初始化顺序：
...</p></div><footer class=entry-footer><span title='2018-03-31 17:00:00 +0800 CST'>March 31, 2018</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;972 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Swift 初始化" href=https://zyf.im/2018/03/31/swift-init/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>iOS Safe Area 我所知道的全部</h2></header><div class=entry-content><p>在 iOS 7 Apple 在 UIViewController 中引入了 topLayoutGuide 和 bottomLayoutGuide 属性来描述没有被覆盖(status bar, navigation bar, toolbar, tab bar, etc.)屏幕的区域。在 iOS 11 中，Apple 已经弃用了这些属性，并引入了 safe area。Apple 建议我们不要在 safe area 操作，在 iOS 11 中，当在 iOS App 中定位视图时，你必须使用新的 safe area API。
UIView 在 iOS 11 UIViewController topLayoutGuide 和 bottomLayoutGuide 属性已经被替换成了新的 UIView 中的 safe area：
@available(iOS 11.0, *) open var safeAreaInsets: UIEdgeInsets { get } @available(iOS 11.0, *) open var safeAreaLayoutGuide: UILayoutGuide { get } safeAreaInsets 属性意味着屏幕可以覆盖从四个方向，而不仅仅是顶部和底部。当被 iPhone X 呈现时，我们就明白了为什么我们需要左右 insets。
iPhone 8 vs iPhone X safe area (portrait orientation)
...</p></div><footer class=entry-footer><span title='2018-03-29 11:00:00 +0800 CST'>March 29, 2018</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;965 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to iOS Safe Area 我所知道的全部" href=https://zyf.im/2018/03/29/ios-safe-area/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>UITableViewCell 自适应 UITextView 高度</h2></header><div class=entry-content><p>使用 Auto Layout 让 UITableViewCell 自适应 UITextView 高度，效果演示：
99-projects-of-swift/029-tableviewcell-self-adaption
预备步骤 给 textView 上下左右建立相对于 cell 的约束 取消 textView 的 Scrolling Enabled 设置 tableView 估算高度 tableView.estimatedRowHeight = 70 设置 textView.delegate = self 关键点 如果在 textViewDidChange(textView:) 调用 tableView.reloadData() 会造成 textView 失去焦点，键盘隐藏。
解决方法：
func textViewDidChange(textView: UITextView) { tableView.beginUpdates() tableView.endUpdates() } 这里带来了一个问题，当 textView 长度超过一屏或者过长时，在输入时 tableView 会跳动滚动 jumping and stuttering。
更好的解决方法：
func textViewDidChange(textView: UITextView) { let currentOffset = tableView.contentOffset UIView.setAnimationsEnabled(false) tableView.beginUpdates() tableView.endUpdates() UIView.setAnimationsEnabled(true) tableView.setContentOffset(currentOffset, animated: false) } 禁用动画和重建表视图的内容偏移修正抖动。
...</p></div><footer class=entry-footer><span title='2018-03-27 16:00:00 +0800 CST'>March 27, 2018</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;87 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to UITableViewCell 自适应 UITextView 高度" href=https://zyf.im/2018/03/27/self-sizing-uitextview-in-a-uitableviewcell/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>【译】iOS 单元测试和 UI 测试入门教程</h2></header><div class=entry-content><p>iOS Unit Testing and UI Testing Tutorial
编写测试并不迷人 (glamorous)，但是既然测试能让你闪闪发光 (sparkling) 的应用程序避免变成 (from turning into) 一堆乱七八糟的垃圾，那么说明测试是必要的。如果你正在阅读这篇教程，那么你已经知道你 应该 为代码和 UI 编写测试，但是你可能不知道如何做。
也许你已经有一个 “可以运行” 的应用，但想测试你正在进行的扩展应用的更改。也许你已经编写了一些测试，但不确定它们是否是 正确 的测试。或者，你已经开始开发一个新应用，想要边开发边测试。
这篇教程将告诉你如何:
使用 Xcode 的测试导航器来测试应用的模型和异步方法 通过使用存根 (stubs) 和模拟对象 (mocks) 模拟与库或系统对象的交互 测试 UI 和性能 使用代码覆盖率工具 在此过程中，你将学到一些测试高手常用的专业术语。
开始 首先，下载教程素材。它包含一个基于 UIKit Apprentice 中的示例应用的 BullsEye 项目。这是一个简单的运气和机会游戏。游戏逻辑在 BullsEyeGame 类中，你将在本教程中对其进行测试。
测试什么 在编写任何测试之前，重要的是了解基础知识。你需要测试什么？
如果你的目标是扩展现有应用，你应该首先为计划更改的任何组件编写测试。
一般来说，测试应该覆盖：
核心功能：模型类和方法及其与控制器的交互 最常见的 UI 工作流 边界条件 Bug 修复 测试的最佳实践 首字母缩写 FIRST 描述了有效单元测试的一套简明标准。这些标准是：
Fast：测试应该快速运行。 Independent/Isolated：测试之间不应共享状态。 Repeatable：每次运行测试时，都应获得相同的结果。外部数据提供者或并发问题可能导致间歇性失败。 Self-validating：测试应完全自动化。输出应该是"通过"或"失败"，而不是依赖程序员对日志文件的解释。 Timely：理想情况下，你应该在编写生产代码之前编写测试它们的测试。这被称为测试驱动开发。 遵循 FIRST 原则将使你的测试保持清晰有用，而不会成为应用开发的障碍。
...</p></div><footer class=entry-footer><span title='2018-03-15 19:00:00 +0800 CST'>March 15, 2018</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;680 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 【译】iOS 单元测试和 UI 测试入门教程" href=https://zyf.im/2018/03/15/ios-unit-testing-and-ui-testing-tutorial/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>R.swift 强类型引用资源文件</h2></header><div class=entry-content><p>R.swift 获取强类型、自动编译的图片、字体、segues 等资源。
以避免无法编译时检查 字符串 的形式引用资源所导致的错误。
let icon = UIImage(named: "settings-icon") let font = UIFont(name: "San Francisco", size: 42) let color = UIColor(named: "indictator highlight") let viewController = CustomViewController(nibName: "CustomView", bundle: nil) let string = String(format: NSLocalizedString("welcome.withName", comment: ""), locale: NSLocale.current, "Arthur Dent") With R.swift
let icon = R.image.settingsIcon() let font = R.font.sanFrancisco(size: 42) let color = R.color.indicatorHighlight() let viewController = CustomViewController(nib: R.nib.customView.name) let string = R.string.localizable.welcomeWithName("Arthur Dent") 配置 其中 GitHub 上有的就不再累述了，主要注意：
添加 R.generated.swift 不要勾选 Copy items if needed，软引用就好。 要在 .gitignore 添加 *.generated.swift 以避免不必要的冲突。 添加新的资源文件后需要 command + b 编译下，才可以使用。
.clr 颜色文件的创建和使用 使用 Xcode 创建 .clr 文件：
之后可以在其中添加颜色，选择颜色回车可以对颜色从新命名。
生成的 .clr 文件保存在 ~/library/Colors 下，可以导入到项目后再通过 R.color 使用。
Tips 打开、关闭隐藏文件：
command + shift + . References XCode Tip: Color Palette</p></div><footer class=entry-footer><span title='2018-01-17 14:00:00 +0800 CST'>January 17, 2018</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;116 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to R.swift 强类型引用资源文件" href=https://zyf.im/2018/01/17/r-swift-getting-started/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Xcode 不知名的实用技巧</h2></header><div class=entry-content><p>状态栏 Help Search 框可以很方便的检索到相关的设置项。
Navigator ⌘ 1 .. ⌘ 7 可以切换窗口。
Show the Symbol navigator 在类不多时，可以方便看所有类的结构，类多时时使用下面的 filter 功能。
Show the Breakpoint navigator 点击右下角 + 选择 Exception Breakpoint..，可以在添加更明确的报错点，可以选择语言是 obj-c 还是 Swfit。
Utilities ⌘ ⌥ 1 .. ⌘ ⌥ 7 可以切换窗口。
Show the Code Snippet Library 代码片段模板，也可以将自己的写好的片段拖入。
Show the Media Library 可以直接从中拖拽图片成 UIImageView 放入 xib 中。
...</p></div><footer class=entry-footer><span title='2018-01-12 13:00:00 +0800 CST'>January 12, 2018</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;159 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Xcode 不知名的实用技巧" href=https://zyf.im/2018/01/12/xcode-tips/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://zyf.im/tags/ios/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://zyf.im/>ZYF.IM BLOG</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>