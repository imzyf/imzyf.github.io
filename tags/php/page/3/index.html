<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Php | ZYF.IM BLOG</title>
<meta name=keywords content><meta name=description content="Code. Create. Conquer."><meta name=author content="Me"><link rel=canonical href=https://zyf.im/tags/php/><link crossorigin=anonymous href=/assets/css/stylesheet.4997c86cdc3165a43745858554a5b14aaf4d3769db9f06a36b0c69ef98eb2927.css integrity="sha256-SZfIbNwxZaQ3RYWFVKWxSq9NN2nbnwajawxp75jrKSc=" rel="preload stylesheet" as=style><link rel=icon href=https://zyf.im/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zyf.im/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://zyf.im/favicon-32x32.png><link rel=apple-touch-icon href=https://zyf.im/apple-touch-icon.png><link rel=mask-icon href=https://zyf.im/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://zyf.im/tags/php/index.xml><link rel=alternate hreflang=en href=https://zyf.im/tags/php/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-6DVZ6E58DG"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-6DVZ6E58DG")}</script><meta property="og:url" content="https://zyf.im/tags/php/"><meta property="og:site_name" content="ZYF.IM BLOG"><meta property="og:title" content="Php"><meta property="og:description" content="Code. Create. Conquer."><meta property="og:locale" content="en-us"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Php"><meta name=twitter:description content="Code. Create. Conquer."></head><body class="list dark" id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://zyf.im/ accesskey=h title="ZYF.IM (Alt + H)"><img src=https://zyf.im/apple-touch-icon.png alt aria-label=logo height=35>ZYF.IM</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://zyf.im/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://zyf.im/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://zyf.im/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://zyf.im/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://zyf.im/>Home</a>&nbsp;»&nbsp;<a href=https://zyf.im/tags/>Tags</a></div><h1>Php
<a href=/tags/php/index.xml title=RSS aria-label=RSS><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Lonicera Framework</h2></header><div class=entry-content><p>项目代码：imzyf/lonicera | GitHub
【PHP 核心技术与最佳实践】第二版 第 6 章 读书笔记
Lonicera Framework - Every French soldier carries a marshal’s baton in his knapsack.
MVC MVC 模式的目的是实现一种动态的程序设计，使后续对程序的修改和扩展简化，并且使程序某一部分的重复利用成为可能。
Lonicera 0.1 bootstrap index.php 单一入口模式。
启动 PHP 内置 Web 服务器：
php -S localhost:7070 路由器层 更偏向于使用 PATH_INFO 方式来访问。
从传统 URL 参数模式的访问地址进行解析，提取里面的 group、controller、action、param 4 个参数，随后交给 bootstrap 进行 dispatch 处理。
数据模型 用 PDO 来实现连接数据库。
ORM Object Relational Mapping 对象与数据库的映射叫作对象关系映射 PO Persistent Object 把一个数据库中的表的一行记录对应的对象称为持久对象 BO Business Object 业务对象 把业务逻辑封装为一个对象 VO Value Object 值对象 界面显示的数据对象 DTO Data Transfer Object 用在热呵呵需要数据传输的地方 DAO Data Access Object 指代 Active Record 模式中的数据对象 传统的 ORM 模式提倡数据对象和负责持久化的代码的分开，但是这并没有坚持数据操作的工作量。还有一种 ORM 模式叫作 Active Record。在 Active Record 中，模型层集成了 ORM 的功能，他们及代表实体，包含因为业务逻辑，又是数据对象，并负责把自己存储到数据库中。
...</p></div><footer class=entry-footer><span title='2019-12-19 16:46:06 +0000 UTC'>December 19, 2019</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;281 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Lonicera Framework" href=https://zyf.im/2019/12/19/lonicera-framework/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>归并排序</h2></header><div class=entry-content><p>归并排序（英语：Merge sort，或 mergesort），是创建在归并操作上的一种有效的排序算法，效率为 O(nlogn)。1945 年由约翰·冯·诺伊曼首次提出。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。
采用分治法：
分割：递归地把当前序列平均分割成两半。 集成：在保持元素顺序的同时将上一步得到的子序列集成到一起（归并）。 归并操作（merge），也叫归并算法，指的是将两个已经排序的序列合并成一个序列的操作。归并排序算法依赖归并操作。
&lt;?php function mergeSort($arr) { $len = count($arr); if ($len &lt;= 1) { return $arr; } // 递归结束条件, 到达这步的时候, 数组就只剩下一个元素了, 也就是分离了数组 $mid = $len / 2; $left = array_slice($arr, 0, $mid); // 拆分数组0-mid这部分给左边left $right = array_slice($arr, $mid); // 拆分数组mid-末尾这部分给右边right $left = mergeSort($left); // 左边拆分完后开始递归合并往上走 $right = mergeSort($right); // 右边拆分完毕开始递归往上走 $arr = merge($left, $right); // 合并两个数组,继续递归 return $arr; } // merge函数将指定的两个有序数组(arrA, arr)合并并且排序 function merge($arrA, $arrB) { $arrC = array(); while (count($arrA) && count($arrB)) { // 这里不断的判断哪个值小, 就将小的值给到arrC, 但是到最后肯定要剩下几个值, // 不是剩下arrA里面的就是剩下arrB里面的而且这几个有序的值, 肯定比arrC里面所有的值都大所以使用 $arrC[] = $arrA[0] &lt; $arrB[0] ? array_shift($arrA) : array_shift($arrB); } return array_merge($arrC, $arrA, $arrB); } $startTime = microtime(1); $arr = range(1, 1000); shuffle($arr); echo 'before sort: ', implode(', ', $arr), "\n"; $sortArr = mergeSort($arr); echo 'after sort: ', implode(', ', $sortArr), "\n"; echo 'use time: ', microtime(1) - $startTime, "s\n"; 假设被排序的数列中有 N 个数。遍历一趟的时间复杂度是 O(N)，需要遍历多少次呢？
...</p></div><footer class=entry-footer><span title='2019-05-23 14:44:40 +0000 UTC'>May 23, 2019</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;156 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 归并排序" href=https://zyf.im/2019/05/23/merge-sort/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Laravel 中 composer 加载流程</h2></header><div class=entry-content><p>启动 Laravel 5.8 文章以 Laravel 学习。入口文件 public/index.php：
// Register The Auto Loader require __DIR__.'/../vendor/autoload.php'; autoload.php 不负责具体功能逻辑，只做了两件事：初始化自动加载类、注册自动加载类。
autoload_real.php 中的类名为 ComposerAutoloaderInit... 这可能是为防止与用户自定义类名跟这个类重复冲突，加上了哈希值。
其实还有一个做法我们更加熟悉，是定义一个命名空间。这里为什么不定义一个命名空间呢？一种理解：命名空间一般都是为了复用，而这个类只需要运行一次即可，以后也不会用得到，用哈希值更加合适。
autoload_real.php autoload.php 主要调用了 getLoader()：
public static function getLoader() { // 单例模式，自动加载类只能有一个 1 if (null !== self::$loader) { return self::$loader; } // 获得自动加载核心类对象 2 spl_autoload_register(array('ComposerAutoloaderInit76e88f0b305cd64c7c84b90b278c31db', 'loadClassLoader'), true, true); self::$loader = $loader = new \Composer\Autoload\ClassLoader(); spl_autoload_unregister(array('ComposerAutoloaderInit76e88f0b305cd64c7c84b90b278c31db', 'loadClassLoader')); // 初始化自动加载核心类对象 3 $useStaticLoader = PHP_VERSION_ID >= 50600 && !defined('HHVM_VERSION') && (!function_exists('zend_loader_file_encoded') || !zend_loader_file_encoded()); if ($useStaticLoader) { require_once __DIR__ . '/autoload_static.php'; call_user_func(\Composer\Autoload\ComposerStaticInit76e88f0b305cd64c7c84b90b278c31db::getInitializer($loader)); } else { $map = require __DIR__ . '/autoload_namespaces.php'; foreach ($map as $namespace => $path) { $loader->set($namespace, $path); } $map = require __DIR__ . '/autoload_psr4.php'; foreach ($map as $namespace => $path) { $loader->setPsr4($namespace, $path); } $classMap = require __DIR__ . '/autoload_classmap.php'; if ($classMap) { $loader->addClassMap($classMap); } } // 注册自动加载核心类对象 4 $loader->register(true); // 自动加载全局函数 5 if ($useStaticLoader) { $includeFiles = Composer\Autoload\ComposerStaticInit76e88f0b305cd64c7c84b90b278c31db::$files; } else { $includeFiles = require __DIR__ . '/autoload_files.php'; } foreach ($includeFiles as $fileIdentifier => $file) { composerRequire76e88f0b305cd64c7c84b90b278c31db($fileIdentifier, $file); } return $loader; } 单例模式 1 if (null !== self::$loader) { return self::$loader; } 构造 ClassLoader 核心类 2 spl_autoload_register(array('ComposerAutoloaderInit76e88f0b305cd64c7c84b90b278c31db', 'loadClassLoader'), true, true); self::$loader = $loader = new \Composer\Autoload\ClassLoader(); spl_autoload_unregister(array('ComposerAutoloaderInit76e88f0b305cd64c7c84b90b278c31db', 'loadClassLoader')); public static function loadClassLoader($class) { if ('Composer\Autoload\ClassLoader' === $class) { require __DIR__ . '/ClassLoader.php'; } } composer 先向 PHP 自动加载机制注册了一个函数，这个函数 require 了 ClassLoader 文件。成功 new 出该文件中核心类 ClassLoader() 后，又销毁了该函数。
...</p></div><footer class=entry-footer><span title='2019-04-28 19:21:12 +0000 UTC'>April 28, 2019</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;1435 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Laravel 中 composer 加载流程" href=https://zyf.im/2019/04/28/composer-autoload-in-laravel/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>PHP 请小心判断 strpos</h2></header><div class=entry-content><p>又开始写世界上最后的语言 PHP 了（狗头保命）。一个很简单的字符串是否包含判断就掉坑了。
方法签名：
strpos ( string $haystack , mixed $needle [, int $offset = 0 ] ) : int $mystring = 'abc'; $findme = 'a'; if (strpos($mystring, $findme)) { dump('yes'); } 注意这时是不会输出 yes，因为 strpos($mystring, $findme) 返回的是 0。就想官方文档说的：
Warning 此函数可能返回布尔值 FALSE，但也可能返回等同于 FALSE 的非布尔值。应使用 === 运算符来测试此函数的返回值。
正解：
if (strpos($mystring, $findme) !== false) { dump('yes'); } 这次问题是网上一搜，找到 strpos 后看到 如果没找到 needle，将返回 FALSE 就没多想就用了。语言间的差异还有注意。
References php.net - strpos – EOF –</p></div><footer class=entry-footer><span title='2019-04-10 20:27:21 +0000 UTC'>April 10, 2019</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;68 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to PHP 请小心判断 strpos" href=https://zyf.im/2019/04/10/php-strpos-warning/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>L01 Web 开发实战入门</h2></header><div class=entry-content><p>Laravel 教程 - Web 开发实战入门
基础信息 Laravel 与 PHP Ruby on Rails 有以下原则：
强调与注重敏捷开发； 约定高于配置（Convention over configuration）； DRY（Don’t repeat yourself）不要重复自己，提倡代码重用； 重视「编码愉悦性」。 如何正确阅读本书 随后你会有很多机会来学习它们。现在最重要的是保持『训练』的连贯性。
编程是技能，不是知识，技能只有在不断刻意练习下才会有进步。
开发环境布置 第一个应用 composer create-project laravel/laravel Laravel --prefer-dist "5.5.*" Git 与 GitHub 设置 push 的默认模式为 simple
git config --global push.default simple 部署上线 注册 Heroku 后：
heroku login # 添加 SSH Key 到 Heroku 上 heroku keys:add # 创建配置文件来告诉 Heroku 应当使用什么命令来启动 Web 服务器 echo web: vendor/bin/heroku-php-apache2 public/ > Procfile git add -A git commit -m "Procfile for Heroku" # 创建一个新应用 heroku create # 对应用名称进行更改，保证未被其它人占用 heroku rename imzyf-laravel-essential # 声明应用是用 PHP 写的 heroku buildpacks:set heroku/php # 设置 APP key php artisan key:generate heroku config:set APP_KEY=base64:wuWj8Kicza6I9YxgWczviNVcueVN2RroqiUILreyNmA= # 部署上线 git push heroku master # 快速打开线上应用 heroku open # 输出生产环境上的日志 heroku logs 构建页面 静态页面 生成静态页面控制器：
...</p></div><footer class=entry-footer><span title='2018-05-09 17:00:00 +0000 UTC'>May 9, 2018</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;371 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to L01 Web 开发实战入门" href=https://zyf.im/2018/05/09/laravel-essential-training-reading-notes/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>【Modern PHP】笔记</h2></header><div class=entry-content><p>又回到 PHP Web 开发，使用 Laravel 框架，重读《Modern PHP》。
PHP 正在重生。
特性 命名空间 声明命名空间：
&lt;?php namespace Oreilly\ModernPHP; 导入和别名：
&lt;?php use Symfony\Component\HttpFoundation\Response as Res; $r = new Res('Oops', 400); $r->send(); PHP 5.6 开始可以导入函数和常量：
&lt;?php use func Namespace\functionName; use constant Namespace\CONST_NAME; functionName(); echo CONST_NAME; 使用接口 接口是两个 PHP 对象之间的契约，其目的不是让一个对象依赖另一个对象的身份，而是依赖另一个对象的能力。
使用接口编写更加灵活，能委托别人实现细节。
性状 trait 性状是类的部分实现，可以混入一个或者多个现有的 PHP 类中。性状有两个作用：表明类可以做什么（像是接口）；提供模块化实现（像是类）。
如果想让两个无关的 PHP 类具有类似的行为，应该怎么呢？性状就是为了解决这种问题而诞生的。性状能把模块化的实现方式注入多个无关的类中。而且性状还能促进代码的重用。
这与创建一个接口，两个无关的类实现这个接口的优势在于：不用写相同的实现代码，符合 DRY 原则。
PHP 解释器在编译时会把性状复制粘贴到类的定义体中，但是不会处理这个操作引入的不兼容问题。如果性状假定类中有特定的属性和方法（在性状中没有定义），要确保相应的类中有对应的属性和方法。
生成器 Generator 是 PHP 5.5.0 引入的功能。生成器是简单的迭代器，仅此而已。
PHP 生成器不要求类实现 Iterator 接口，从而减轻了类的负担。生成器会根据需求计算并产生要迭代的值。这对应该的性能有重大影响。假如标准的 PHP 迭代器经常在内存中执行迭代操作，这要预先计算出数据集，性能低；此时我们可以使用生成器，即时计算并产出后续值，不占用宝贵的内存资源。
PHP 生成器不能满足所有迭代操作的需求，因为如果不查询，生成器永远不知道下一个要迭代的值是什么，在生成器中无法后退和快进。生成器还是一次性，无法多次迭代同一个生成器。不过，如果需要，可以重建或克隆生成器。
PHP 生成器是 PHP 函数，只不过要在函数中一次或者多次使用 yield 关键字。生成器从不返回值，值产出值。
...</p></div><footer class=entry-footer><span title='2018-05-08 17:00:00 +0000 UTC'>May 8, 2018</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;572 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 【Modern PHP】笔记" href=https://zyf.im/2018/05/08/modern-php-reading-notes/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>PhpStorm 使用经验</h2></header><div class=entry-content><p>Getting Started Two shortcuts to get started
Shift+Shift(⇧+⇧) helps you find anything within your project. Alt+Enter(Option+Enter) provides instant access to contextual actions and quick fixes relevant to the selected code. Getting started with PHP in PhpStorm
还有个 One Dark theme 但是 Material Theme UI 已经包含这个主题。
配置：
Preferences > Appearance & Behavior > Appearance 下，右侧配置：Theme: Darcula，勾选 User custom font: .AppleSystemUIFont Size: 18。
Preferences > Editor > Font 下，右侧配置：Font: Menlo Size: 18 Line spacing: 1.2。
...</p></div><footer class=entry-footer><span title='2018-05-05 14:00:00 +0000 UTC'>May 5, 2018</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;433 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to PhpStorm 使用经验" href=https://zyf.im/2018/05/05/phpstorm-using-experience/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>PHP 中获取 Nginx 使用反向代理或 CDN 后的客户端真实 IP</h2></header><div class=entry-content><p>获取 Nginx 反向代理后的客户端 IP，基本是按一定顺序检测以下参数中的信息：
HTTP_CLIENT_IP HTTP_X_REAL_FORWARDED_FOR HTTP_X_FORWARDED_FOR REMOTE_ADDR 在未使用 CDN 和反向代理情况下 当业务服务器直接暴露在公网上，并且未使用 CDN 和反向代理服务器时，可以直接使用 remote_addr：
$_SERVER['REMOTE_ADDR'] 这时候 HTTP_X_FORWARDED_FOR 和 HTTP_X_REAL_IP 都是可以被伪造的，但 REMOTE_ADDR 是客户端和服务器的握手 IP，即 client 的出口 IP，伪造不了。
在使用 CDN 和反向代理情况下 铁律 当多层代理或使用 CDN 时，如果代理服务器不把用户的真实 IP 传递下去，那么业务服务器将永远不可能获取到用户的真实 IP。
如果 WEB 服务器上层也是使用 Nginx 做代理或负载均衡，则需要在代理层的 Nginx 配置中明确 XFF 参数，累加传递上一个请求方的 IP 到 header 请求中。以下是代理层的 Nginx 配置参数。
proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_set_header X-NginX-Proxy true; 只有一层代理的情况 我们按上面的配置发起一个伪造请求，10.100.11.25 是我电脑的 IP，链路为：
...</p></div><footer class=entry-footer><span title='2017-06-02 16:00:00 +0000 UTC'>June 2, 2017</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;438 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to PHP 中获取 Nginx 使用反向代理或 CDN 后的客户端真实 IP" href=https://zyf.im/2017/06/02/php-get-real-ip-after-nginx-using-reverse-proxy-or-cdn/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>PHP 中 this self parent 用法</h2></header><div class=entry-content><p>self:: 调用本类属性、方法；可以抑制方法多态性。 parent:: 调用父类属性、方法。 static:: 调用静态属性、方法；可以体现多态性。 $this-> 调用本实例的属性、方法；$this:: 可以调用静态属性、方法；但是无法在静态方法里使用；可以体现多态性。 -> object-operator, you always know you’re dealing with an instance. :: scope-resolution-operator, you need more information about the context. &lt;?php class A { public static function newStaticClass() { return new static(); } public static function newSelfClass() { return new self(); } public function newThisClass() { return new $this(); } } class B extends A { public function newParentClass() { return new parent(); } } class C extends B { public static function newSelfClass() { return new self(); } } $c = new C(); var_dump($c::newStaticClass()); // C and is same C::newStaticClass() var_dump($c::newSelfClass()); // C because self now points to "C" class var_dump($c->newThisClass()); // C var_dump($c->newParentClass()); // A because parent was defined *way back* in class "B" References php - When to use self over $this? - Stack Overflow</p></div><footer class=entry-footer><span title='2017-05-25 15:00:00 +0000 UTC'>May 25, 2017</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;136 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to PHP 中 this self parent 用法" href=https://zyf.im/2017/05/25/how-to-use-this-self-parent-in-php/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>区分 NGINX 中 fastcgi_params fastcgi fastcgi-php</h2></header><div class=entry-content><p>NGNIX 有两份 fastcgi 配置文件，分别是 fastcgi_params 和 fastcgi.conf，其区别只有一点点。到目前为止，由于 package managers，他们仍然引起新用户的混淆。
在自己系统中还有份 snippets/fastcgi-php.conf，这个又是啥？
fastcgi_params vs fastcgi.conf 它们都是用于配置 NGINX 与 FastCGI 应用程序通信的参数文件。
fastcgi_params: 包含了FastCGI应用程序所需的最基本参数，如SCRIPT_FILENAME、QUERY_STRING等。这些参数通常不需要修改。 fastcgi.conf: 包含了更高级的FastCGI参数，可以用于优化FastCGI应用程序的性能，如设置连接超时时间、缓冲区大小等。 fastcgi.conf 比 fastcgi_params 多了一行 SCRIPT_FILENAME 的定义
fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; 注意：$document_root 和 $fastcgi_script_name 之间没有 /。
原本 NGNIX 只有 fastcgi_params，后来发现很多人在定义 SCRIPT_FILENAME 时使用了硬编码的方式，于是为了规范用法便引入了 fastcgi.conf。
不过这样的话就产生一个疑问：为什么一定要引入一个新的配置文件，而不是修改旧的配置文件？
这是因为fastcgi_param 指令是数组型的，和普通指令相同的是：内层替换外层；和普通指令不同的是：当在同级多次使用的时候，是新增而不是替换。
换句话说，如果在同级定义两次 SCRIPT_FILENAME，那么它们都会被发送到后端，这可能会导致一些潜在的问题，为了避免此类情况，便引入了一个新的配置文件。
server { listen 80; server_name foo.com; root /path; index index.html index.htm index.php; location / { try_files $uri $uri/ /index.php$is_args$args; } location ~ \.php$ { try_files $uri =404; include fastcgi.conf; fastcgi_pass 127.0.0.1:9000; } } fastcgi-php.conf fastcgi-php.conf 是一个 Nginx 配置文件片段，用于配置 Nginx 服务器与 PHP FastCGI 进程之间的通信。它定义了 FastCGI 连接的参数和选项，以及如何处理 PHP 脚本。通常，这个文件是在 Nginx 的主配置文件中包含的，以确保 Nginx 能够正确地将请求发送到 PHP FastCGI 进程。
...</p></div><footer class=entry-footer><span title='2017-04-22 12:00:00 +0000 UTC'>April 22, 2017</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;234 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 区分 NGINX 中 fastcgi_params fastcgi fastcgi-php" href=https://zyf.im/2017/04/22/nginx-fastcgi-params-fastcgi-fastcgi-php/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://zyf.im/tags/php/page/2/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://zyf.im/tags/php/page/4/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://zyf.im/>ZYF.IM BLOG</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>